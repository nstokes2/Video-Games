
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using SkinnedModel;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;

using Microsoft.Xna.Framework.Input;

namespace SmellOfRevenge2011
{
    public class JuneXnaModel
    {
        //done like this to distinguish between waitTIme which is already used
        public TimeSpan timeToWait = TimeSpan.Zero;
        public bool falling = false;
        public bool jumping = false;
        public bool endJump = false;
        public double maxJumpTime = .75;
        public double currentJumpTime = 0;
        public bool attackPhase = false;
        public bool movePhase = true;
        public List<BoundingSphere> oldSpheres;
        public int arrowTimer = 100;
        public double arrowTime = 0;
        public float angle = 0; 
        public List<BoundingSphere> rangeSpheres;
        //A1A2B1B2X1X2Y1Y2
        public int type = 0;
        public int spareParts = 0;
        public int cpus = 0;
        public int antennas = 0;
        public int powerCharges = 0;
        public bool moveLeft = false;
        public bool moveRight = false;
        public Vector3 outOfWayPos = Vector3.Zero;
        public int mSphereIndex = 0; 
        public BoundingBox collisionBox;
        public List<BoundingBox> setBoxes;
        public List<List<BoundingBox>> moveBoxes;
        //public 
        public bool separating = false;
        public Vector3 sepDirection = Vector3.Zero;
        public int separatedFor = 0;
        public List<BoundingSphere> toTarget;

        public bool validRange = false;
        public List<Arrow> arrows;
        public bool hasAllyTargetCursor = false;
        public int allyTargetIndex = -1;
        public bool atBase = false;
        public TimeSpan baseTime = TimeSpan.Zero;
        public bool chaseDown = false;
        //public bool hasTarget = false;
        public BoundingSphere NWSphere;
        public BoundingSphere NSphere;
        public BoundingSphere NESphere;
        public BoundingSphere ESphere;
        public BoundingSphere WSphere;
        public BoundingSphere SWSphere;
        public BoundingSphere SESphere;
        public BoundingSphere SSphere;
        public List<List<bool>> IncOpen;
        public List<List<BoundingSphere>> IncrementalSpheres;
        public List<List<BoundingSphere>> NWSpheres;
        public List<List<BoundingSphere>> NSpheres;
        public List<List<BoundingSphere>> NESpheres;
        public List<List<BoundingSphere>> WSpheres;
        public List<List<BoundingSphere>> ESpheres;
        public List<List<BoundingSphere>> SWSpheres;
        public List<List<BoundingSphere>> SESpheres;
        public List<List<BoundingSphere>> SSpheres;
        public int runnerIndex = 0;
        //int targetIndex = 0;
        public bool isDefender = false;
        public bool isMonster = false;
        public bool isFighter = false;
        public bool isRunner = false;
        bool runToBase = false;
        bool followTheseus = false;
        bool hasTarget = false;
        public List<BoundingSphere> atkSpheres = new List<BoundingSphere>();
        int targetI = 0;
        int targetJ = 0;
        public List<int> hits = new List<int>();
        TimeSpan waitTime = TimeSpan.Zero;
        Vector3 newPosition = Vector3.Zero;
        BoundingSphere newPosSphere = new BoundingSphere();
        Vector3 outOfWayDirection = Vector3.Zero;
        BoundingSphere formerSpace = new BoundingSphere();
        bool atPosition = false;
        bool getOutOfWay = false;
        List<int> unitsOutOfWay = new List<int>();
        List<int> outOfWayFor = new List<int>();
        BoundingSphere cullSphere = new BoundingSphere();
         bool xOnZero = true;
         bool yOnZero = true;
         bool xOnBounds = true;
         bool yOnBounds = true;
         List<int> collisionGroup;
         int assignedColGroup = 0;
         bool hasColGroup = false;
         int collisionCount = 0;
        public  int setSphereCount = 0;
        public  bool moveWait = false;
        //0 is they go along together
        public int moveResolution = 0;
        ///0 unimpeded 1 blocked by enemy ai 2 blocked by player 
        public  int moveState = 0;
        
        public  List<BoundingSphere> futureMovement;
        public List<BoundingSphere> smoothSpheres;
        Random rand;
        public TimeSpan cutOffTime;
        public TimeSpan aiDecisionTimer;
        public TimeSpan minDecisionTimer;
        public TimeSpan maxDecisionTimer;
        
        /// <summary>
        /// 0 is wander, 1 is theseus melee, 2 is theseus range, 3 is encircle, 4 is retreat to direction
        /// </summary>
        public int aiState;
        public Vector3 plannedPosition;
        public bool havePlannedPosition = false;
        public bool isHoldAtk1, isHoldAtk2, isHoldAtk3;
        public bool lockTarget3 = false;
        public bool lockTarget2 = false;
        public bool lockTarget = false;
        public List<int> hitTags;
        public List<float> hitDist;
        public bool newClick = false;
        public float pRotationAmount = 0.0f;
        public int pstate = 0; 
        public horizontalRing fireRings;
        public BoundingSphere IFSphere = new BoundingSphere();
        public BoundingSphere EWSphere = new BoundingSphere();
        public bool RingOfFire = false;
        public TimeSpan ROFTime = TimeSpan.Zero;
        public bool RockOrbit = false;
        public TimeSpan ROTime = TimeSpan.Zero;
        public bool Heal = false;
        public TimeSpan HTime = TimeSpan.Zero;
        public bool EnvelopingWinds = false;
        public TimeSpan EWTime = TimeSpan.Zero;
        public float IFRadius = 50.0f;
        public float speed = 5.0f;
        public float armor = 0.0f;
        public float rABonus = 0.0f;
        public float avalancheDebuff = 0.0f;
        public float icyFieldDebuff = 0.0f;
        public bool BoilingBlood = false;
        public TimeSpan BBTimer = TimeSpan.Zero;
        public bool RockArmor = false;
        public TimeSpan RATimer = TimeSpan.Zero;
        public bool IcyField = false;
        public TimeSpan IFTimer = TimeSpan.Zero;
        public bool PowerGust = false;
        public TimeSpan PGTimer = TimeSpan.Zero;
        public List<horizontalRing> hRs = new List<horizontalRing>();
        public Vector3 kbVec = Vector3.Zero;
        public TimeSpan kbTimer = TimeSpan.Zero;
        public bool isAPSet = false;
        public Vector3 adjustedPosition = Vector3.Zero;
        public List<horizontalCircle> hCs = new List<horizontalCircle>();
        public List<horizontalForward> hFs = new List<horizontalForward>();
        public bool leftSide = true;
        public int lSelection = 0;
        public int rSelection = 0; 
        public List<Rune> runes = new List<Rune>();
        //public List<string> runes = new List<string>();
        //public List<int> amount = new List<int>();
        public bool modTower = false;
        public bool combRune = false;
        public bool subRune = false;
        public bool addRune = false;
        public bool runeSelected = false;
        public bool towerSelected = false;
        public bool remove = false;
        public bool ghost = false;
        public int gState = 0; 
        public int mState = 0;
        public List<Vector3> mWayPoints = new List<Vector3>();
        public bool healing = false;
        public bool upgradeCon = false;
        public bool healCon = false;
        public bool buildWall = false;
        public bool physicalTower = false;
        public bool construction = false;
        public bool buildTower = false;
        public bool spellList = false;
        public Matrix projectileWorld = Matrix.Identity;
        public Vector3 Projected = Vector3.Zero;
        public Vector3? TargetCursor3 = new Vector3?(Vector3.Zero);
        public Vector2 TargetCursor = Vector2.Zero;
        public Vector3 TargetDirection = Vector3.Zero;
        public Vector3 buildDirection;
        public BoundingSphere TargetSphere = new BoundingSphere();
        public BoundingSphere buildSphere1;
        public BoundingSphere buildSphere2;
        public bool buildPhase1 = false;
        public bool buildPhase2 = false;
        public Wall wall;
        public Vector3 TargetTrans = Vector3.Zero;
        /// <summary>
        /// 0 is ares 1 is player 2 is tower 3 is no target
        /// </summary>
        public int fighterState = 3;
        public int towerIndex = 0;
        public List<Construct> constructs = new List<Construct>();
        /// <summary>
        /// 0 = move to tower 1 = move to setSphere
        /// </summary>
        //FIRE 1 SET
        public bool pyre1 = false;
        public bool fireBall1 = false;
        public bool ringOfFire1 = false;
        public bool blazing1 = false;

        //Earth 1 Set
        public bool armor1 = false;
        public bool avalanche1 = false;
        public bool rockOrbit = false;
        public bool gibralter1 = false;

        //Water 1 Set
        public bool heal1 = false;
        public bool waterBlast = false;
        public bool iceShield = false;
        public bool poolOfConscience = false;

        //Wind 1 Set
        /// <summary>
        /// Move speed
        /// </summary>
        public bool swift = false;
        public bool slicingWinds = false;
        public bool deadAir = false;
        public bool tornado = false;


        public bool offense = false;
        public bool defense = false;
        public bool support = false;
        public bool spellConstruct = false;

        public bool absorbAffinity = false;
        public int fireA = 0;
        public int earthA = 0;
        public int windA = 0;
        public int waterA = 0;
        public List<int> targetList;
        public Matrix[] baseTransforms;
        public Vector3 towerDirection = Vector3.Zero;
        public Tower tower =new Tower(Vector3.Zero);
        public Vector3 buildCenter1 = Vector3.Zero;
        public Vector3 buildCenter2 = Vector3.Zero;

        public int slot = 0;
        public bool atkSuccess = false;
        public bool tryMove = false;
        public BoundingSphere bodySphere;
        public int fstate = 0;
        public Vector3 fRunDestination = Vector3.Zero;
        public List<Point> fPoints;
        public int fighterIndex = 0;
        public List<BoundingSphere> setSpheres;
        public List<List<bool>> open;
        public List<List<BoundingSphere>> moveSpheres;
        public List<List<BoundingSphere>> pValidMSpheres;
        public List<List<Vector3>> distances;
        public bool mainPathSet = false;
        public bool miniPathSet = false;
        
        public double creationTime = 0; 
        public bool activated = false;
        public bool atkTower = false;
        public bool atkPlayer = false;
        public bool searching = false;
        //public bool pathing = false;
        public int cPulses = 0;
        public int cIntervalTimer = 0; 
        public int cTime = 0;
        public int maxCTime = 0;
        public int cInterval = 0;
        public bool constant = false;
        public bool isRay= false;
        public bool isArea = false;
        
        public float cylinderDistance;
        public List<VertexPositionColor> vertices;
        public List<ushort> indices;
        public Ray forwardRay;
        public Ray currentHeading;
        public Ray targetHeading;

        /// <summary>
        /// channeling is bow2ing a spell not blasting a forward spell
        /// </summary>
        public bool channeling = false;
        public Vector3 ChannelingDirection = Vector3.Zero;
        public Vector3 AreaEffectDirection = Vector3.Zero;
        public List<Ray> rays;

        public Vector3 AreaEffectCenter;
        //public Vector3 AreaWorld;
        public DRay spellDRay;


        public float charge1 = 0;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
        public float charge2 = 0;
        public float charge3 = 0;
        public float charge4 = 0;

        public float charge1R = 100;
        public float charge2R = 10;
        public float charge3R = 10;
        public float charge4R = 10;

        public bool spell = false;
        public bool strafe = false;

        public Vector2 unproject;
        //public Vector2 
        public float health;
        public float mana1Max;
        public float healthMax;
        public float stamMax;
        public float stamina;
        public float mana1;
        public float mana2;
        public float mana3;
        public float mana4;
        public float mana1Recover;
        public float mana2Recover;
        public float mana3Recover;
        public float mana4Recover;
        public float healthRecover;
        public float staminaRecover;
        public int castId = 0; 
        public int castState = 0; 
        public Vector3 moveVec;
        public Vector3 atkVec;

 
        public int target;
        MouseState mouse;
        MouseState oldMouse;
        public List<Vector3> slashPoints = new List<Vector3>();
        public float jumpHt = 0.0f;
        public List<Vector2> unprojected = new List<Vector2>();
        public TimeSpan rangeDecisionTimer = TimeSpan.Zero;
        public TimeSpan advanceTimer = TimeSpan.Zero;
        public bool strafeLeft = false;
        public bool strafeRight = false;
        public bool backUp = false;
        public bool advance = false;
        public bool rangeAttack = false;
        public Vector3 patrol1;
        public Vector3 patrol2;
        public int currentX = 0;
        public int currentY = 0;
        public TimeSpan time;
        public int fightClass = 0; //sword and shield
        public List<int> hit = new List<int>();
        #region //new stuff
        public Vector3 transRayStart;
        public Vector3 transRayEnd;
        public Vector3 transRayDirection;

        public int id; 
        float thrustAdd;
        public bool successRun = false;
        public int targetIndex = 0; 

        public Ray ray;
        public Ray lRay;
        public Ray rRay;
        public List<Point> pathing;



        public int flag = 0; 

        public UnitPathing uiPath;
        public UnitPathing uiPath2, uiPath3, uiPath4;
        int pathState = 0; 
        public Vector3 runDestination = Vector3.Zero;

        public Vector3 formVec = Vector3.Zero;
        /// <summary>
        /// 0 is not colliding 1 is move to formVec "collision" 2 is adjustedPositon
        /// </summary>
        public int state = 0;
        public bool dead = false;
        public TimeSpan restTimer = TimeSpan.Zero;
        private Vector3 dirToFormation;
        public Vector3 DirToFormation
        {
            get
            {
                return dirToFormation;
            }
            set
            {
                dirToFormation = value;
            }


        }
        #endregion

        bool openStrike = false;
        public bool active = false;
        public Vector3 formationVector = Vector3.Zero; 
        public bool Melee = false;
        public bool Range = false;

        
        public TimeSpan decisionTimer = TimeSpan.Zero;
        public List<Vector3> targets;
        public int energy = 0; 
        
        public int move = 5;
        public List<int> injuries = new List<int>();
        public List<TimeSpan> injuryTimes = new List<TimeSpan>();
        public bool attackSuccess = false;
        public TimeSpan lightningTimer = TimeSpan.Zero;
        public bool blocked = false;
        public bool lightninged = false;
        public bool lightningSuccess = false;
        public bool isAddRageAtk = false;
        public Vector3 knockBackVec;
        public bool isKnockedBack = false;
        public bool isKnockedDown = false;

        public bool isAddRage = false;

        bool arrow1Fired = false;
        bool arrow2Fired = false;
        bool arrow3Fired = false;
        

        //0 is Theseus, 1 is Perseus, 2 is Paris
        public int testingIndex = 0; 

        public Matrix forwardSpell;
        //for thrown weapons use arrow
        public Matrix arrowWorld;
        //for the pin move use spear
        public Matrix spearWorld;
        public Matrix lTAxeWorld;
        public Matrix rTAxeWorld;
        public Matrix shieldWorld;

        public List<Projectile2> projectiles;
        public List<Projectile2> eruptions;
        public List<Projectile2> projectilesB;
        public boundingSphere areaSphere;
        public List<boundingSphere> knockBackSphere;
        public List<boundingSphere> physicalSphere;
        public List<boundingSphere> spheres;
        public List<boundingSphere> spearSpheres;
        public List<boundingSphere> spellSpheres;
        public List<boundingSphere> rSpear;
        public List<boundingSphere> lSpear;
        public List<boundingSphere> rSword;
        public List<boundingSphere> lSword;
        public List<boundingSphere> axe;
        public List<boundingSphere> lTAxe;
        public List<boundingSphere> rTAxe;
        public List<boundingSphere> arrow;
        public List<boundingSphere> roundShield;
        public List<boundingSphere> towerShield;
        public List<boundingSphere> bow;
        public List<boundingSphere> collisionS;

        public Vector3[] spots = new Vector3[10];
        public Matrix formation = new Matrix();


        
        public Vector3[] CFormation = new Vector3[9];
        public Vector3[] NFormation = new Vector3[9];
        public Vector3[] SFormation = new Vector3[9];
        public Vector3[] EFormation = new Vector3[9];
        public Vector3[] WFormation = new Vector3[9];

        public bool[] cOpen = new bool[9];
        public bool[] nOpen = new bool[9];
        public bool[] sOpen = new bool[9];
        public bool[] eOpen = new bool[9];
        public bool[] wOpen = new bool[9]; 

        public bool resetFormations = true;
        public TimeSpan currentAtkTime = TimeSpan.Zero;
        public TimeSpan currentAnimationTime = TimeSpan.Zero;
        TimeSpan runTime = TimeSpan.Zero;
        public float rotAmt = 0.0f;
        public float thrustAmount = 0.0f;
        public float RThrust = 0.0f;
        #region animation
        //        shield1 10 shield2 10.5 shieldbash1 11 shieldbash2 11.5 shieldUpper 12 sU2 12.5 sU3 13 sU4 13.5
// shield toss 14  shield toss2 14.5 sT3 15 Shield Spin 15.15 SS2 16 SS3 16.5 SS4 17 Spear1 17.5 S2 18 SpearSpin 18.5 - 21 FlyingSpear 21.5 22.5
//Spear Pinion 23 -24 Spear throw 1 24.5 St2 25 ST followthrough 25.5 SpearOFfhandPinion 26 26.5 bow1 27 bow2 27.5 bow3 28 bow3 followthrough on special arrow
//KB1 28.5 KB1.5 29 KB2 29.5 KnockDown = 30

       
        public Matrix[] hurt1, standing, brace,  atk1a, atk1b, atk1c, atk1d, atk2a, atk2b, atk2c, atk2d, atk3a, atk3b, atk3c, lRun1, lRun2, lRun3, lRun4, rRun1, rRun2, rRun3, rRun4, deaded, previousAnimation;
        public Matrix[] shield1, shield2, shieldBash1, shieldBash2, shieldUpper1, shieldUpper2, shieldUpper3, shieldUpper4, shieldToss1, shieldToss2,
            shieldToss3, shieldSpin1, shieldSpin2, shieldSpin3, shieldSpin4, spear1, spear2, spear3, spearSpin1, spearSpin2, spearSpin3, spearSpin4, spearSpin5, spearSpin6,
            flySpear1, flySpear2, flySpear3, spearPin1, spearPin2, spearPin3, spearThrow1, spearThrow2, spearThrow3, spearThrow4, bow1, bow2, bow3, bow3FollowThru, 
            kb1, kb2, kb3, knockDown,
            hammerStrike1, hammerStrike2, hammerStrike3, hammerFlight1, hammerFlight2, hammerToss1, hammerToss2, hammerToss3, hammerToss4,
            rockStomp1, rockStomp2, punch1, punch2, punch3, punchUpper1, punchUpper2, punchUpper3, punchGround1, punchGround2,
            highKick1, highKick2, AchiSpin1, AchiSpin2, AchiSpin3, AchiSpin4, AchiSpin5, AchiSpinSlash1, AchiSpinSlash2,
            AchiSpinSlash3, AchiSpinSlash4, AchiSpinSlash5, AchiSpinSlash6, AchiSpinSlash7, AchiSwordJump1, AchiSwordJump2,
            AchiSwordJump3, AchiSwordRise1, AchiSwordRise2, AchiSwordRise3, AchiSwordPound1, AchiSwordPound2, AchiSwordPound3,
            wing1, wing2, angelAtka1, angelAtka2, angelAtka3, angelAtkb1, angelAtkb2, angelAtkb3, angelSwoosh1,
            angelSwoosh2, angelSwoosh3, angelSwoosh4, angelSwoosh5;

        public Matrix[] die1, die2, stepBack, jump1, jumpKB, jumpKD;
        MoveMouse playerMouseMove;
        Move playerMove;
        TimeSpan playerMoveTime;


        public bool isDead, isStepBack, isJump, isJumpKB, isJumpKD;
        public bool isShield, isShieldBash, isShieldUpper, isShieldToss, isShieldSpin, isSpear, isSpearSpin, isFlyingSpear, isSpearPin, isSpearThrow, isSpearOffPin, isBow, isBowSpecial,
            isKnockBack, isKnockDown, isTripleBow;

        public bool isHammerStrike, isHammerFlight, isHammerToss, isRockStomp, isPunch, isPunchUpper, isPunchGround, isHighKick, isAchiSpin,
            isAchiSpinSlash, isAchiSwordJump, isAchiSwordRise, isAchiSwordPound, isWing2, isAngelAtka, isAngelAtkb, isAngelSwoosh;
/// <summary>
/// isBrace goes to animation, isBraced just returns the animation
/// </summary>
        public bool isBrace;// = true;
        public bool isHurt; //= false;
        
        public bool isAtk1, isStanding, isAtk2, isAtk3;
        public bool isRapidStrikes, isDoubleStrike;
        public bool isRun;

        public bool isGetUp; //goes to brace

        readonly TimeSpan MoveTimeOut = TimeSpan.FromSeconds(1.5);
        protected SkinningData skinningData;
        public SkinningData SkinningData
        {
            get
            {
                return this.skinningData;
            }
            set
            {
                this.skinningData = value;
            }


        }
        public InputManager inputManager;

        public AnimationPlayer masterPlayer;
        public AnimationClip masterClip;

        protected Matrix[] justBones;
        public Matrix[] JustBones
        {
            get
            {
                return justBones;
            }
            set
            {
                justBones = value;
            }
        }
        protected Matrix[] legBones;
        public Matrix[] LegBones;
        protected Matrix[] upperBones;
        public Matrix[] UpperBones;
        protected Matrix[] worldTrans;
        public Matrix[] WorldTrans
        {
            get
            {
                return worldTrans;
            }
            set
            {
                worldTrans = value;
            }
        }
        protected Matrix[] skinTrans;
        public Matrix[] SkinTrans
        {
            get
            {
                return skinTrans;
            }
            set
            {
                skinTrans = value;
            }
        }

        public float TurnToFaceSpeed(Vector3 position, Vector3 target, Vector3 rotation, float speed)
        {
            float x = (target.X - position.X);
            float z = (target.Z - position.Z);

            float desiredAngle = (float)Math.Atan2(x, z);

            Vector3 tempDir = rotation;
            float tempY = (float)Math.Atan2(rotation.X, rotation.Z);
            float difference = WrapAngle(desiredAngle - tempY);

            difference = MathHelper.Clamp(difference, -speed, speed);

            return WrapAngle(tempY + difference);
        }
        public float TurnToFaceSlow(Vector3 position, Vector3 target, Vector3 rotation)
        {
            float x = (target.X - position.X);
            float z = (target.Z - position.Z);

            float desiredAngle = (float)Math.Atan2(x, z);

            Vector3 tempDir = rotation;
            float tempY = (float)Math.Atan2(rotation.X, rotation.Z);
            float difference = WrapAngle(desiredAngle - tempY);

            difference = MathHelper.Clamp(difference, -.01f, .01f);

            return WrapAngle(tempY + difference);
        }

        public float TurnToFace(Vector3 position, Vector3 target, Vector3 rotation)
        {
            float x = (target.X - position.X);
            float z = (target.Z - position.Z);

            float desiredAngle = (float)Math.Atan2(x, z);

            Vector3 tempDir = rotation;
            float difference = WrapAngle(desiredAngle - tempDir.Y);

              difference = MathHelper.Clamp(difference, -20, 20);

            return WrapAngle(tempDir.Y + difference);
        }

        private static float WrapAngle(float radians)
        {
            while (radians < -MathHelper.Pi)
            {
                radians += MathHelper.TwoPi;
            }
            while (radians > MathHelper.Pi)
            {
                radians -= MathHelper.TwoPi;
            }
            return radians;
        }


        public Vector3 oldPosition;
        public Vector3 oldDirection;
        Vector3 scale, scale2, scale3, scale4;
        Quaternion rota, rota2, rota3, rota4;
        Vector3 trans, trans2, trans3, trans4;

        GamePadState currentGamePadState;
        GamePadState oldGamePadState;
        KeyboardState currentKeyBoardState, oldkeyBoardState;

        private Vector3 position;
        public Vector3 Position
        {

            get
            {
                return position;
            }
            set
            {
                position = value;
            }
        }
        private  Vector3 facing;
        public  Vector3 Facing
        {
            get
            {
                return facing;
            }
            set
            {
                facing = value;
            }
        }
        private Vector3 direction;
        public Vector3 Direction
        {
            get
            {
                return direction;
            }
            set
            {
                direction = value;
            }
        }

        private Matrix world;
        public Matrix World
        {
            get
            {
                return world;
            }
            set
            {
                world = value;
            }
        }
        private Vector3 up;
        public Vector3 Up
        {
            get
            {
                return up;
            }
            set
            {
                up = value;
            }
        }
        private Vector3 right;
        public Vector3 Right
        {
            get
            {
                return right;
            }
            set
            {
                right = value;
            }
        }

        public void updateRays()
        {
            float angle;
            Vector3 trans = ScreenManager.Theseus.collisionS[1].BS.Center;
            rays.Clear();
            if(forwardRay.Intersects(ScreenManager.Theseus.collisionS[1].BS) != null)

            {
                angle = TurnToFace(forwardRay.Position, trans - world.Left * 20, Direction);


                rays.Add(new Ray(forwardRay.Position, new Vector3((float)Math.Sin(angle), 0, (float)Math.Cos(angle))));
                angle = TurnToFace(forwardRay.Position, trans - world.Right * 20, Direction);
                rays.Add(new Ray(forwardRay.Position, new Vector3((float)Math.Sin(angle), 0, (float)Math.Cos(angle))));

            }

        }

        public JuneXnaModel(Vector3 pos, Vector3 dir, Matrix[] transforms)
        {
            hitTags = new List<int>();
            hitDist = new List<float>();
            baseTransforms = transforms;
            bodySphere = new BoundingSphere();
            JsearchStatus = new JSearchStatus();

            JsearchStatus = JSearchStatus.Stopped;
            JopenList = new List<JSearchNode>();
            JclosedList = new List<JSearchNode>();
            Jpaths = new Dictionary<Point, Point>();

            start = Point.Zero;
            end = Point.Zero;

            Reset(start, end);
            fPoints = new List<Point>();
            //distances = new List<List<Vector3>>();
            setSpheres = new List<BoundingSphere>();
            open = new List<List<bool>>();
            for (int i = 0; i < 5; i++)
            {
                open.Add(new List<bool>());
                for (int j = 0; j < 5; j++)
                {
                    open[i].Add(new bool());
                    open[i][j] = false;
                }
            }
            moveSpheres = new List<List<BoundingSphere>>();
            for (int i = 0; i < 5; i++)
            {
                moveSpheres.Add(new List<BoundingSphere>());
                for (int j = 0; j < 5; j++)
                {
                    moveSpheres[i].Add(new BoundingSphere());
                }


            }


            health = 100;
            vertices = new List<VertexPositionColor>();
            indices = new List<ushort>();
            AreaEffectCenter = pos;
            areaSphere = new boundingSphere("area sphere", new BoundingSphere(pos, 50));
            rays = new List<Ray>();
            forwardRay = new Ray(new Vector3(pos.X, 70.0f, pos.Z), dir);

            mana1Max = 100;
            healthMax = 100;
            stamMax = 100;
            mana1 = 100;
            mana2 = 100;
            mana3 = 100;
            mana4 = 100;
            mana1Recover = 1.0f;
            mana2Recover = 1.0f;
            mana3Recover = 1.0f;
            mana4Recover = 1.0f;
            staminaRecover = 1.0f;
            healthRecover = 1.0f;
            moveVec = Vector3.Zero;
            atkVec = Vector3.Zero;
            target = 99;
            patrol1 = Vector3.Zero;
            patrol2 = Vector3.Zero;
            transRayDirection = Vector3.Zero;
            transRayEnd = Vector3.Zero;
            transRayStart = Vector3.Zero;
            isBrace = true;
            isHurt = false;

            ray = new Ray(new Vector3(pos.X, 90.0f, pos.Z), dir);
            lRay = new Ray(new Vector3(pos.X, 90.0f, pos.Z), Vector3.Transform(dir, Matrix.CreateFromAxisAngle(Vector3.Up, -1.0f)));
            rRay = new Ray(new Vector3(pos.X, 90.0f, pos.Z), Vector3.Transform(dir, Matrix.CreateFromAxisAngle(Vector3.Up, 1.0f)));
            pathing = new List<Point>();
            formationVector = Vector3.Zero;

            for (int i = 0; i < 9; i++)
            {

                CFormation[i] = new Vector3(0.0f, 0.0f, 0.0f);

            }
            targets = new List<Vector3>();
            projectilesB = new List<Projectile2>();
            forwardSpell = new Matrix();
            projectiles = new List<Projectile2>();
            eruptions = new List<Projectile2>();


            collisionS = new List<boundingSphere>();
            knockBackSphere = new List<boundingSphere>();
            physicalSphere = new List<boundingSphere>();
            spheres = new List<boundingSphere>();
            spearSpheres = new List<boundingSphere>();

            spellSpheres = new List<boundingSphere>();
            rSpear = new List<boundingSphere>();
            lSpear = new List<boundingSphere>();
            rSword = new List<boundingSphere>();
            lSword = new List<boundingSphere>();
            axe = new List<boundingSphere>();
            lTAxe = new List<boundingSphere>();
            rTAxe = new List<boundingSphere>();
            arrow = new List<boundingSphere>();
            roundShield = new List<boundingSphere>();
            towerShield = new List<boundingSphere>();
            bow = new List<boundingSphere>();






            position = pos;
            direction = dir;
            Up = Vector3.Up;
            right = Vector3.Right;


            inputManager = new InputManager((PlayerIndex)0, ScreenManager.moveList.LongestMoveLength);

            isDead = false;
            isJump = false;
            isJumpKB = false;
            isJumpKD = false;
            isStepBack = false;

            isGetUp = false;
            isAtk1 = false;
            isAtk2 = false;
            isAtk3 = false;
            isRapidStrikes = false;
            isDoubleStrike = false;
            isStanding = false;

            isRun = false;


            isShield = false;
            isShieldBash = false;
            isShieldUpper = false;
            isShieldToss = false;
            isShieldSpin = false;
            isSpear = false;
            isSpearSpin = false;
            isFlyingSpear = false;
            isSpearPin = false;
            isSpearThrow = false;
            isSpearOffPin = false;
            isBow = false;
            isBowSpecial = false;
            isKnockBack = false;
            isKnockDown = false;
            isTripleBow = false;


            isHammerStrike = false;
            isHammerToss = false;
            isRockStomp = false;
            isPunch = false;
            isPunchUpper = false;
            isPunchGround = false;
            isHighKick = false;
            isAchiSpin = false;
            isAchiSpinSlash = false;
            isAchiSwordJump = false;
            isAchiSwordRise = false;
            isAchiSwordPound = false;
            isWing2 = false;
            isAngelAtka = false;
            isAngelAtkb = false; isAngelSwoosh = false;
            // setAnimationPlayers();

        }
        public JuneXnaModel(Vector3 pos, Vector3 dir)
        {

            oldSpheres = new List<BoundingSphere>();
            for (int i = 0; i < 48; i++)
                oldSpheres.Add(new BoundingSphere());
            facing = dir;
            rangeSpheres = new List<BoundingSphere>();
            collisionBox = new BoundingBox();
            setBoxes = new List<BoundingBox>();
            
            IncOpen = new List<List<bool>>();
            for (int i = 0; i < 3; i++)
            {
                IncOpen.Add(new List<bool>());
                for (int j = 0; j < 3; j++)
                    IncOpen[i].Add(new bool());

            }
            IncrementalSpheres = new List<List<BoundingSphere>>();
            for (int i = 0; i < 3; i++)
            {
                IncrementalSpheres.Add(new List<BoundingSphere>());
                for (int j = 0; j < 3; j++)
                {
                    IncrementalSpheres[i].Add(new BoundingSphere());


                }
            }
            toTarget = new List<BoundingSphere>();
            arrows = new List<Arrow>();
            NSphere = new BoundingSphere();
            NESphere = new BoundingSphere();
            NWSphere = new BoundingSphere();
            WSphere = new BoundingSphere();
            ESphere = new BoundingSphere();
            SESphere = new BoundingSphere();
            SWSphere = new BoundingSphere();
            SSphere = new BoundingSphere();
            NWSpheres = new List<List<BoundingSphere>>();
            NESpheres = new List<List<BoundingSphere>>();
            NSpheres = new List<List<BoundingSphere>>();
            WSpheres = new List<List<BoundingSphere>>();
            ESpheres = new List<List<BoundingSphere>>();
            SWSpheres = new List<List<BoundingSphere>>();
            SESpheres = new List<List<BoundingSphere>>();
            SSpheres = new List<List<BoundingSphere>>();
            for (int i = 0; i < 5; i++)
            {
              //  NWSpheres = 
                NWSpheres.Add(new List<BoundingSphere>());
                NESpheres.Add(new List<BoundingSphere>());
                NSpheres.Add(new List<BoundingSphere>());
                ESpheres.Add(new List<BoundingSphere>());
                WSpheres.Add(new List<BoundingSphere>());
                SSpheres.Add(new List<BoundingSphere>());
                SESpheres.Add(new List<BoundingSphere>());
                SWSpheres.Add(new List<BoundingSphere>());
                for(int j = 0; j<5 ; j++)
                {

                   
                NWSpheres[i].Add(new BoundingSphere());
                NESpheres[i].Add(new BoundingSphere());
                NSpheres[i].Add(new BoundingSphere());
                ESpheres[i].Add(new BoundingSphere());
                WSpheres[i].Add(new BoundingSphere());
                SSpheres[i].Add(new BoundingSphere());
                SESpheres[i].Add(new BoundingSphere());
                SWSpheres[i].Add(new BoundingSphere());

                }
            }
            collisionGroup = new List<int>();
            futureMovement = new List<BoundingSphere>();
            for (int i = 0; i < 2; i++)
                futureMovement.Add(new BoundingSphere());
            aiState = 0;
            rand = new Random();
            cutOffTime = TimeSpan.Zero;
            aiDecisionTimer = TimeSpan.Zero;
            minDecisionTimer = TimeSpan.FromSeconds(1);
            maxDecisionTimer = TimeSpan.FromSeconds(2);
            plannedPosition = Vector3.Zero;
            isHoldAtk1 = false;
            isHoldAtk2 = false;
            isHoldAtk3 = false;
            hitTags = new List<int>();
            hitDist = new List<float>();
            targetList = new List<int>();
            bodySphere = new BoundingSphere();
            JsearchStatus = new JSearchStatus();
            MsearchStatus = new JSearchStatus();
            MsearchStatus = JSearchStatus.Stopped;
            JsearchStatus = JSearchStatus.Stopped;
            JopenList = new List<JSearchNode>();
            JclosedList = new List<JSearchNode>();
            Jpaths = new Dictionary<Point, Point>();
            MopenList = new List<JSearchNode>();
            MclosedList = new List<JSearchNode>();
            Mpaths = new Dictionary<Point, Point>();
            Mstart = Point.Zero;
            Mend = Point.Zero;

            start = Point.Zero;
            end = Point.Zero;
            MReset(Mstart, Mend);
            Reset(start, end);
            fPoints = new List<Point>();
            //distances = new List<List<Vector3>>();
            setSpheres = new List<BoundingSphere>();
            open =new List<List<bool>>();
            for(int i= 0;i<9; i++)
            {
                open.Add(new List<bool>());
                for (int j = 0; j < 9; j++)
                {
                    open[i].Add(new bool());
                    open[i][j] = false;
                }
            }
           // smoothSpheres = new List<BoundingSphere>();
            //for(int i= 0; i<3;                 
            pValidMSpheres = new List<List<BoundingSphere>>();
            for (int i = 0; i < 5; i++)
            {
                pValidMSpheres.Add(new List<BoundingSphere>());
                for (int j = 0; j < 5; j++)
                {
                    pValidMSpheres[i].Add(new BoundingSphere());

                }

            }

            moveBoxes = new List<List<BoundingBox>>();
            for (int i = 0; i < 5; i++)
            {
                moveBoxes.Add(new List<BoundingBox>());
                for (int j = 0; j < 5; j++)
                {
                    moveBoxes[i].Add(new BoundingBox());
                }



            }                                                                                                                                                                                                                                 
            moveSpheres = new List<List<BoundingSphere>>();
            for (int i = 0; i < 9; i++)
            {
                moveSpheres.Add(new List<BoundingSphere>());
                for (int j = 0; j < 9; j++)
                {
                    moveSpheres[i].Add(new BoundingSphere());
                }


            }


            health = 100;
            vertices = new List<VertexPositionColor>();
            indices = new List<ushort>();
            AreaEffectCenter = pos;
            areaSphere = new boundingSphere("area sphere", new BoundingSphere(pos, 50));
            rays = new List<Ray>();
            forwardRay = new Ray(new Vector3(pos.X, 70.0f, pos.Z), dir);

            mana1Max = 100;
            healthMax = 100;
            stamMax = 100;
            mana1 = 100;
            mana2 = 100;
            mana3 = 100;
            mana4 = 100;
            mana1Recover = 1.0f;
            mana2Recover = 1.0f;
            mana3Recover = 1.0f;
            mana4Recover = 1.0f;
            staminaRecover = 1.0f;
            healthRecover = 1.0f;
            moveVec = Vector3.Zero;
            atkVec = Vector3.Zero;
            target = 99;
            patrol1 = Vector3.Zero;
            patrol2 = Vector3.Zero;
            transRayDirection = Vector3.Zero;
            transRayEnd = Vector3.Zero;
            transRayStart = Vector3.Zero;
            isBrace = true;
            isHurt = false;

            ray = new Ray(new Vector3(pos.X, 90.0f, pos.Z), dir);
            lRay = new Ray(new Vector3(pos.X, 90.0f, pos.Z), Vector3.Transform(dir, Matrix.CreateFromAxisAngle(Vector3.Up, -1.0f)));
            rRay = new Ray(new Vector3(pos.X, 90.0f, pos.Z), Vector3.Transform(dir, Matrix.CreateFromAxisAngle(Vector3.Up, 1.0f)));
            pathing = new List<Point>();
            formationVector = Vector3.Zero ;

            for(int i = 0; i < 9; i++)
            {

                CFormation[i] = new Vector3(0.0f, 0.0f, 0.0f);

            }
            targets = new List<Vector3>();
            projectilesB = new List<Projectile2>();
            forwardSpell = new Matrix();
            projectiles = new List<Projectile2>();
            eruptions = new List<Projectile2>();


            collisionS = new List<boundingSphere>();
            knockBackSphere = new List<boundingSphere>();
            physicalSphere = new List<boundingSphere>();
            spheres = new List<boundingSphere>();
            spearSpheres = new List<boundingSphere>();

            spellSpheres = new List<boundingSphere>();
            rSpear = new List<boundingSphere>();
            lSpear = new List<boundingSphere>();
            rSword = new List<boundingSphere>();
            lSword = new List<boundingSphere>();
            axe = new List<boundingSphere>();
            lTAxe = new List<boundingSphere>();
            rTAxe = new List<boundingSphere>();
            arrow = new List<boundingSphere>();
            roundShield = new List<boundingSphere>();
            towerShield = new List<boundingSphere>();
            bow = new List<boundingSphere>();






            position = pos;
            direction = dir;
            Up = Vector3.Up;
            right = Vector3.Right;


            inputManager = new InputManager((PlayerIndex)0, ScreenManager.moveList.LongestMoveLength);

            isDead = false;
            isJump = false;
            isJumpKB = false;
            isJumpKD = false;
            isStepBack = false;
            
            isGetUp = false;
            isAtk1 = false;
            isAtk2 = false;
            isAtk3 = false;
            isRapidStrikes = false;
            isDoubleStrike = false;
            isStanding = false;

            isRun = false;


            isShield= false; 
            isShieldBash= false; 
            isShieldUpper= false;
            isShieldToss= false; 
            isShieldSpin= false; 
            isSpear= false;
            isSpearSpin= false;
            isFlyingSpear= false;
            isSpearPin= false;
            isSpearThrow= false; 
            isSpearOffPin= false; 
            isBow= false;
            isBowSpecial= false;
            isKnockBack = false; 
            isKnockDown = false;
            isTripleBow = false;

            
             isHammerStrike = false;
            isHammerToss = false; 
            isRockStomp = false;
            isPunch = false;
            isPunchUpper = false;
            isPunchGround = false; 
            isHighKick = false;
            isAchiSpin = false;
            isAchiSpinSlash = false;
            isAchiSwordJump = false; 
            isAchiSwordRise = false; 
            isAchiSwordPound = false; 
            isWing2 = false; 
            isAngelAtka = false;
            isAngelAtkb = false; isAngelSwoosh = false;
           // setAnimationPlayers();

        }

        public void setAnimationPlayers2()
        {

            masterPlayer = new AnimationPlayer(skinningData);
            masterClip = skinningData.AnimationClips["Take 001"];
            masterPlayer.StartClip(masterClip);


            previousAnimation = new Matrix[skinningData.BindPose.Count];
            worldTrans = new Matrix[skinningData.BindPose.Count];
            skinTrans = new Matrix[skinningData.BindPose.Count];
            justBones = new Matrix[skinningData.BindPose.Count];
            legBones = new Matrix[skinningData.BindPose.Count];
            upperBones = new Matrix[skinningData.BindPose.Count];

            hurt1 = new Matrix[skinningData.BindPose.Count];
            brace = new Matrix[skinningData.BindPose.Count];
            standing = new Matrix[skinningData.BindPose.Count];
            lRun1 = new Matrix[skinningData.BindPose.Count];
            lRun2 = new Matrix[skinningData.BindPose.Count];
            lRun3 = new Matrix[skinningData.BindPose.Count];
            lRun4 = new Matrix[skinningData.BindPose.Count];
            rRun1 = new Matrix[skinningData.BindPose.Count];
            rRun2 = new Matrix[skinningData.BindPose.Count];
            rRun3 = new Matrix[skinningData.BindPose.Count];
            rRun4 = new Matrix[skinningData.BindPose.Count];
            atk1a = new Matrix[skinningData.BindPose.Count];
            atk1b = new Matrix[skinningData.BindPose.Count];
            atk1c = new Matrix[skinningData.BindPose.Count];
            atk1d = new Matrix[skinningData.BindPose.Count];
            atk2a = new Matrix[skinningData.BindPose.Count];
            atk2b = new Matrix[skinningData.BindPose.Count];
            atk2c = new Matrix[skinningData.BindPose.Count];
            atk2d = new Matrix[skinningData.BindPose.Count];
            deaded = new Matrix[skinningData.BindPose.Count];
            bow1 = new Matrix[skinningData.BindPose.Count];
            bow2 = new Matrix[skinningData.BindPose.Count];
            bow3 = new Matrix[skinningData.BindPose.Count];
            bow3FollowThru = new Matrix[skinningData.BindPose.Count];

            masterPlayer.Update(TimeSpan.FromMilliseconds(5 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(brace, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(5 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(standing, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(10 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(lRun1, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(15 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(lRun2, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(20 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(lRun3, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(25 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(lRun4, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(30 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(rRun1, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(35 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(rRun2, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(40 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(rRun3, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(45 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(rRun4, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(50 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(atk1a, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(55 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(atk1b, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(60 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(atk1c, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(65 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(atk1d, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(70 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(atk2a, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(75 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(atk2b, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(80 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(atk2c, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(85 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(atk2d, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(90 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(deaded, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(95 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(bow1, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(100 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(bow2, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(105 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(bow3, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(109.2 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(bow3FollowThru, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(114.5 * 33.3333), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(hurt1, 0);

        }

        public void setAnimationPlayers()
        {

            masterPlayer = new AnimationPlayer(skinningData);
            masterClip = skinningData.AnimationClips["Take 001"];
            masterPlayer.StartClip(masterClip);

            hurt1 = new Matrix[skinningData.BindPose.Count];
            standing = new Matrix[skinningData.BindPose.Count];
            brace = new Matrix[skinningData.BindPose.Count];
            atk1a = new Matrix[skinningData.BindPose.Count];
            atk1b = new Matrix[skinningData.BindPose.Count];
            atk1c = new Matrix[skinningData.BindPose.Count];
            atk1d = new Matrix[skinningData.BindPose.Count];
            atk2a = new Matrix[skinningData.BindPose.Count];
            atk2b = new Matrix[skinningData.BindPose.Count];
            atk3a = new Matrix[skinningData.BindPose.Count];
            atk3b = new Matrix[skinningData.BindPose.Count];
            atk3c = new Matrix[skinningData.BindPose.Count];
            lRun1 = new Matrix[skinningData.BindPose.Count];
            lRun2 = new Matrix[skinningData.BindPose.Count];
            lRun3 = new Matrix[skinningData.BindPose.Count];
            lRun4 = new Matrix[skinningData.BindPose.Count];
            rRun1 = new Matrix[skinningData.BindPose.Count];
            rRun2 = new Matrix[skinningData.BindPose.Count];
            rRun3 = new Matrix[skinningData.BindPose.Count];
            rRun4 = new Matrix[skinningData.BindPose.Count];
            shield1= new Matrix[skinningData.BindPose.Count];
            shield2= new Matrix[skinningData.BindPose.Count]; 
            shieldBash1= new Matrix[skinningData.BindPose.Count]; 
            shieldBash2= new Matrix[skinningData.BindPose.Count];  
            shieldUpper1= new Matrix[skinningData.BindPose.Count];  
            shieldUpper2= new Matrix[skinningData.BindPose.Count]; 
            shieldUpper3= new Matrix[skinningData.BindPose.Count]; 
            shieldUpper4= new Matrix[skinningData.BindPose.Count]; 
            shieldToss1= new Matrix[skinningData.BindPose.Count]; 
            shieldToss2= new Matrix[skinningData.BindPose.Count]; 
            shieldToss3= new Matrix[skinningData.BindPose.Count]; 
            shieldSpin1= new Matrix[skinningData.BindPose.Count];  
            shieldSpin2= new Matrix[skinningData.BindPose.Count]; 
            shieldSpin3= new Matrix[skinningData.BindPose.Count];  
            shieldSpin4= new Matrix[skinningData.BindPose.Count]; 
            spear1= new Matrix[skinningData.BindPose.Count]; 
            spear2= new Matrix[skinningData.BindPose.Count];
            spear3 = new Matrix[skinningData.BindPose.Count]; 
            spearSpin1= new Matrix[skinningData.BindPose.Count]; 
            spearSpin2= new Matrix[skinningData.BindPose.Count]; 
            spearSpin3= new Matrix[skinningData.BindPose.Count];  
            spearSpin4= new Matrix[skinningData.BindPose.Count]; 
            spearSpin5= new Matrix[skinningData.BindPose.Count]; 
            spearSpin6= new Matrix[skinningData.BindPose.Count]; 
            flySpear1= new Matrix[skinningData.BindPose.Count];  
            flySpear2= new Matrix[skinningData.BindPose.Count]; 
            flySpear3= new Matrix[skinningData.BindPose.Count];  
            spearPin1= new Matrix[skinningData.BindPose.Count];  
            spearPin2= new Matrix[skinningData.BindPose.Count]; 
            spearPin3= new Matrix[skinningData.BindPose.Count];  
            spearThrow1= new Matrix[skinningData.BindPose.Count]; 
            spearThrow2= new Matrix[skinningData.BindPose.Count];
            spearThrow3 = new Matrix[skinningData.BindPose.Count];
            spearThrow4 = new Matrix[skinningData.BindPose.Count]; 
            bow1= new Matrix[skinningData.BindPose.Count];  
            bow2= new Matrix[skinningData.BindPose.Count]; 
            bow3= new Matrix[skinningData.BindPose.Count]; 
            bow3FollowThru= new Matrix[skinningData.BindPose.Count]; 
            kb1= new Matrix[skinningData.BindPose.Count]; 
            kb2= new Matrix[skinningData.BindPose.Count]; 
            kb3= new Matrix[skinningData.BindPose.Count];
            knockDown = new Matrix[skinningData.BindPose.Count];
            hammerStrike1 = new Matrix[skinningData.BindPose.Count];
            hammerStrike2 = new Matrix[skinningData.BindPose.Count];
            hammerStrike3 = new Matrix[skinningData.BindPose.Count];
            hammerToss1 = new Matrix[skinningData.BindPose.Count];
            hammerToss2 = new Matrix[skinningData.BindPose.Count];
            hammerToss3 = new Matrix[skinningData.BindPose.Count];
            hammerToss4 = new Matrix[skinningData.BindPose.Count];
            hammerFlight1 = new Matrix[skinningData.BindPose.Count];
            hammerFlight2 = new Matrix[skinningData.BindPose.Count];
            rockStomp1 = new Matrix[skinningData.BindPose.Count];
            rockStomp2 = new Matrix[skinningData.BindPose.Count];
            punch1 = new Matrix[skinningData.BindPose.Count];
            punch2 = new Matrix[skinningData.BindPose.Count];
            punch3 = new Matrix[skinningData.BindPose.Count];
            punchUpper1 = new Matrix[skinningData.BindPose.Count];
            punchUpper2 = new Matrix[skinningData.BindPose.Count];
            punchUpper3 = new Matrix[skinningData.BindPose.Count];
            punchGround1 = new Matrix[skinningData.BindPose.Count];
            punchGround2 = new Matrix[skinningData.BindPose.Count];
            highKick1 = new Matrix[skinningData.BindPose.Count];
            highKick2 = new Matrix[skinningData.BindPose.Count];
            AchiSpin1 = new Matrix[skinningData.BindPose.Count];
            AchiSpin2 = new Matrix[skinningData.BindPose.Count];
            AchiSpin3 = new Matrix[skinningData.BindPose.Count];
            AchiSpin4 = new Matrix[skinningData.BindPose.Count];
            AchiSpin5 = new Matrix[skinningData.BindPose.Count];

            AchiSpinSlash1 = new Matrix[skinningData.BindPose.Count];
            AchiSpinSlash2 = new Matrix[skinningData.BindPose.Count];
            AchiSpinSlash3 = new Matrix[skinningData.BindPose.Count];
            AchiSpinSlash4 = new Matrix[skinningData.BindPose.Count];
            AchiSpinSlash5 = new Matrix[skinningData.BindPose.Count];
            AchiSpinSlash6 = new Matrix[skinningData.BindPose.Count];
            AchiSpinSlash7 = new Matrix[skinningData.BindPose.Count];

            AchiSwordJump1 = new Matrix[skinningData.BindPose.Count];
            AchiSwordJump2 = new Matrix[skinningData.BindPose.Count];
            AchiSwordJump3 = new Matrix[skinningData.BindPose.Count];

            AchiSwordRise1 = new Matrix[skinningData.BindPose.Count];
            AchiSwordRise2 = new Matrix[skinningData.BindPose.Count];
            AchiSwordRise3 = new Matrix[skinningData.BindPose.Count];

            AchiSwordPound1 = new Matrix[skinningData.BindPose.Count];
            AchiSwordPound2 = new Matrix[skinningData.BindPose.Count];
            AchiSwordPound3 = new Matrix[skinningData.BindPose.Count];

            wing1 = new Matrix[skinningData.BindPose.Count];
            wing2 = new Matrix[skinningData.BindPose.Count];

            angelAtka1 = new Matrix[skinningData.BindPose.Count];
            angelAtka2 = new Matrix[skinningData.BindPose.Count];
            angelAtka3 = new Matrix[skinningData.BindPose.Count];

            angelAtkb1 = new Matrix[skinningData.BindPose.Count];
            angelAtkb2 = new Matrix[skinningData.BindPose.Count];
            angelAtkb3 = new Matrix[skinningData.BindPose.Count];

            angelSwoosh1 = new Matrix[skinningData.BindPose.Count];
            angelSwoosh2 = new Matrix[skinningData.BindPose.Count];
            angelSwoosh3 = new Matrix[skinningData.BindPose.Count];
            angelSwoosh4 = new Matrix[skinningData.BindPose.Count];
            angelSwoosh5 = new Matrix[skinningData.BindPose.Count];

            die1 = new Matrix[skinningData.BindPose.Count];
            die2 = new Matrix[skinningData.BindPose.Count];
            stepBack = new Matrix[skinningData.BindPose.Count];
            jump1 = new Matrix[skinningData.BindPose.Count];
            jumpKB = new Matrix[skinningData.BindPose.Count];
            jumpKD = new Matrix[skinningData.BindPose.Count];




            previousAnimation = new Matrix[skinningData.BindPose.Count];
            worldTrans = new Matrix[skinningData.BindPose.Count];
            skinTrans = new Matrix[skinningData.BindPose.Count];
            justBones = new Matrix[skinningData.BindPose.Count];
            legBones = new Matrix[skinningData.BindPose.Count];
            upperBones = new Matrix[skinningData.BindPose.Count];

            masterPlayer.Update(TimeSpan.FromMilliseconds(500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(standing, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(1000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(brace, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(1500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(atk1a, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(2000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(atk1b, 0);

            masterPlayer.Update(TimeSpan.FromMilliseconds(2500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(atk1c, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(3000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(atk1d, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(3500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(atk2a, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(4000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(atk2b, 0);

            masterPlayer.Update(TimeSpan.FromMilliseconds(4500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(atk3a, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(5000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(atk3b, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(5500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(atk3c, 0);

            masterPlayer.Update(TimeSpan.FromMilliseconds(6000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(lRun1, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(6500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(lRun2, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(7000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(lRun3, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(7500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(lRun4, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(8000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(rRun1, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(8500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(rRun2, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(9000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(rRun3, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(9500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(rRun4, 0);




            masterPlayer.Update(TimeSpan.FromMilliseconds(10000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(shield1, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(10500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(shield2, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(11000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(shieldBash1, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(11500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(shieldBash2, 0);

            masterPlayer.Update(TimeSpan.FromMilliseconds(12000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(shieldUpper1, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(12500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(shieldUpper2, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(13000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(shieldUpper3, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(13500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(shieldUpper4, 0);



            masterPlayer.Update(TimeSpan.FromMilliseconds(14000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(shieldToss1, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(14500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(shieldToss2, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(15000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(shieldToss3, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(15500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(shieldSpin1, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(16000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(shieldSpin2, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(16500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(shieldSpin3, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(17000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(shieldSpin4, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(17500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(spear1, 0);

            //shield1, shield2, shieldBash1, shieldBash2, shieldUpper1, shieldUpper2, shieldUpper3, shieldUpper4, shieldToss1, shieldToss2,
            //shieldToss3, shieldSpin1, shieldSpin2, shieldSpin3, shieldSpin4, spear1, spear2, spearSpin1, spearSpin2, spearSpin3, spearSpin4, spearSpin5, spearSpin6,
            //flySpear1, flySpear2, flySpear3, spearPin1, spearPin2, spearPin3, spearThrow1, spearThrow2, spearThrowFinish, spearOffhandPin1, spearOffHandPin2,
            //bow1, bow2, bow3, bow3FollowThru, kb1, kb2, kb3, knockDown;

            masterPlayer.Update(TimeSpan.FromMilliseconds(18000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(spear2, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(18500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(spear3, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(19000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(spearSpin1, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(19500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(spearSpin2, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(20000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(spearSpin3, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(20500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(spearSpin4, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(21000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(spearSpin5, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(21500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(spearSpin6, 0);


            //shield1, shield2, shieldBash1, shieldBash2, shieldUpper1, shieldUpper2, shieldUpper3, shieldUpper4, shieldToss1, shieldToss2,
            //shieldToss3, shieldSpin1, shieldSpin2, shieldSpin3, shieldSpin4, spear1, spear2, spearSpin1, spearSpin2, spearSpin3, spearSpin4, spearSpin5, spearSpin6,
            //flySpear1, flySpear2, flySpear3, spearPin1, spearPin2, spearPin3, spearThrow1, spearThrow2, spearThrowFinish, spearOffhandPin1, spearOffHandPin2,
            //bow1, bow2, bow3, bow3FollowThru, kb1, kb2, kb3, knockDown;

            masterPlayer.Update(TimeSpan.FromMilliseconds(22000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(flySpear1, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(22500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(flySpear2, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(23000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(flySpear3, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(23500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(spearPin1, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(24000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(spearPin2, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(24500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(spearPin3, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(25000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(spearThrow1, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(25500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(spearThrow2, 0);


            //shield1, shield2, shieldBash1, shieldBash2, shieldUpper1, shieldUpper2, shieldUpper3, shieldUpper4, shieldToss1, shieldToss2,
            //shieldToss3, shieldSpin1, shieldSpin2, shieldSpin3, shieldSpin4, spear1, spear2, spearSpin1, spearSpin2, spearSpin3, spearSpin4, spearSpin5, spearSpin6,
            //flySpear1, flySpear2, flySpear3, spearPin1, spearPin2, spearPin3, spearThrow1, spearThrow2, spearThrowFinish, spearOffhandPin1, spearOffHandPin2,
            //bow1, bow2, bow3, bow3FollowThru, kb1, kb2, kb3, knockDown;

            masterPlayer.Update(TimeSpan.FromMilliseconds(26000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(spearThrow3, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(26500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(spearThrow4, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(27000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(bow1, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(27500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(bow2, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(28000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(bow3, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(28500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(bow3FollowThru, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(29000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(kb1, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(29500), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(kb2, 0);
            masterPlayer.Update(TimeSpan.FromMilliseconds(30000), false, Matrix.Identity);
            masterPlayer.GetBoneTransforms().CopyTo(kb3, 0);


            //masterPlayer.Update(TimeSpan.FromMilliseconds(30500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(knockDown, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(31000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(hammerStrike1, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(31500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(hammerStrike2, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(32000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(hammerStrike3, 0);

            //masterPlayer.Update(TimeSpan.FromMilliseconds(32500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(hammerFlight1, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(33000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(hammerFlight2, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(33500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(hammerToss1, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(34000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(hammerToss2, 0);


            //masterPlayer.Update(TimeSpan.FromMilliseconds(34500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(hammerToss3, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(35000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(rockStomp1, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(35500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(rockStomp2, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(36000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(punch1, 0);


            //masterPlayer.Update(TimeSpan.FromMilliseconds(36500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(punch2, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(37000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(punch3, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(37500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(punchUpper1, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(38000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(punchUpper2, 0);

            //masterPlayer.Update(TimeSpan.FromMilliseconds(38500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(punchUpper3, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(39000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(punchGround1, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(39500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(punchGround2, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(40000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(highKick1, 0);

            //masterPlayer.Update(TimeSpan.FromMilliseconds(40500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(highKick2, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(41000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSpin1, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(41500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSpin2, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(42000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSpin3, 0);


            //masterPlayer.Update(TimeSpan.FromMilliseconds(42500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSpin4, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(43000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSpin5, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(43500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSpinSlash1, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(44000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSpinSlash2, 0);


            //masterPlayer.Update(TimeSpan.FromMilliseconds(44500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSpinSlash3, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(45000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSpinSlash4, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(45500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSpinSlash5, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(46000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSpinSlash6, 0);


            //masterPlayer.Update(TimeSpan.FromMilliseconds(46500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSpinSlash7, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(47000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSwordJump1, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(47500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSwordJump2, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(48000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSwordJump3, 0);

            //masterPlayer.Update(TimeSpan.FromMilliseconds(48500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSwordRise1, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(49000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSwordRise2, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(49500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSwordRise3, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(50000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSwordPound1, 0);


            //masterPlayer.Update(TimeSpan.FromMilliseconds(50500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(AchiSwordPound2, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(51000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(wing1, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(51500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(wing2, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(52000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(angelAtka1, 0);

            //masterPlayer.Update(TimeSpan.FromMilliseconds(52500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(angelAtka2, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(53000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(angelAtka3, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(53500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(angelAtkb1, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(54000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(angelAtkb2, 0);

            //masterPlayer.Update(TimeSpan.FromMilliseconds(54500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(angelAtkb3, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(55000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(die1, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(55500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(die2, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(56000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(jump1, 0);

            //masterPlayer.Update(TimeSpan.FromMilliseconds(56500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(jumpKB, 0);
            //masterPlayer.Update(TimeSpan.FromMilliseconds(56999), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(jumpKD, 0);

            //OLD DIES
            //masterPlayer.Update(TimeSpan.FromMilliseconds(57500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(die1, 0);

            //masterPlayer.Update(TimeSpan.FromMilliseconds(58000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(die2, 0);

            //masterPlayer.Update(TimeSpan.FromMilliseconds(58500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(stepBack, 0);

            //masterPlayer.Update(TimeSpan.FromMilliseconds(59000), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(jump1, 0);

            //masterPlayer.Update(TimeSpan.FromMilliseconds(59500), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(jumpKB, 0);

            //masterPlayer.Update(TimeSpan.FromMilliseconds(59999), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(jumpKD, 0);

            //masterPlayer.Update(TimeSpan.FromMilliseconds(57499), false, Matrix.Identity);
            //masterPlayer.GetBoneTransforms().CopyTo(angelSwoosh5, 0);

        }

#endregion

        public void makeCylinder()
        {
            //effect = new BasicEffect(ScreenManager.GraphicsDevice);
            vertices.Clear();
            indices.Clear();

            Vector3 midPoint = forwardSpell.Translation;
            for (int i = 0; i < 10; i += 1)
            {
                midPoint = forwardSpell.Translation;
                const float radius = 30;
                const float height = 40;

                double angle = i / 10.0 * Math.PI * 2;

                float x = (float)Math.Cos(angle);
                float y = (float)Math.Sin(angle);

                vertices.Add(new VertexPositionColor(new Vector3(midPoint.X + x * radius, midPoint.Y + y * radius, midPoint.Z), Color.Blue));
                //  BoundingSphereRenderer.Render(new BoundingSphere(new Vector3(midPoint.X + x * radius, midPoint.Y + y * radius, midPoint.Z), 10), ScreenManager.GraphicsDevice, ScreenManager.camera.View, ScreenManager.camera.Projection, Color.Blue);
                midPoint += Direction * cylinderDistance;
                vertices.Add(new VertexPositionColor(new Vector3(midPoint.X + x * radius, midPoint.Y + y * radius, midPoint.Z), Color.Blue));

                indices.Add((ushort)(i * 2));
                indices.Add((ushort)(i * 2 + 1));
                indices.Add((ushort)((i * 2 + 2) % (10 * 2)));

                indices.Add((ushort)(i * 2 + 1));
                indices.Add((ushort)((i * 2 + 3) % (10 * 2)));
                indices.Add((ushort)((i * 2 + 2) % (10 * 2)));


                //   BoundingSphereRenderer.Render(new BoundingSphere(new Vector3(midPoint.X + x * radius, midPoint.Y + y * radius, midPoint.Z), 10), ScreenManager.GraphicsDevice, ScreenManager.camera.View, ScreenManager.camera.Projection, Color.Blue);
            }

          //  vertexBuffer.SetData(vertices.ToArray());
          //  indexBuffer.SetData(indices.ToArray());


        }

        public void findNextTarget()
        {
            bool found = false;
            float lowest = 99999;
            int index = 0;
            //int j= 0;
            float current = 0;

            for (int i = 0; i < ScreenManager.fighters.Count; i++)
            {
                if (ScreenManager.fighters[i].activated && ScreenManager.fighters[i].health > 0)
                {
                    current = Vector3.Distance(Position, ScreenManager.fighters[i].Position);
                    found = true;
                    if (current < lowest)
                    {
                        index = i;
                        lowest = current;
                    }
                }
            }
            if (found)
            {
                if (targetList.Count > 0)
                    targetList[0] = index;
                else
                    targetList.Add(index);
            }



        }
        public void EUpdate(GameTime gameTime)
        {
            int i = 0;
            float dToT = 0;
            float rotationAmount = 0;
         


                oldPosition = Position;
                dToT = Vector3.Distance(position, ScreenManager.etLvl1Player.World.Translation);
                rotationAmount = 0.0f;
                rotationAmount = TurnToFace(position, ScreenManager.etLvl1Player.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

           
            

            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            //before you check for isatk1 make sure it hasn't already been struck
            if (isAtk1)
                UpdateBasic1(gameTime);

            if (isHurt)
                hurtUpdate(gameTime);


            if (isKnockBack)
                UpdateKnockBack(gameTime);

            if (isAtk1)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isHurt)
                standing.CopyTo(justBones, 0); 
            else
                brace.CopyTo(justBones, 0);
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();




        }
        public void UpdatePlayerLevel1(GameTime gameTime)
        {


            float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds;
            oldGamePadState = currentGamePadState;
            oldkeyBoardState = currentKeyBoardState;
            World.Decompose(out scale, out rota, out trans);
            oldPosition = Position;
            oldDirection = Direction;
            currentGamePadState = GamePad.GetState(PlayerIndex.One);

            foreach (Projectile2 pro in projectiles)
                pro.update2(gameTime);


            //float rororo = TurnToFace(position, ScreenManager.Perseus.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
            //Console.WriteLine(rororo);
            Vector2 rotationAmount = currentGamePadState.ThumbSticks.Left;

            Vector2 inputAmount = currentGamePadState.ThumbSticks.Right;

            //rotAmt = TurnToFace(ScreenManager.asterion.Position, ScreenManager.medusa.Position, Vector3.Zero);
            // Direction = new Vector3((float)Math.Sin(rotAmt), 0.0f, (float)Math.Cos(rotAmt));

            if (gameTime.TotalGameTime - playerMoveTime > MoveTimeOut)
            {
                playerMove = null;
            }
            //inputManager.Update(gameTime);
            Move newMove = ScreenManager.moveList.DetectMove(ScreenManager.inputManager);

            if (newMove != null)
            {
                playerMove = newMove;

                playerMoveTime = gameTime.TotalGameTime;

                if (playerMove.Name == "RS")
                {
                   // projectiles.Add(new Projectile2("Fire", forwardSpell, Direction));

                }
                if (playerMove.Name == "LT")
                {
                   // testingIndex++;
                   // if (testingIndex > 2)
                    //    testingIndex = 0;

                }
                if (playerMove.Name == "RT")
                {
                    //ScreenManager.Theseus.Position = new Vector3(1349.0f, 0.0f, 2770.0f);//13.49 -27.692

                   // EternalStruggle.TheseusStandRun2 = true;
                }
                if (playerMove.Name == "LS")
                {


                }



                if (playerMove.Name == "A")
                {

                    if (isBrace)//if you are brace yuo can do anything
                    {
                        //isShieldBash = true;
                        hit.Clear();
                        isAtk1 = true;
                        currentAnimationTime = TimeSpan.Zero;
                        justBones.CopyTo(previousAnimation, 0);
                        isBrace = false;
                        
                        //ScreenManager.spears[0].state = 1;
                        //need to set attack
                    }

                }
                if (playerMove.Name == "AA")
                {
                    //if (!isAtk1 && !isAtk2)

                    //if (!isShieldUpper)
                    //{

                    //    isShieldUpper = true;
                    //    //currentAnimationTime = TimeSpan.Zero;
                    //    //justBones.CopyTo(previousAnimation, 0);

                    //    if (!isShieldBash)
                    //        currentAnimationTime = TimeSpan.Zero;


                    //}


                }

                if (playerMove.Name == "X")
                {
                    //if (!isShieldSpin)
                    //{
                    //    isShieldSpin = true;
                    //    currentAnimationTime = TimeSpan.Zero;
                    //}
                    //justBones.CopyTo(previousAnimation, 0);




                }
                Console.WriteLine(playerMove.Name);

            }

            if (isKnockedBack)
            {
                if (!isKnockBack)
                {
                    isKnockBack = true;
                    currentAnimationTime = TimeSpan.Zero;
                    justBones.CopyTo(previousAnimation, 0);

                    isShieldBash = false;
                    isShieldUpper = false;
                    isShieldToss = false;
                }

            }


            //if (Math.Abs(rotationAmount.X) > .3f || Math.Abs(rotationAmount.Y) > .3f)
            {
                //Direction = new Vector3(rotationAmount.X, 0.0f, rotationAmount.Y);



                if ((rotationAmount.X) > .3f)
                {

                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, -.03f));
                }
                if ((rotationAmount.X) < -.3f)
                {
                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, .03f));

                }
                thrustAmount = -currentGamePadState.ThumbSticks.Left.Y;

                if (thrustAmount > 1)
                    thrustAmount = 1.0f;
                if (thrustAmount < -1)
                    thrustAmount = -1.0f;

             

                if (Math.Abs(thrustAmount) > 0.3f)
                {

                    isRun = true;
                    justBones.CopyTo(previousAnimation, 0);
                    //isBrace = false; 
                }
                else
                {
                    isRun = false;

                    runTime = TimeSpan.Zero;
                }
                //  else
                //  thrustAmount = rotationAmount.Y;
            }
            //else
            //    thrustAmount = 0.0f;

            Up.Normalize();
            Direction.Normalize();




            Right = Vector3.Cross(Direction, Up);
            if (isAtk1)
                UpdateBasic1(gameTime);
            else if (isRun)
                updateRun(gameTime);
            else if (isBrace)
                UpdateBrace(gameTime);
            else if (isKnockBack)
                UpdateKnockBack(gameTime);
            //else if (isBraced)
            //    UpdateBrace(gameTime);
            else
                previousAnimation.CopyTo(justBones, 0);
         


           

            Position += Direction * thrustAmount * 5.0f;
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);

            world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);



            if (isKnockBack)
                Position = oldPosition + knockBackVec * 5.0f;

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            ray = new Ray(new Vector3(Position.X, 90.0f, Position.Z), Direction);


            //  if (resetFormations)
            {
                //    resetFormations = false;

                formation = world;
            }
            // position = new Vector3(-100.0f, 0.0f, 0.0f);



        }
        public void updateSpearMelee(GameTime gameTime)
        {

            currentAnimationTime += TimeSpan.FromTicks(gameTime.ElapsedGameTime.Ticks * 9);
                if (currentAnimationTime.TotalSeconds < 9.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            spear1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spear1[i].Decompose(out scale, out rota, out trans);
                            spear2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 2.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spear2[i].Decompose(out scale, out rota, out trans);
                            spear3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 2.0f));

                        }


                    }

                    else if (currentAnimationTime.TotalSeconds < 5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spear3[i].Decompose(out scale, out rota, out trans);
                            spearSpin1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spearSpin1[i].Decompose(out scale, out rota, out trans);
                            spearSpin2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 7.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spearSpin2[i].Decompose(out scale, out rota, out trans);
                            spearSpin3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 6.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 6.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 8.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spearSpin3[i].Decompose(out scale, out rota, out trans);
                            spearSpin4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 7.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 7.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spearSpin4[i].Decompose(out scale, out rota, out trans);
                            spearSpin5[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 8.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 8.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spearSpin3[i].Decompose(out scale, out rota, out trans);
                            spearSpin4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 8.0) / 9.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 8.0) / 9.0f));

                        }


                    }



                }
                else
                {

                    Melee = false;
                    isSpear = false;
                    energy = 0;
                    currentAnimationTime = TimeSpan.Zero;
                }



            


        }
        public void updateSpearPin(GameTime gameTime)
        {
            currentAnimationTime += gameTime.ElapsedGameTime;
            if (currentAnimationTime.TotalSeconds < 4.0f)
            {

                if (currentAnimationTime.TotalSeconds < 1.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        previousAnimation[i].Decompose(out scale, out rota, out trans);
                        spearPin1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 2.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        spearPin1[i].Decompose(out scale, out rota, out trans);
                        spearPin2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 2.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 2.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 3.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        spearPin2[i].Decompose(out scale, out rota, out trans);
                        spearPin3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 3.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 3.0f));

                    }

                   
                }
                else if (currentAnimationTime.TotalSeconds < 4.0f)
                {
                    //if (arrow1Fired == false)
                    //{
                    //    projectiles.Add(new Projectile2("Spear", spearWorld, Direction));
                    //    arrow1Fired = true;
                    //}
                    for (int i = 0; i < brace.Length; i++)
                    {
                        spearThrow3[i].Decompose(out scale, out rota, out trans);
                        spearThrow4[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 4.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 4.0f));

                    }


                }

            }
            else
            {
                // if (arrow1Fired == false)
                //{

                    projectiles.Add(new Projectile2("pinSpear", spearWorld, Direction));
            
               


                isSpearPin = false;

                Range = false;
                currentAnimationTime = TimeSpan.Zero;
                energy = 0;
                //EternalStruggle.As.Add(new EternalStruggle.RageHit(TimeSpan.FromSeconds(4)));



            }
            












        }
        public void updateSpearThrow(GameTime gameTime)
        {
            currentAnimationTime += TimeSpan.FromTicks(gameTime.ElapsedGameTime.Ticks * 4);
            if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            spearThrow1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spearThrow1[i].Decompose(out scale, out rota, out trans);
                            spearThrow2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 2.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spearThrow2[i].Decompose(out scale, out rota, out trans);
                            spearThrow3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) /3.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 3.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        //if (arrow1Fired == false)
                        //{
                        //    projectiles.Add(new Projectile2("Spear", arrowWorld, Direction));
                        //    arrow1Fired = true;
                        //}
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spearThrow3[i].Decompose(out scale, out rota, out trans);
                            spearThrow4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 4.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 4.0f));

                        }


                    }

                }
                else 
                {
                   // if (arrow1Fired == false)
                    //{
                     //    arrow1Fired = false;
                        projectiles.Add(new Projectile2("Spear", spearWorld, Direction));

                    //}

                    isSpearThrow = false;
                    active = false;
                    Range = false;
                    currentAnimationTime = TimeSpan.Zero;
                    energy = 0; 
                    //EternalStruggle.As.Add(new EternalStruggle.RageHit(TimeSpan.FromSeconds(4)));



                }
            


        }
        public void updateSwordFollower(GameTime gameTime)
        {

            oldPosition = Position;
                float dToT = Vector3.Distance(Position, formationVector);
                float rotationAmount = 0.0f;
                rotationAmount = TurnToFace(Position, formationVector, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));


                float x = (float)Math.Sin(rotationAmount);
                float y = (float)Math.Cos(rotationAmount);
                Direction = new Vector3(x, 0.0f, y);
            
            if(dToT > 30)
                Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * 0.3f;
            




            //if (isRun)
            //    upperBones.CopyTo(justBones, 0);
            //else if (isSpearThrow)
            //    upperBones.CopyTo(justBones, 0);
            //else if (isSpearPin)
            //    upperBones.CopyTo(justBones, 0);
            //else if (isSpear)
            //    upperBones.CopyTo(justBones, 0);
            //else if (isAtk1)
            //    upperBones.CopyTo(justBones, 0);
            //else
                brace.CopyTo(justBones, 0);

           // Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * 1.0f;

            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            formation = world; 
            
        }
        public void updateSpearAi(GameTime gameTime)
        {

            oldPosition = Position;
            float dToT = Vector3.Distance(position, ScreenManager.Michael.World.Translation);
            float rotationAmount = 0.0f;
            rotationAmount = TurnToFace(position, ScreenManager.Michael.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));


            foreach (Projectile2 pro in projectiles)
            {

                if (pro.Name == "pinSpear")
                    pro.update2ENonMoving(gameTime);
                else
                    pro.update2E(gameTime);
            }

            

            if (!Melee & !Range)
            {
                if (ScreenManager.rand.Next() % 2 == 0)
                {
                    Melee = true;





                }
                else
                    Range = true; 
            }

            if (Range)
            {

                if (dToT > 300.0f)
                {
                    //  resetFormation = true;
                    thrustAmount = 0.3f;
                    runTime = TimeSpan.Zero;
                    if (!isRun)
                    {
                        isRun = true;
                        justBones.CopyTo(previousAnimation, 0);

                    }
                    
                }
               else 
                {
                    thrustAmount = 0.0f;
                    runTime = TimeSpan.Zero;
                   if (dToT < 80)
                    {
                        thrustAmount = 0.0f;
                        isRun = false;

                    }
                    if (!isSpearThrow &! isSpearPin)
                    {
                        if (dToT > 150)
                            isSpearThrow = true;
                        else
                            isSpearPin = true;
                        //isRun = false;
                        justBones.CopyTo(previousAnimation, 0);
                        currentAnimationTime = TimeSpan.Zero;

                    }

                    if (isSpearThrow)
                        updateSpearThrow(gameTime);
                    else if (isSpearPin)
                        updateSpearPin(gameTime);

                }


                float x = (float)Math.Sin(rotationAmount);
                float y = (float)Math.Cos(rotationAmount);
                Direction = new Vector3(x, 0.0f, y);







            }
            if (Melee)
            {

                if (dToT > 100.0f)
                {
                    //  resetFormation = true;
                    thrustAmount = 1.0f;
                    if (!isRun)
                    {
                        isRun = true;
                        justBones.CopyTo(previousAnimation, 0);
 
                    }
                    updateRun(gameTime);
                }

                else if (!isSpear &! isAtk1)
                {

                    if (ScreenManager.rand.Next() % 2 == 0)
                    {
                        isSpear = true;

                    }
                    else
                        isAtk1 = true;


                    isRun = false;

                    justBones.CopyTo(previousAnimation, 0);
                    currentAnimationTime = TimeSpan.Zero;



                }
                if (dToT < 70)
                {
                    thrustAmount = 0.0f;
                    isRun = false;
                }
                float x = (float)Math.Sin(rotationAmount);
                float y = (float)Math.Cos(rotationAmount);
                Direction = new Vector3(x, 0.0f, y);
                          
                  
                if(isSpear)
                updateSpearMelee(gameTime);
                if (isAtk1)
                    UpdateBasic1(gameTime);
                
            }




            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isSpearThrow)
                upperBones.CopyTo(justBones, 0);
            else if (isSpearPin)
                upperBones.CopyTo(justBones, 0);
            else if (isSpear)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1)
                upperBones.CopyTo(justBones, 0); 
            else
                brace.CopyTo(justBones, 0);

            Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 5.0f;

            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            formation = world; 


        }
        public void LSUpdateEngineer(GameTime gameTime)
        {


            float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds;
            oldGamePadState = currentGamePadState;
            oldkeyBoardState = currentKeyBoardState;
            World.Decompose(out scale, out rota, out trans);
            oldPosition = Position;
            oldDirection = Direction;
            currentGamePadState = GamePad.GetState(PlayerIndex.One);

            foreach (Projectile2 pro in projectiles)
                pro.update2(gameTime);


            Vector2 rotationAmount = currentGamePadState.ThumbSticks.Left;

            Vector2 inputAmount = currentGamePadState.ThumbSticks.Right;

            //rotAmt = TurnToFace(ScreenManager.asterion.Position, ScreenManager.medusa.Position, Vector3.Zero);
            // Direction = new Vector3((float)Math.Sin(rotAmt), 0.0f, (float)Math.Cos(rotAmt));

            if (gameTime.TotalGameTime - playerMoveTime > MoveTimeOut)
            {
                playerMove = null;
            }

            Console.WriteLine((int)CFormation[1].X / 100);
            Console.WriteLine((int)CFormation[1].Z / 100);

            //inputManager.Update(gameTime);
            Move newMove = ScreenManager.moveList.DetectMove(ScreenManager.inputManager);
            if (!isKnockBack)

                if (newMove != null)
                {
                    playerMove = newMove;

                    playerMoveTime = gameTime.TotalGameTime;

                    if (playerMove.Name == "RS")
                    {
                        projectiles.Add(new Projectile2("Fire", forwardSpell, Direction));

                    }
                    if (playerMove.Name == "LT")
                    {
                        //testingIndex++;
                        //if (testingIndex > 2)
                        //    testingIndex = 0;

                        if ((int)Position.Z / 30 != 0)

                            if (ScreenManager.pathBoard[(int)Position.X / 30][(int)Position.Z / 30] == true &&
                                ScreenManager.pathBoard[(int)Position.X / 30 + 1][(int)Position.Z / 30] == true &&
                                ScreenManager.pathBoard[(int)Position.X / 30 + 1][(int)Position.Z / 30 + 1] == true &&
                                    ScreenManager.pathBoard[(int)Position.X / 30][(int)Position.Z / 30] == true)
                            {
                                JuneXnaModel newJune = new JuneXnaModel(new Vector3((int)Position.X / 30 * 30 + 30, 0.0f, (int)Position.Z / 30 * 30 + 30), Vector3.Backward);
                                newJune.skinningData = ScreenManager.juneModel.Tag as SkinningData;
                                newJune.setAnimationPlayers();
                                loadSpheresJuneModel(newJune);
                                ScreenManager.playerTowers.Add(newJune);

                                ScreenManager.pathBoard[(int)Position.X / 30][(int)Position.Z / 30] = false;

                                ScreenManager.pathBoard[(int)Position.X / 30 + 1][(int)Position.Z / 30 + 1] = false;

                                ScreenManager.pathBoard[(int)Position.X / 30][(int)Position.Z / 30 + 1] = false;

                                ScreenManager.pathBoard[(int)Position.X / 30 + 1][(int)Position.Z / 30] = false;

                                if (ScreenManager.LSRunner.flag == 0)
                                    ScreenManager.LSRunner.uiPath.Reset(fromVecLS(position), fromVecLS(new Vector3(0.0f, 0.0f, 270.0f)));

                                //ScreenManager.boardPanel[(int)Position.X / 25][(int)Position.Z / 100] = 1;

                                //ScreenManager.runner1.uiPath.Reset(fromVec(ScreenManager.runner1.Position), fromVec(Screenmanager));
                                //ScreenManager.runner1.pathState = 0;
                                //ScreenManager.runner1.pathing.Clear();

                                //foreach(JuneXnaModel juney in ScreenManager.enemyRunners)
                                //{
                                //    juney.uiPath.Reset(fromVec(juney.Position), fromVec(new Vector3(juney.Position.X, 0.0f, 0.0f)));
                                //    juney.pathState = 0;
                                //    juney.pathing.Clear();
                                //}
                            }



                    }
                    if (playerMove.Name == "RT")
                    {

                        //Vector3 spot = new Vector3((int)Position.X/100 * 100 + 50, 0.0f, (int)Position.Z/100 * 100 + 50);


                        // if(Vector3.Distance(Position, spot) < 100)
                        //Point spot = new Point((int)Position.X / 100, (int)Position.Z / 100);
                        if ((int)Position.Z / 100 != 0)
                        {
                            ScreenManager.pathBoard[(int)Position.X / 100][(int)Position.Z / 100] = false;
                            ScreenManager.boardPanel[(int)Position.X / 100][(int)Position.Z / 100] = 1;

                            ScreenManager.runner1.uiPath.Reset(fromVec(ScreenManager.runner1.Position), fromVec(Vector3.Zero));
                            ScreenManager.runner1.pathState = 0;
                            ScreenManager.runner1.pathing.Clear();
                        }
                    }


                    if (playerMove.Name == "LS")
                    {
                        if (ScreenManager.buildStage == true)
                        {
                            
                            ScreenManager.LSRunner.uiPath = new UnitPathing(fromVec(position), fromVec(ScreenManager.cupidTemple.position - new Vector3(0.0f, 0.0f, 30.0f)));
                            ScreenManager.buildStage = false;
                        }
                        else
                            ScreenManager.buildStage = true;


                    }



                    if (playerMove.Name == "A")
                    {

                        if (!isHammerStrike)
                        {
                            isHammerStrike = true;
                            currentAnimationTime = TimeSpan.Zero;
                            justBones.CopyTo(previousAnimation, 0);

                            //ScreenManager.spears[0].state = 1;
                            //need to set attack
                        }

                    }
                    if (playerMove.Name == "AA")
                    {
                        //if (!isAtk1 && !isAtk2)

                        if (!isDoubleStrike)
                        {

                            isDoubleStrike = true;
                            //currentAnimationTime = TimeSpan.Zero;
                            //justBones.CopyTo(previousAnimation, 0);

                            if (!isHammerStrike)
                                currentAnimationTime = TimeSpan.Zero;


                        }


                    }

                    if (playerMove.Name == "X")
                    {
                        if (!isHammerFlight)
                        {
                            isHammerFlight = true;
                            currentAnimationTime = TimeSpan.Zero;
                        }
                        justBones.CopyTo(previousAnimation, 0);




                    }
                    Console.WriteLine(playerMove.Name);

                }

            if (isKnockedBack)
            {
                if (!isKnockBack)
                {
                    isKnockBack = true;
                    currentAnimationTime = TimeSpan.Zero;
                    justBones.CopyTo(previousAnimation, 0);

                    isHammerFlight = false;
                    isHammerStrike = false;
                    isDoubleStrike = false;
                    isHammerToss = false;
                }

            }


            //if (Math.Abs(rotationAmount.X) > .3f || Math.Abs(rotationAmount.Y) > .3f)
            {
                //Direction = new Vector3(rotationAmount.X, 0.0f, rotationAmount.Y);



                if ((rotationAmount.X) > .3f)
                {

                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, -.03f));
                }
                if ((rotationAmount.X) < -.3f)
                {
                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, .03f));

                }
                thrustAmount = -currentGamePadState.ThumbSticks.Left.Y;

                if (thrustAmount > 1)
                    thrustAmount = 1.0f;
                if (thrustAmount < -1)
                    thrustAmount = -1.0f;



                if (Math.Abs(thrustAmount) > 0.0f)
                {
                    isRun = true;
                    justBones.CopyTo(previousAnimation, 0);
                }
                else
                {
                    isRun = false;
                    runTime = TimeSpan.Zero;
                }
                //  else
                //  thrustAmount = rotationAmount.Y;
            }
            //else
            //    thrustAmount = 0.0f;

            Up.Normalize();
            Direction.Normalize();




            Right = Vector3.Cross(Direction, Up);
            if (isRun)
            {
                runTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)3.0);
                if (runTime.TotalSeconds < 9.0f)
                {

                    //        if (runTime.TotalSeconds < 1.0f)
                    //        {

                    //            for (int i = 0; i < brace.Length; i++)
                    //            {
                    //                previousAnimation[i].Decompose(out scale, out rota, out trans);
                    //                run1a[i].Decompose(out scale2, out rota2, out trans2);
                    //                upperBones[i] = Matrix.CreateScale(scale2) *
                    //Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
                    //Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                    //            }

                    //        }
                    //        else 
                    if (runTime.TotalSeconds < 1.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun1[i].Decompose(out scale, out rota, out trans);
                            lRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun2[i].Decompose(out scale, out rota, out trans);
                            lRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun3[i].Decompose(out scale, out rota, out trans);
                            lRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun4[i].Decompose(out scale, out rota, out trans);
                            rRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun1[i].Decompose(out scale, out rota, out trans);
                            rRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 5.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 7.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun2[i].Decompose(out scale, out rota, out trans);
                            rRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 6.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 6.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 8.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun3[i].Decompose(out scale, out rota, out trans);
                            rRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 7.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 7.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun4[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 8.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 8.0) / 1.0f));

                        }


                    }

                }
                else
                {

                    runTime = TimeSpan.Zero;
                    lRun1.CopyTo(previousAnimation, 0);



                }

            }
            currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)2);

            if (isKnockBack)
            {

                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            kb1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb1[i].Decompose(out scale, out rota, out trans);
                            kb2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb2[i].Decompose(out scale, out rota, out trans);
                            kb3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb3[i].Decompose(out scale, out rota, out trans);
                            knockDown[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }

                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isKnockBack = false;
                    isKnockedBack = false;
                }












            }

            if (isHammerFlight)
            {


                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 2.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            hammerFlight1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 2.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            hammerFlight1[i].Decompose(out scale, out rota, out trans);
                            hammerFlight2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 2.0f));

                        }


                    }
                    else
                    {
                        currentAnimationTime = TimeSpan.Zero;
                        isHammerFlight = false;
                    }

                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isHammerFlight = false;
                }


            }
            if (isHammerStrike)
            {
                if (currentAnimationTime.TotalSeconds < 3.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            hammerStrike1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            hammerStrike1[i].Decompose(out scale, out rota, out trans);
                            hammerStrike2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            hammerStrike2[i].Decompose(out scale, out rota, out trans);
                            hammerStrike3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }

                }
                else if (!isDoubleStrike)
                {

                    isHammerStrike = false;
                    currentAnimationTime = TimeSpan.Zero;



                }

                else if (currentAnimationTime.TotalSeconds < 4.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        hammerStrike3[i].Decompose(out scale, out rota, out trans);
                        hammerStrike1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 5.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        hammerStrike1[i].Decompose(out scale, out rota, out trans);
                        hammerStrike2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                    }


                }

                else if (currentAnimationTime.TotalSeconds < 6.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        hammerStrike2[i].Decompose(out scale, out rota, out trans);
                        hammerStrike3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                    }


                }



                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isHammerStrike = false;
                    isDoubleStrike = false;

                }


            }




            //world = Matrix.Identity;
            //world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            //world.Up = Up;
            //world.Right = Right;
            //world.Translation = Position + new Vector3(0.0f, 0.0f, 0.0f);


            //if (isAtk1)
            // upperBones.CopyTo(justBones, 0);
            //else

            // world = Matrix.Identity;

            Position += Direction * thrustAmount * 5.0f;
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isHammerStrike)
                upperBones.CopyTo(justBones, 0);
            else if (isHammerFlight)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);

            world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);



            if (isKnockBack)
                Position = oldPosition + knockBackVec * 5.0f;

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();


            ray = new Ray(new Vector3(Position.X, 90.0f, Position.Z), Direction);


            //  if (resetFormations)
            {
                //    resetFormations = false;

                formation = world;
            }
            // position = new Vector3(-100.0f, 0.0f, 0.0f);



        }
        public void LSEngineer(GameTime gameTime)
        {


            float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds;
            time += TimeSpan.FromSeconds(elapsed);

            oldGamePadState = currentGamePadState;
            oldkeyBoardState = currentKeyBoardState;
            World.Decompose(out scale, out rota, out trans);
            oldPosition = Position;
            oldDirection = Direction;
            currentGamePadState = GamePad.GetState(PlayerIndex.One);

            foreach (Projectile2 pro in projectiles)
                pro.update2(gameTime);


            Vector2 rotationAmount = currentGamePadState.ThumbSticks.Left;


            if (time > TimeSpan.FromMilliseconds(500))
            {
                if (rotationAmount.X < -.03)
                {
                    currentX++;
                    time = TimeSpan.Zero;
                }
                if (rotationAmount.X > .03)
                {
                    currentX--;
                    time = TimeSpan.Zero;
                }
                if (rotationAmount.Y < -.03)
                {
                    currentY++;
                    time = TimeSpan.Zero;
                }
                if (rotationAmount.Y > .03)
                {
                    currentY--;
                    time = TimeSpan.Zero;
                }

                Console.WriteLine(currentX + " " + currentY);
            }
            Vector2 inputAmount = currentGamePadState.ThumbSticks.Right;

            //rotAmt = TurnToFace(ScreenManager.asterion.Position, ScreenManager.medusa.Position, Vector3.Zero);
            // Direction = new Vector3((float)Math.Sin(rotAmt), 0.0f, (float)Math.Cos(rotAmt));

            if (gameTime.TotalGameTime - playerMoveTime > MoveTimeOut)
            {
                playerMove = null;
            }

            //Console.WriteLine((int)CFormation[1].X / 100);
            //Console.WriteLine((int)CFormation[1].Z/ 100);

            //inputManager.Update(gameTime);
            Move newMove = ScreenManager.moveList.DetectMove(ScreenManager.inputManager);
            if (!isKnockBack)

                if (newMove != null)
                {
                    playerMove = newMove;

                    playerMoveTime = gameTime.TotalGameTime;

                    if (playerMove.Name == "RS")
                    {
                        projectiles.Add(new Projectile2("Fire", forwardSpell, Direction));

                    }
                    if (playerMove.Name == "LT")
                    {
                        //testingIndex++;
                        //if (testingIndex > 2)
                        //    testingIndex = 0;

                        if ((int)Position.Z / 30 != 0)

                            if (ScreenManager.pathBoard[(int)Position.X / 30][(int)Position.Z / 30] == true &&
                                ScreenManager.pathBoard[(int)Position.X / 30 + 1][(int)Position.Z / 30] == true &&
                                ScreenManager.pathBoard[(int)Position.X / 30 + 1][(int)Position.Z / 30 + 1] == true &&
                                    ScreenManager.pathBoard[(int)Position.X / 30][(int)Position.Z / 30] == true)
                            {
                                JuneXnaModel newJune = new JuneXnaModel(new Vector3((int)Position.X / 30 * 30 + 30, 0.0f, (int)Position.Z / 30 * 30 + 30), Vector3.Backward);
                                newJune.skinningData = ScreenManager.juneModel.Tag as SkinningData;
                                newJune.setAnimationPlayers();
                                loadSpheresJuneModel(newJune);
                                ScreenManager.playerTowers.Add(newJune);

                                ScreenManager.pathBoard[(int)Position.X / 30][(int)Position.Z / 30] = false;

                                ScreenManager.pathBoard[(int)Position.X / 30 + 1][(int)Position.Z / 30 + 1] = false;

                                ScreenManager.pathBoard[(int)Position.X / 30][(int)Position.Z / 30 + 1] = false;

                                ScreenManager.pathBoard[(int)Position.X / 30 + 1][(int)Position.Z / 30] = false;
                                //ScreenManager.boardPanel[(int)Position.X / 25][(int)Position.Z / 100] = 1;

                                //ScreenManager.runner1.uiPath.Reset(fromVec(ScreenManager.runner1.Position), fromVec(Screenmanager));
                                //ScreenManager.runner1.pathState = 0;
                                //ScreenManager.runner1.pathing.Clear();

                                //foreach(JuneXnaModel juney in ScreenManager.enemyRunners)
                                //{
                                //    juney.uiPath.Reset(fromVec(juney.Position), fromVec(new Vector3(juney.Position.X, 0.0f, 0.0f)));
                                //    juney.pathState = 0;
                                //    juney.pathing.Clear();
                                //}
                            }



                    }
                    if (playerMove.Name == "RT")
                    {

                        //Vector3 spot = new Vector3((int)Position.X/100 * 100 + 50, 0.0f, (int)Position.Z/100 * 100 + 50);


                        // if(Vector3.Distance(Position, spot) < 100)
                        //Point spot = new Point((int)Position.X / 100, (int)Position.Z / 100);
                        if ((int)Position.Z / 100 != 0)
                        {
                            ScreenManager.pathBoard[(int)Position.X / 100][(int)Position.Z / 100] = false;
                            ScreenManager.boardPanel[(int)Position.X / 100][(int)Position.Z / 100] = 1;

                            ScreenManager.runner1.uiPath.Reset(fromVec(ScreenManager.runner1.Position), fromVec(Vector3.Zero));
                            ScreenManager.runner1.pathState = 0;
                            ScreenManager.runner1.pathing.Clear();
                        }
                    }


                    if (playerMove.Name == "LS")
                    {
                        if (ScreenManager.buildStage == true)
                            ScreenManager.buildStage = false;
                        else
                            ScreenManager.buildStage = true;


                    }



                    if (playerMove.Name == "A")
                    {

                        if (!isHammerStrike)
                        {
                            isHammerStrike = true;
                            currentAnimationTime = TimeSpan.Zero;
                            justBones.CopyTo(previousAnimation, 0);

                            //ScreenManager.spears[0].state = 1;
                            //need to set attack
                        }

                    }
                    if (playerMove.Name == "AA")
                    {
                        //if (!isAtk1 && !isAtk2)

                        if (!isDoubleStrike)
                        {

                            isDoubleStrike = true;
                            //currentAnimationTime = TimeSpan.Zero;
                            //justBones.CopyTo(previousAnimation, 0);

                            if (!isHammerStrike)
                                currentAnimationTime = TimeSpan.Zero;


                        }


                    }

                    if (playerMove.Name == "X")
                    {
                        if (!isHammerFlight)
                        {
                            isHammerFlight = true;
                            currentAnimationTime = TimeSpan.Zero;
                        }
                        justBones.CopyTo(previousAnimation, 0);




                    }
                    Console.WriteLine(playerMove.Name);

                }

            if (isKnockedBack)
            {
                if (!isKnockBack)
                {
                    isKnockBack = true;
                    currentAnimationTime = TimeSpan.Zero;
                    justBones.CopyTo(previousAnimation, 0);

                    isHammerFlight = false;
                    isHammerStrike = false;
                    isDoubleStrike = false;
                    isHammerToss = false;
                }

            }


            //if (Math.Abs(rotationAmount.X) > .3f || Math.Abs(rotationAmount.Y) > .3f)
            {
                //Direction = new Vector3(rotationAmount.X, 0.0f, rotationAmount.Y);



                if ((rotationAmount.X) > .3f)
                {

                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, -.03f));
                }
                if ((rotationAmount.X) < -.3f)
                {
                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, .03f));

                }

                //Direction = new Vector3(currentGamePadState.ThumbSticks.Right.X, 0.0f, currentGamePadState.ThumbSticks.Right.Y);
                thrustAmount = -currentGamePadState.ThumbSticks.Left.Y;

                if (thrustAmount > 1)
                    thrustAmount = 1.0f;
                if (thrustAmount < -1)
                    thrustAmount = -1.0f;



                if (Math.Abs(thrustAmount) > 0.0f)
                {
                    isRun = true;
                    justBones.CopyTo(previousAnimation, 0);
                }
                else
                {
                    isRun = false;
                    runTime = TimeSpan.Zero;
                }
                //  else
                //  thrustAmount = rotationAmount.Y;
            }
            //else
            //    thrustAmount = 0.0f;

            Up.Normalize();
            Direction.Normalize();




            Right = Vector3.Cross(Direction, Up);
            if (isRun)
            {
                updateRun(gameTime);

            }
          

            
            

           
            
            if (isHammerStrike)
            {
                if (currentAnimationTime.TotalSeconds < 3.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            hammerStrike1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            hammerStrike1[i].Decompose(out scale, out rota, out trans);
                            hammerStrike2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            hammerStrike2[i].Decompose(out scale, out rota, out trans);
                            hammerStrike3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }

                }
                else if (!isDoubleStrike)
                {

                    isHammerStrike = false;
                    currentAnimationTime = TimeSpan.Zero;



                }

                else if (currentAnimationTime.TotalSeconds < 4.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        hammerStrike3[i].Decompose(out scale, out rota, out trans);
                        hammerStrike1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 5.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        hammerStrike1[i].Decompose(out scale, out rota, out trans);
                        hammerStrike2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                    }


                }

                else if (currentAnimationTime.TotalSeconds < 6.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        hammerStrike2[i].Decompose(out scale, out rota, out trans);
                        hammerStrike3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                    }


                }



                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isHammerStrike = false;
                    isDoubleStrike = false;

                }


            }




            //world = Matrix.Identity;
            //world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            //world.Up = Up;
            //world.Right = Right;
            //world.Translation = Position + new Vector3(0.0f, 0.0f, 0.0f);


            //if (isAtk1)
            // upperBones.CopyTo(justBones, 0);
            //else

            // world = Matrix.Identity;

            Position = new Vector3(currentX * 30.0f, 0.0f, currentY * 30.0f);
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isHammerStrike)
                upperBones.CopyTo(justBones, 0);
            else if (isHammerFlight)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);

            world.Forward = Vector3.Forward;



            if (isKnockBack)
                Position = oldPosition + knockBackVec * 5.0f;

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();


            ray = new Ray(new Vector3(Position.X, 90.0f, Position.Z), Direction);


            //  if (resetFormations)
            {
                //    resetFormations = false;

                formation = world;
            }
            // position = new Vector3(-100.0f, 0.0f, 0.0f);



        }
        public void UpdateEngineer(GameTime gameTime)
        {


            float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds;
            oldGamePadState = currentGamePadState;
            oldkeyBoardState = currentKeyBoardState;
            World.Decompose(out scale, out rota, out trans);
            oldPosition = Position;
            oldDirection = Direction;
            currentGamePadState = GamePad.GetState(PlayerIndex.One);

            foreach (Projectile2 pro in projectiles)
                pro.update2(gameTime);


            Vector2 rotationAmount = currentGamePadState.ThumbSticks.Left;

            Vector2 inputAmount = currentGamePadState.ThumbSticks.Right;

            //rotAmt = TurnToFace(ScreenManager.asterion.Position, ScreenManager.medusa.Position, Vector3.Zero);
            // Direction = new Vector3((float)Math.Sin(rotAmt), 0.0f, (float)Math.Cos(rotAmt));

            if (gameTime.TotalGameTime - playerMoveTime > MoveTimeOut)
            {
                playerMove = null;
            }
            ScreenManager.fakeStatue.Position = new Vector3((int)Position.X / 30 * 30 + 30, 0.0f, (int)Position.Z / 30 * 30 + 30);
            //Console.WriteLine((int)CFormation[1].X / 100);
            //Console.WriteLine((int)CFormation[1].Z/ 100);

            //inputManager.Update(gameTime);
            Move newMove = ScreenManager.moveList.DetectMove(ScreenManager.inputManager);
            if (!isKnockBack)

                if (newMove != null)
                {
                    playerMove = newMove;

                    playerMoveTime = gameTime.TotalGameTime;

                    if (playerMove.Name == "RS")
                    {
                        projectiles.Add(new Projectile2("Fire", forwardSpell, Direction));

                    }
                    if (playerMove.Name == "LT")
                    {
                        //testingIndex++;
                        //if (testingIndex > 2)
                        //    testingIndex = 0;


                        if ((int)Position.Z/30 != 0)
                        
                            if(ScreenManager.pathBoard[(int)Position.X / 30][(int)Position.Z / 30] == true &&
                                ScreenManager.pathBoard[(int)Position.X / 30+ 1][(int)Position.Z / 30] == true &&
                                ScreenManager.pathBoard[(int)Position.X / 30 + 1][(int)Position.Z / 30 + 1] == true &&
                                    ScreenManager.pathBoard[(int)Position.X / 30][(int)Position.Z / 30] == true)
                            {
                         JuneXnaModel newJune  = new JuneXnaModel(new Vector3((int)Position.X / 30 * 30 + 30, 0.0f, (int)Position.Z / 30 * 30 + 30), Vector3.Backward);
                        newJune.skinningData = ScreenManager.juneModel.Tag as SkinningData;
                        newJune.setAnimationPlayers();
                        loadSpheresJuneModel(newJune);
                        ScreenManager.playerTowers.Add(newJune);

                        ScreenManager.pathBoard[(int)Position.X / 30][(int)Position.Z / 30] = false;

                        ScreenManager.pathBoard[(int)Position.X / 30 + 1][(int)Position.Z / 30 + 1] = false;

                        ScreenManager.pathBoard[(int)Position.X / 30][(int)Position.Z / 30 + 1] = false;

                        ScreenManager.pathBoard[(int)Position.X / 30 + 1][(int)Position.Z / 30] = false;
                        //ScreenManager.boardPanel[(int)Position.X / 25][(int)Position.Z / 100] = 1;

                        //ScreenManager.runner1.uiPath.Reset(fromVec(ScreenManager.runner1.Position), fromVec(Screenmanager));
                        //ScreenManager.runner1.pathState = 0;
                        //ScreenManager.runner1.pathing.Clear();

                            //foreach(JuneXnaModel juney in ScreenManager.enemyRunners)
                            //{
                            //    juney.uiPath.Reset(fromVec(juney.Position), fromVec(new Vector3(juney.Position.X, 0.0f, 0.0f)));
                            //    juney.pathState = 0;
                            //    juney.pathing.Clear();
                            //}
                            }
                     
                        

                    }
                    if (playerMove.Name == "RT")
                    {

                       //Vector3 spot = new Vector3((int)Position.X/100 * 100 + 50, 0.0f, (int)Position.Z/100 * 100 + 50);
                        

                       // if(Vector3.Distance(Position, spot) < 100)
                        //Point spot = new Point((int)Position.X / 100, (int)Position.Z / 100);
                        if ((int)Position.Z/100 != 0)
                        {
                            ScreenManager.pathBoard[(int)Position.X / 100][(int)Position.Z / 100] = false;
                            ScreenManager.boardPanel[(int)Position.X / 100][(int)Position.Z / 100] = 1;

                            ScreenManager.runner1.uiPath.Reset(fromVec(ScreenManager.runner1.Position), fromVec(Vector3.Zero));
                            ScreenManager.runner1.pathState = 0;
                            ScreenManager.runner1.pathing.Clear();
                        }
                    }


                    if (playerMove.Name == "LS")
                    {
                        if (ScreenManager.buildStage == true)
                            ScreenManager.buildStage = false;
                        else
                            ScreenManager.buildStage = true;


                    }



                    if (playerMove.Name == "A")
                    {
                       
                        if (!isHammerStrike)
                        {
                            isHammerStrike = true;
                            currentAnimationTime = TimeSpan.Zero;
                            justBones.CopyTo(previousAnimation, 0);

                            //ScreenManager.spears[0].state = 1;
                            //need to set attack
                        }

                    }
                    if (playerMove.Name == "AA")
                    {
                        //if (!isAtk1 && !isAtk2)

                        if (!isDoubleStrike)
                        {

                            isDoubleStrike = true;
                            //currentAnimationTime = TimeSpan.Zero;
                            //justBones.CopyTo(previousAnimation, 0);

                            if (!isHammerStrike)
                                currentAnimationTime = TimeSpan.Zero;


                        }


                    }

                    if (playerMove.Name == "X")
                    {
                        if (!isHammerFlight)
                        {
                            isHammerFlight = true;
                            currentAnimationTime = TimeSpan.Zero;
                        }
                        justBones.CopyTo(previousAnimation, 0);




                    }
                    Console.WriteLine(playerMove.Name);

                }

            if (isKnockedBack)
            {
                if (!isKnockBack)
                {
                    isKnockBack = true;
                    currentAnimationTime = TimeSpan.Zero;
                    justBones.CopyTo(previousAnimation, 0);

                    isHammerFlight = false;
                    isHammerStrike = false;
                    isDoubleStrike = false;
                    isHammerToss = false;
                }

            }


            //if (Math.Abs(rotationAmount.X) > .3f || Math.Abs(rotationAmount.Y) > .3f)
            {
                //Direction = new Vector3(rotationAmount.X, 0.0f, rotationAmount.Y);



                if ((rotationAmount.X) > .3f)
                {

                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, -.03f));
                }
                if ((rotationAmount.X) < -.3f)
                {
                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, .03f));

                }

                //Direction = new Vector3(currentGamePadState.ThumbSticks.Right.X, 0.0f, currentGamePadState.ThumbSticks.Right.Y);
                thrustAmount = -currentGamePadState.ThumbSticks.Left.Y;

                if (thrustAmount > 1)
                    thrustAmount = 1.0f;
                if (thrustAmount < -1)
                    thrustAmount = -1.0f;



                if (Math.Abs(thrustAmount) > 0.0f)
                {
                    isRun = true;
                    justBones.CopyTo(previousAnimation, 0);
                }
                else
                {
                    isRun = false;
                    runTime = TimeSpan.Zero;
                }
                //  else
                //  thrustAmount = rotationAmount.Y;
            }
            //else
            //    thrustAmount = 0.0f;

            Up.Normalize();
            Direction.Normalize();




            Right = Vector3.Cross(Direction, Up);
            if (isRun)
            {
                runTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)3.0);
                if (runTime.TotalSeconds < 9.0f)
                {

                    //        if (runTime.TotalSeconds < 1.0f)
                    //        {

                    //            for (int i = 0; i < brace.Length; i++)
                    //            {
                    //                previousAnimation[i].Decompose(out scale, out rota, out trans);
                    //                run1a[i].Decompose(out scale2, out rota2, out trans2);
                    //                upperBones[i] = Matrix.CreateScale(scale2) *
                    //Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
                    //Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                    //            }

                    //        }
                    //        else 
                    if (runTime.TotalSeconds < 1.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun1[i].Decompose(out scale, out rota, out trans);
                            lRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun2[i].Decompose(out scale, out rota, out trans);
                            lRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun3[i].Decompose(out scale, out rota, out trans);
                            lRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun4[i].Decompose(out scale, out rota, out trans);
                            rRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun1[i].Decompose(out scale, out rota, out trans);
                            rRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 5.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 7.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun2[i].Decompose(out scale, out rota, out trans);
                            rRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 6.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 6.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 8.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun3[i].Decompose(out scale, out rota, out trans);
                            rRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 7.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 7.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun4[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 8.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 8.0) / 1.0f));

                        }


                    }

                }
                else
                {

                    runTime = TimeSpan.Zero;
                    lRun1.CopyTo(previousAnimation, 0);



                }

            }
            currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)2);

            if (isKnockBack)
            {

                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            kb1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb1[i].Decompose(out scale, out rota, out trans);
                            kb2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb2[i].Decompose(out scale, out rota, out trans);
                            kb3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb3[i].Decompose(out scale, out rota, out trans);
                            knockDown[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }

                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isKnockBack = false;
                    isKnockedBack = false;
                }












            }

            if (isHammerFlight)
            {


                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 2.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            hammerFlight1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 2.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            hammerFlight1[i].Decompose(out scale, out rota, out trans);
                            hammerFlight2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 2.0f));

                        }


                    }
                    else
                    {
                        currentAnimationTime = TimeSpan.Zero;
                        isHammerFlight = false;
                    }

                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isHammerFlight = false;
                }


            }
            if (isHammerStrike)
            {
                if (currentAnimationTime.TotalSeconds < 3.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            hammerStrike1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            hammerStrike1[i].Decompose(out scale, out rota, out trans);
                            hammerStrike2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            hammerStrike2[i].Decompose(out scale, out rota, out trans);
                            hammerStrike3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }

                }
                else if (!isDoubleStrike)
                {

                    isHammerStrike = false;
                    currentAnimationTime = TimeSpan.Zero;



                }

                else if (currentAnimationTime.TotalSeconds < 4.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        hammerStrike3[i].Decompose(out scale, out rota, out trans);
                        hammerStrike1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 5.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        hammerStrike1[i].Decompose(out scale, out rota, out trans);
                        hammerStrike2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                    }


                }

                else if (currentAnimationTime.TotalSeconds < 6.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        hammerStrike2[i].Decompose(out scale, out rota, out trans);
                        hammerStrike3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                    }


                }



                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isHammerStrike = false;
                    isDoubleStrike = false;

                }


            }




            //world = Matrix.Identity;
            //world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            //world.Up = Up;
            //world.Right = Right;
            //world.Translation = Position + new Vector3(0.0f, 0.0f, 0.0f);


            //if (isAtk1)
            // upperBones.CopyTo(justBones, 0);
            //else

            // world = Matrix.Identity;

            Position += Direction * thrustAmount * 5.0f;
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isHammerStrike)
                upperBones.CopyTo(justBones, 0);
            else if (isHammerFlight)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);

            world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);



            if (isKnockBack)
                Position = oldPosition + knockBackVec * 5.0f;

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();


            ray = new Ray(new Vector3(Position.X, 90.0f, Position.Z), Direction);


            //  if (resetFormations)
            {
                //    resetFormations = false;

                formation = world;
            }
            // position = new Vector3(-100.0f, 0.0f, 0.0f);



        }
        public void UpdateJSL(GameTime gameTime)
        {

            int shortest = 0;
            float shortDist = Vector3.Distance(ScreenManager.Theseus.CFormation[0], Position);
            for (int i = 0; i < 9; i++)
            {
                if (i != 4)
                {
                    float thisDist = Vector3.Distance(ScreenManager.Theseus.CFormation[i], Position);
                    if (shortDist > thisDist)
                        shortest = i;

                }

            }

            formVec = ScreenManager.Theseus.CFormation[shortest];

            float dTof = Vector3.Distance(position, formVec);
            float rotationAmount = 0.0f;
            rotationAmount = TurnToFace(position, formVec, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            DirToFormation = new Vector3(x, 0.0f, y);

            rotationAmount = TurnToFace(position, ScreenManager.Theseus.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));


            if (state == 1 && dTof < 20)
                state = 0;

            float dToT = Vector3.Distance(position, ScreenManager.Theseus.World.Translation);
            //if(inForm)

            rotationAmount = TurnToFace(position, ScreenManager.Theseus.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));



            //Console.WriteLine(dToT);

            if (health <= 0)
            {
                if (!dead)
                {
                    currentAnimationTime = TimeSpan.Zero;
                    justBones.CopyTo(previousAnimation, 0);
                    isKnockDown = true;
                    dead = true;

                }
                updateKnockDown(gameTime);
            }
            else
            {



                x = (float)Math.Sin(rotationAmount);
                y = (float)Math.Cos(rotationAmount);
                Direction = new Vector3(x, 0.0f, y);

                Up = Vector3.Up;
                Right = Vector3.Cross(Direction, Up);



                if (!active && state == 0)
                    restTimer += gameTime.ElapsedGameTime;

                if (restTimer > TimeSpan.FromSeconds(3.0))
                {
                    restTimer = TimeSpan.FromSeconds(3.0);
                    active = true;
                }
                if (isKnockedBack)
                {
                    isKnockedBack = false;
                    isAtk1 = false;
                    isAtk2 = false;
                    isAtk3 = false;
                    isRun = false;
                    isKnockBack = true;
                    justBones.CopyTo(previousAnimation, 0);
                    currentAnimationTime = TimeSpan.Zero;

                }




                if (dToT < 300.0f)//if it can be seen
                    if (dToT > 80)
                    {
                        //  resetFormation = true;
                        thrustAmount = 1.0f;
                        if (!isRun)
                        {
                            isRun = true;
                            justBones.CopyTo(previousAnimation, 0);
                        }

                    }
                    else
                    {


                        //   resetFormation = false;
                        thrustAmount = 0.0f;
                        runTime = TimeSpan.Zero;
                        isRun = false;

                        if (dToT > 80)
                        {
                            thrustAmount = 1.3f;

                        }
                        else
                        {
                            thrustAmount = 0.0f;

                            if (restTimer > TimeSpan.FromSeconds(.5) & !isAtk1 & !isAtk2 & !isAtk3)
                            {

                                int random = ScreenManager.rand.Next();
                                {
                                    if (random % 3 == 1)
                                    {

                                        active = true;
                                        isAtk1 = true;

                                        justBones.CopyTo(previousAnimation, 0);

                                        openStrike = true;
                                        restTimer = TimeSpan.Zero;
                                    }
                                    if (random % 3 == 2)
                                    {
                                        justBones.CopyTo(previousAnimation, 0);
                                        isAtk2 = true;
                                        isAtk1 = true;
                                    }
                                    if (random % 3 == 0)
                                    {
                                        justBones.CopyTo(previousAnimation, 0);
                                        isAtk3 = true;
                                        isAtk2 = true;
                                        isAtk1 = true;
                                    }

                                }


                                if (!isAtk1)
                                {
                                    isAtk1 = true;
                                    active = true;

                                }
                            }

                        }

                    }
                // Console.WriteLine(restTimer);
            }









            if (isRun)
                updateRun(gameTime);

            if (isAtk1)
                UpdateBasic1(gameTime);
            else if (isAtk2)
                UpdateBasic2(gameTime);
            else if (isAtk3)
                UpdateBasic3(gameTime);

            if (isKnockBack)
                UpdateKnockBack(gameTime);
            if (isKnockDown)
                updateKnockDown(gameTime);

            if (!dead)
            {
                if (state == 1)
                    Position += new Vector3(DirToFormation.X, DirToFormation.Y, DirToFormation.Z) * 2.0f;
                else if (isRun)
                    Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 2.0f;
            }
            //if(isKnockBack)
            //    Position -= new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 2.0f;

            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1 || isAtk2 || isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockDown)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);



            int pX = (int)position.X / 100;
            int pZ = (int)position.Z / 100;

            if (Position.X < 0)
                pX = 0;
            if (Position.Z < 0)
                pZ = 0;
            if (position.X > 12799)
                pX = 127;
            if (position.Z > 12799)
                pZ = 127;
            //Console.WriteLine(
            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;




            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            //if(resetFormation)
            formation = world;





        }
        public void UpdateJAL(GameTime gameTime)
        {
            int shortest = 0;
            float shortDist = Vector3.Distance(ScreenManager.Theseus.CFormation[0], Position);
            for (int i = 0; i < 9; i++)
            {
                if (i != 4)
                {
                    float thisDist = Vector3.Distance(ScreenManager.Theseus.CFormation[i], Position);
                    if (shortDist > thisDist)
                        shortest = i;

                }

            }

            formVec = ScreenManager.Theseus.CFormation[shortest];

            float dTof = Vector3.Distance(position, formVec);
            float rotationAmount = 0.0f;
            rotationAmount = TurnToFace(position, formVec, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            DirToFormation = new Vector3(x, 0.0f, y);

            rotationAmount = TurnToFace(position, ScreenManager.Theseus.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

            foreach (Projectile2 pro in projectiles)
                pro.update2E(gameTime);


            if (state == 1 && dTof < 20)
                state = 0;



            float dToT = Vector3.Distance(position, ScreenManager.Theseus.World.Translation);
            //if(inForm)

            rotationAmount = TurnToFace(position, ScreenManager.Theseus.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));



            //Console.WriteLine(dToT);

            if (health <= 0)
            {
                if (!dead)
                {
                    currentAnimationTime = TimeSpan.Zero;
                    justBones.CopyTo(previousAnimation, 0);
                    isKnockDown = true;
                    dead = true;
                    isAtk1 = isAtk2 = isAtk3 = false;

                }
                updateKnockDown(gameTime);
            }
            else
            {



                x = (float)Math.Sin(rotationAmount);
                y = (float)Math.Cos(rotationAmount);
                Direction = new Vector3(x, 0.0f, y);

                Up = Vector3.Up;
                Right = Vector3.Cross(Direction, Up);



                if (!active && state == 0)
                    restTimer += gameTime.ElapsedGameTime;

                if (restTimer > TimeSpan.FromSeconds(3.0))
                {
                    restTimer = TimeSpan.FromSeconds(3.0);
                    active = true;
                }
                if (isKnockedBack)
                {
                    isKnockedBack = false;
                    isAtk1 = false;
                    isAtk2 = false;
                    isAtk3 = false;
                    isRun = false;
                    isKnockBack = true;
                    justBones.CopyTo(previousAnimation, 0);
                    currentAnimationTime = TimeSpan.Zero;

                }




                if (dToT < 300.0f)//if it can be seen
                    if (dToT > 220.0f)
                    {
                        //  resetFormation = true;
                        thrustAmount = 1.0f;
                        if (!isRun)
                        {
                            isRun = true;
                            justBones.CopyTo(previousAnimation, 0);
                        }

                    }
                    else
                    {


                        //   resetFormation = false;
                        thrustAmount = 0.0f;
                        runTime = TimeSpan.Zero;
                        isRun = false;

                        if (dToT > 190)
                        {
                            thrustAmount = 0.3f;

                        }
                        else
                        {
                            thrustAmount = 0.0f;

                            if (restTimer > TimeSpan.FromSeconds(.5) & !isAtk1 & !isAtk2 & !isAtk3)
                            {

                                int random = ScreenManager.rand.Next();
                                {
                                    if (random % 3 == 1)
                                    {

                                        active = true;
                                        isAtk1 = true;

                                        openStrike = true;
                                        restTimer = TimeSpan.Zero;
                                    }
                                    if (random % 3 == 2)
                                    {
                                        isAtk2 = true;
                                        isAtk1 = true;
                                    }
                                    if (random % 3 == 0)
                                    {
                                        isAtk3 = true;
                                        isAtk2 = true;
                                        isAtk1 = true;
                                    }

                                }


                                if (!isAtk1)
                                {
                                    isAtk1 = true;
                                    active = true;

                                }
                            }

                        }

                    }
                // Console.WriteLine(restTimer);
            }









            if (isRun)
                updateRun(gameTime);

            if (isAtk1)
                UpdateBow(gameTime);
            else if (isAtk2)
                UpdateBasic2(gameTime);
            else if (isAtk3)
                UpdateBasic3(gameTime);

            if (isKnockBack)
                UpdateKnockBack(gameTime);
            if (isKnockDown)
                updateKnockDown(gameTime);

            if (!dead)
            {
                if (state == 1)
                    Position += new Vector3(DirToFormation.X, DirToFormation.Y, DirToFormation.Z) * 2.0f;
                else if (isRun)
                    Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 2.0f;
            }
            //if(isKnockBack)
            //    Position -= new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 2.0f;

            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1 || isAtk2 || isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockDown)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);



            int pX = (int)position.X / 100;
            int pZ = (int)position.Z / 100;

            if (Position.X < 0)
                pX = 0;
            if (Position.Z < 0)
                pZ = 0;
            if (position.X > 12799)
                pX = 127;
            if (position.Z > 12799)
                pZ = 127;
            //Console.WriteLine(
            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;




            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            //if(resetFormation)
            formation = world;





        }
        public void UpdateJSpearL(GameTime gameTime)
        {
            //Console.WriteLine(state);
            {

                for (int i = 0; i < projectiles.Count; i++)
                {
                    projectiles[i].update2E(gameTime);
                    if (!projectiles[i].alive)
                        projectiles.RemoveAt(i);

                }

                float rayDir = TurnToFace(transRayEnd, transRayStart, Vector3.Zero);
                float rx = (float)Math.Sin(rayDir);
                float ry = (float)Math.Cos(rayDir);
                transRayDirection = new Vector3(rx, 0.0f, ry);

                ray = new Ray(transRayStart, transRayDirection);

                int shortest = 0;
                float shortDist = Vector3.Distance(ScreenManager.Theseus.CFormation[0], Position);
                for (int i = 0; i < 9; i++)
                {
                    if (i != 4)
                    {
                        float thisDist = Vector3.Distance(ScreenManager.Theseus.CFormation[i], Position);
                        if (shortDist > thisDist)
                        {
                            shortest = i;
                            shortDist = thisDist;
                        }

                    }

                }

                formVec = ScreenManager.Theseus.CFormation[shortest];


                float dTof = Vector3.Distance(position, formVec);
                float rotationAmount = 0.0f;
                rotationAmount = TurnToFace(position, formVec, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                float x = (float)Math.Sin(rotationAmount);
                float y = (float)Math.Cos(rotationAmount);
                DirToFormation = new Vector3(x, 0.0f, y);

                if (state == 1 && dTof < 20)
                    state = 0;
                float dToT = Vector3.Distance(position, ScreenManager.Theseus.World.Translation);
                //if(inForm)
                rotationAmount = TurnToFace(position, ScreenManager.Theseus.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));


                //Console.WriteLine(dToT);

                if (health <= 0)
                {
                    if (!dead)
                    {
                        currentAnimationTime = TimeSpan.Zero;
                        justBones.CopyTo(previousAnimation, 0);
                        isKnockDown = true;
                        dead = true;
                    }
                    updateKnockDown(gameTime);
                }
                else
                {

                    x = (float)Math.Sin(rotationAmount);
                    y = (float)Math.Cos(rotationAmount);

                    Direction = new Vector3(x, 0.0f, y);

                    Up = Vector3.Up;
                    Right = Vector3.Cross(Direction, Up);

                    if (isKnockedBack)
                    {
                        isKnockedBack = false;
                        isAtk1 = false;
                        isAtk2 = false;
                        isAtk3 = false;
                        isRun = false;
                        isKnockBack = true;
                        justBones.CopyTo(previousAnimation, 0);
                        currentAnimationTime = TimeSpan.Zero;

                    }
                    if (!active)
                        restTimer += gameTime.ElapsedGameTime;


                    if (restTimer > TimeSpan.FromSeconds(3.0) && state == 0)
                    {
                        restTimer = TimeSpan.FromSeconds(3.0);
                        active = true;
                    }


                    //if (!inForm)
                    //{
                    //    if (dTof < 20)
                    //    {
                    //        inForm = true;

                    //    }
                    //    else
                    //    {
                    //        thrustAmount = 1.0f;
                    //        if (!isRun)
                    //        {
                    //            isRun = true;
                    //            justBones.CopyTo(previousAnimation, 0);
                    //        }


                    //    }
                    //}
                    //else
                    {
                        if (dToT < 2000.0f)//if it can be seen
                        {
                            if (dToT > 300)
                            {
                                //  resetFormation = true;
                                int decision = ScreenManager.rand.Next() % 2;
                                if (!isSpearThrow & !advance && decisionTimer > TimeSpan.FromSeconds(1.0))
                                {
                                    decisionTimer = TimeSpan.Zero;
                                    if (decision == 0)
                                    {
                                        thrustAmount = 0.0f;
                                        active = true;
                                        isSpearThrow = true;
                                        justBones.CopyTo(previousAnimation, 0);
                                        openStrike = true;
                                        advanceTimer = TimeSpan.Zero;
                                    }
                                    else
                                    {
                                        advance = true;

                                        thrustAmount = 1.0f;
                                        if (!isRun)
                                        {
                                            isRun = true;
                                            justBones.CopyTo(previousAnimation, 0);
                                        }
                                    }

                                }
                                if (advance)
                                {
                                    advanceTimer += gameTime.ElapsedGameTime;
                                    if (advanceTimer > TimeSpan.FromSeconds(1.0))
                                        advance = false;
                                }
                                if (!isSpearThrow & !advance)
                                {
                                    decisionTimer += gameTime.ElapsedGameTime;

                                }

                            }
                            else if (dToT > 80 )
                            {
                                thrustAmount = 1.0f;
                            }
                            //else if (dTof > 40)
                            //{

                            //    if (dTof > 30)
                            //        thrustAmount = 1.0f;
                            //    else
                            //        inForm = true;




                            //}
                            else
                            {
                                if (advance)
                                    advance = false;

                                //   resetFormation = false;
                                thrustAmount = 0.0f;
                                runTime = TimeSpan.Zero;
                                isRun = false;

                                //if (dToT > 80)
                                //{
                                //    thrustAmount = 0.3f;

                                //}
                                //else
                                {
                                    thrustAmount = 0.0f;

                                    if (active & !isAtk1 & !isAtk2 & !isAtk3 & !isSpearThrow)
                                    {

                                        int random = ScreenManager.rand.Next() % 4;
                                        {
                                            //if (random % 4 == 1 || random%4 == 0)
                                            //{
                                            //    active = true;
                                            //    isSpearThrow = true;
                                            //    justBones.CopyTo(previousAnimation, 0);
                                            //    openStrike = true;
                                            //    restTimer = TimeSpan.Zero;
                                            //}
                                            if (random == 2 || random == 1)
                                            {

                                                active = true;
                                                isAtk1 = true;
                                                justBones.CopyTo(previousAnimation, 0);
                                                openStrike = true;
                                                restTimer = TimeSpan.Zero;
                                            }
                                            if (random == 3)
                                            {
                                                justBones.CopyTo(previousAnimation, 0);
                                                isAtk2 = true;
                                                isAtk1 = true;
                                                restTimer = TimeSpan.Zero;
                                                active = true;
                                            }
                                            if (random == 0)
                                            {
                                                justBones.CopyTo(previousAnimation, 0);
                                                isAtk3 = true;
                                                isAtk2 = true;
                                                isAtk1 = true;
                                                restTimer = TimeSpan.Zero;
                                                active = true;
                                            }

                                        }

                                    }

                                }

                            }
                            //Console.WriteLine(restTimer);
                        }
                    }
                }
               

                if (isRun)
                    updateRun(gameTime);
                if (isHurt)
                    hurtUpdate(gameTime);
                else if (isSpearThrow)
                    updateSpearThrow(gameTime);
                else if (isAtk1)
                    UpdateBasic1(gameTime);
                else if (isAtk2)
                    UpdateBasic2(gameTime);
                else if (isAtk3)
                    UpdateBasic3(gameTime);

                if (isKnockBack)
                    UpdateKnockBack(gameTime);
                if (isKnockDown)
                    updateKnockDown(gameTime);
                //if (thrustAmount > 0.0f)
                    if ((runTime.Seconds > 1.0 && runTime.Seconds < 4.0) || (runTime.Seconds > 4.0 && runTime.Seconds < 7.0))
                        thrustAmount = 1;
                    else
                        thrustAmount = 0;
                if (!dead)
                {
                    if (state == 1)
                        Position += new Vector3(DirToFormation.X, DirToFormation.Y, DirToFormation.Z) * 2.0f;
                    
                    else if (isRun &! isAtk1 &! isAtk2 &! isAtk3)
                        Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 2.0f;
                }
                //if (inForm)
                //    Position = formVec;
                //if(isKnockBack)
                //    Position -= new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 2.0f;

                if (isRun)
                    upperBones.CopyTo(justBones, 0);
                else if (isHurt)
                    upperBones.CopyTo(justBones, 0); 
                else if (isAtk1 || isAtk2 || isAtk3 || isSpearThrow)
                    upperBones.CopyTo(justBones, 0);
                else if (isKnockBack)
                    upperBones.CopyTo(justBones, 0);
                else if (isKnockDown)
                    upperBones.CopyTo(justBones, 0);
                else
                    brace.CopyTo(justBones, 0);



                int pX = (int)position.X / 100;
                int pZ = (int)position.Z / 100;

                if (Position.X < 0)
                    pX = 0;
                if (Position.Z < 0)
                    pZ = 0;
                if (position.X > 12799)
                    pX = 127;
                if (position.Z > 12799)
                    pZ = 127;
                //Console.WriteLine(
                // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
                world = Matrix.Identity;
                world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
                world.Up = Vector3.Up;
                world.Right = Vector3.Cross(world.Forward, world.Up);
                //position.Y = ScreenManager.heightData[pX, pZ];
                world.Translation = Position;




                // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
                UpdateWorldTransforms(Matrix.Identity);
                UpdateSkinTransforms();

                //if(resetFormation)
                formation = world;





            }









        }
        public void UpdateSpear(GameTime gameTime)
        {
            //10 a sec
            //energy += 1;
            //if (energy > 10)
            //    energy = 10;

            oldPosition = Position;
            float dToT = Vector3.Distance(position, ScreenManager.Michael.World.Translation);
            float rotationAmount = 0.0f;
            rotationAmount = TurnToFace(position, ScreenManager.Michael.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

            foreach (Projectile2 pro in projectiles)
                pro.update2E(gameTime);

            decisionTimer += gameTime.ElapsedGameTime;

            if (decisionTimer.TotalMilliseconds > 1500)
            {
                energy++;
                if (energy > 2)
                    energy = 2;

            }

            




            if (dToT < 500.0f)//if it can be seen
            {
                if (dToT > 200.0f)
                {
                    //  resetFormation = true;
                    thrustAmount = 1.0f;
                    if (!isRun)
                    {
                        isRun = true;
                        justBones.CopyTo(previousAnimation, 0);
                    }
                }
                else
                {
                    //   resetFormation = false;
                    thrustAmount = 0.0f;
                    runTime = TimeSpan.Zero;
                    isRun = false;

                    if (dToT > 80)
                    {
                        thrustAmount = 0.3f;

                    }
                    else 
                    {
                        if (energy == 1 &! isSpearThrow &! isSpear)
                        {
                            isSpearThrow = true;

                            justBones.CopyTo(previousAnimation, 0);
                            currentAnimationTime = TimeSpan.Zero;
                        }
                        if (energy == 2 &!isSpearThrow &! isSpear)
                        {

                            isSpear = true;

                            justBones.CopyTo(previousAnimation, 0);
                            currentAnimationTime = TimeSpan.Zero;
                        }
                        //if (!isSpear && energy > 4)
                        //{
                        //    isSpear = true;
                        //   // isSpearThrow = false;

                        //    justBones.CopyTo(previousAnimation, 0);
                        //    currentAnimationTime = TimeSpan.Zero;
                        //    energy -= 4;
                        //}

                    }
                    //else
                    //{
                    //    thrustAmount = 0.0f;
                    //    if (!isSpearThrow && energy < 90)
                    //    {
                    //        isSpearThrow = true;
                    //        justBones.CopyTo(previousAnimation, 0);
                    //        currentAnimationTime = TimeSpan.Zero;
                    //        energy -= 40;

                    //    }
                    //}
 

                }
            }
            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            currentAnimationTime += gameTime.ElapsedGameTime;
            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);

            if (isRun)
            {
                runTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)3.0);
                if (runTime.TotalSeconds < 9.0f)
                {

                    //        if (runTime.TotalSeconds < 1.0f)
                    //        {

                    //            for (int i = 0; i < brace.Length; i++)
                    //            {
                    //                previousAnimation[i].Decompose(out scale, out rota, out trans);
                    //                run1a[i].Decompose(out scale2, out rota2, out trans2);
                    //                upperBones[i] = Matrix.CreateScale(scale2) *
                    //Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
                    //Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                    //            }

                    //        }
                    //        else 
                    if (runTime.TotalSeconds < 1.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun1[i].Decompose(out scale, out rota, out trans);
                            lRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun2[i].Decompose(out scale, out rota, out trans);
                            lRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun3[i].Decompose(out scale, out rota, out trans);
                            lRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun4[i].Decompose(out scale, out rota, out trans);
                            rRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun1[i].Decompose(out scale, out rota, out trans);
                            rRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 5.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 7.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun2[i].Decompose(out scale, out rota, out trans);
                            rRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 6.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 6.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 8.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun3[i].Decompose(out scale, out rota, out trans);
                            rRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 7.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 7.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun4[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 8.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 8.0) / 1.0f));

                        }


                    }

                }
                else
                {

                    runTime = TimeSpan.Zero;
                    lRun1.CopyTo(previousAnimation, 0);



                }

            }
            if (isSpear)
            {

                if (currentAnimationTime.TotalSeconds < 9.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            spear1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spear1[i].Decompose(out scale, out rota, out trans);
                            spear2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 2.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spear2[i].Decompose(out scale, out rota, out trans);
                            spear3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 2.0f));

                        }


                    }

                    else if (currentAnimationTime.TotalSeconds < 5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spear3 [i].Decompose(out scale, out rota, out trans);
                            spearSpin1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spearSpin1[i].Decompose(out scale, out rota, out trans);
                            spearSpin2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 7.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spearSpin2[i].Decompose(out scale, out rota, out trans);
                            spearSpin3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 6.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 6.0) /1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 8.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spearSpin3[i].Decompose(out scale, out rota, out trans);
                            spearSpin4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 7.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 7.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spearSpin4[i].Decompose(out scale, out rota, out trans);
                            spearSpin5[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 8.0) /1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 8.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spearSpin3[i].Decompose(out scale, out rota, out trans);
                            spearSpin4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 8.0) / 9.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 8.0) / 9.0f));

                        }


                    }



                }
                else
                {

                    isSpear = false;
                    energy = 0;
                    currentAnimationTime = TimeSpan.Zero;
                }



            }
            if (isSpearThrow)
            {
                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            spearThrow1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spearThrow1[i].Decompose(out scale, out rota, out trans);
                            spearThrow2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 2.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spearThrow2[i].Decompose(out scale, out rota, out trans);
                            spearThrow3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) /3.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 3.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        //if (arrow1Fired == false)
                        //{
                        //    projectiles.Add(new Projectile2("Spear", arrowWorld, Direction));

                        //    arrow1Fired = true;
                        //}
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spearThrow3[i].Decompose(out scale, out rota, out trans);
                            spearThrow4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 4.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 4.0f));

                        }


                    }

                }
                else 
                {
                   // if (arrow1Fired == false)
                    //{
                        // arrow1Fired = true;
                     //   projectiles.Add(new Projectile2("Spear", arrowWorld, Direction));

                    //}

                    isSpearThrow = false;
                    currentAnimationTime = TimeSpan.Zero;
                    energy = 0; 
                    //EternalStruggle.As.Add(new EternalStruggle.RageHit(TimeSpan.FromSeconds(4)));



                }
            }
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isSpearThrow)
                upperBones.CopyTo(justBones, 0);
            else if (isSpear)
                upperBones.CopyTo(justBones, 0); 

            else
                brace.CopyTo(justBones, 0);

            Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 5.0f;

            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();
            

        }
        public void UpdateParisTS(GameTime gameTime)
        {
            oldPosition = Position;
            float dToT = Vector3.Distance(position, ScreenManager.TheseusTS.World.Translation);
            float rotationAmount = 0.0f;
            rotationAmount = TurnToFace(position, ScreenManager.TheseusTS.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

            foreach (Projectile2 pro in projectiles)
                pro.update2E(gameTime);

            if (!EternalStruggle.TheseusStandRun2)
            {
                if (dToT < 500.0f)//if it can be seen
                    if (dToT > 200.0f)
                    {
                        //  resetFormation = true;
                        thrustAmount = 1.0f;
                        if (!isRun)
                        {
                            isRun = true;
                            justBones.CopyTo(previousAnimation, 0);
                        }
                    }
                    else
                    {
                        //   resetFormation = false;
                        thrustAmount = 0.0f;
                        runTime = TimeSpan.Zero;
                        isRun = false;

                        if (dToT > 190)
                        {
                            thrustAmount = 0.3f;

                        }
                        else
                        {
                            thrustAmount = 0.0f;
                            if (!isBow)
                            {
                                isBow = true;
                                justBones.CopyTo(previousAnimation, 0);
                                currentAnimationTime = TimeSpan.Zero;

                            }
                        }

                    }
                float x = (float)Math.Sin(rotationAmount);
                float y = (float)Math.Cos(rotationAmount);
                 Direction = new Vector3(x, 0.0f, y);

                Up = Vector3.Up;
                Right = Vector3.Cross(Direction, Up);

                //Have to put disqualifiers after all qualifiers

                if (isKnockedBack) //knock back = a lock
                {
                    if (!isKnockBack)
                    {
                        isKnockedBack = false;
                        isKnockBack = true;
                        currentAnimationTime = TimeSpan.Zero;
                        justBones.CopyTo(previousAnimation, 0);
                        isBow = false;
                        isTripleBow = false;
                        isBowSpecial = false;

                    }

                }

                //if (isKnockedDown || isKnockBack) //knockedown represents a lock and knockback is a playback lock
                //{

                //    isBow = false;
                //    isRun = false;
                //    isTripleBow = false;
                //    isBowSpecial = false;
                //    isKnockedBack = false;
                //    thrustAmount = 0.0f;
                //    Direction = oldDirection;


                //}


                if (isRun)
                {
                    runTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)3.0);
                    if (runTime.TotalSeconds < 9.0f)
                    {

                        //        if (runTime.TotalSeconds < 1.0f)
                        //        {

                        //            for (int i = 0; i < brace.Length; i++)
                        //            {
                        //                previousAnimation[i].Decompose(out scale, out rota, out trans);
                        //                run1a[i].Decompose(out scale2, out rota2, out trans2);
                        //                upperBones[i] = Matrix.CreateScale(scale2) *
                        //Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
                        //Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                        //            }

                        //        }
                        //        else 
                        if (runTime.TotalSeconds < 1.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                previousAnimation[i].Decompose(out scale, out rota, out trans);
                                lRun1[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                            }


                        }
                        else if (runTime.TotalSeconds < 2.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                lRun1[i].Decompose(out scale, out rota, out trans);
                                lRun2[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 1.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 1.0) / 1.0f));

                            }


                        }
                        else if (runTime.TotalSeconds < 3.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                lRun2[i].Decompose(out scale, out rota, out trans);
                                lRun3[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 2.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 2.0) / 1.0f));

                            }


                        }
                        else if (runTime.TotalSeconds < 4.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                lRun3[i].Decompose(out scale, out rota, out trans);
                                lRun4[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 3.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 3.0) / 1.0f));

                            }


                        }
                        else if (runTime.TotalSeconds < 5.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                lRun4[i].Decompose(out scale, out rota, out trans);
                                rRun1[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 4.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 4.0) / 1.0f));

                            }


                        }
                        else if (runTime.TotalSeconds < 6.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                rRun1[i].Decompose(out scale, out rota, out trans);
                                rRun2[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 5.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 5.0) / 1.0f));

                            }


                        }
                        else if (runTime.TotalSeconds < 7.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                rRun2[i].Decompose(out scale, out rota, out trans);
                                rRun3[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 6.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 6.0) / 1.0f));

                            }


                        }
                        else if (runTime.TotalSeconds < 8.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                rRun3[i].Decompose(out scale, out rota, out trans);
                                rRun4[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 7.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 7.0) / 1.0f));

                            }


                        }
                        else if (runTime.TotalSeconds < 9.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                rRun4[i].Decompose(out scale, out rota, out trans);
                                lRun1[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 8.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 8.0) / 1.0f));

                            }


                        }

                    }
                    else
                    {

                        runTime = TimeSpan.Zero;
                        lRun1.CopyTo(previousAnimation, 0);



                    }

                }

                currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)8);
                foreach (EternalStruggle.RageHit rageHit in EternalStruggle.As)
                {
                    rageHit.update(gameTime);


                }
                if (isGetUp)
                {
                    if (currentAnimationTime.TotalSeconds < 2.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            brace[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 2.0f));

                        }

                    }
                    else
                    {

                        isGetUp = false;

                    }





                }

                if (isKnockBack)
                {

                    if (currentAnimationTime.TotalSeconds < 4.0f)
                    {

                        if (currentAnimationTime.TotalSeconds < 1.0f)
                        {

                            for (int i = 0; i < brace.Length; i++)
                            {
                                previousAnimation[i].Decompose(out scale, out rota, out trans);
                                kb1[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                            }

                        }
                        else if (currentAnimationTime.TotalSeconds < 2.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                kb1[i].Decompose(out scale, out rota, out trans);
                                kb2[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                            }


                        }
                        else if (currentAnimationTime.TotalSeconds < 3.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                kb2[i].Decompose(out scale, out rota, out trans);
                                kb3[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                            }


                        }
                        else if (currentAnimationTime.TotalSeconds < 4.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                kb3[i].Decompose(out scale, out rota, out trans);
                                knockDown[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                            }


                        }

                    }
                    else
                    {
                        currentAnimationTime = TimeSpan.Zero;
                        isKnockBack = false;
                        isKnockedBack = false;
                        isKnockedDown = true;
                    }












                }


                if (isBowSpecial)
                {


                    if (currentAnimationTime.TotalSeconds < 4.0f)
                    {

                        if (currentAnimationTime.TotalSeconds < 1.0f)
                        {

                            for (int i = 0; i < brace.Length; i++)
                            {
                                previousAnimation[i].Decompose(out scale, out rota, out trans);
                                bow2[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                            }

                        }
                        else if (currentAnimationTime.TotalSeconds < 2.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                bow2[i].Decompose(out scale, out rota, out trans);
                                bow3[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                            }


                        }
                        else if (currentAnimationTime.TotalSeconds < 4.0f)
                        {
                            if (arrow1Fired == false)
                                projectiles.Add(new Projectile2("Arrow", arrowWorld, Direction));
                            for (int i = 0; i < brace.Length; i++)
                            {
                                bow3[i].Decompose(out scale, out rota, out trans);
                                bow3FollowThru[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 2.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 2.0f));

                            }


                        }

                    }
                    else
                    {
                        currentAnimationTime = TimeSpan.Zero;
                        isBowSpecial = false;
                    }

                }
                if (isBow)
                {
                    if (currentAnimationTime.TotalSeconds < 4.0f)
                    {

                        if (currentAnimationTime.TotalSeconds < 2.0f)
                        {

                            for (int i = 0; i < brace.Length; i++)
                            {
                                previousAnimation[i].Decompose(out scale, out rota, out trans);
                                bow2[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 2.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 2.0f));

                            }

                        }
                        else if (currentAnimationTime.TotalSeconds < 4.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                bow2[i].Decompose(out scale, out rota, out trans);
                                bow3[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 4.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 4.0f));

                            }


                        }

                    }
                    else if (!isTripleBow)
                    {
                        if (arrow1Fired == false)
                        {
                           // arrow1Fired = true;
                            projectiles.Add(new Projectile2("Arrow", arrowWorld, Direction));

                        }

                        isBow = false;
                        currentAnimationTime = TimeSpan.Zero;
                        EternalStruggle.As.Add(new EternalStruggle.RageHit(TimeSpan.FromSeconds(4)));



                    }

                    else if (currentAnimationTime.TotalSeconds < 5.0f)
                    {
                        if (arrow1Fired == false)
                        {
                            arrow1Fired = true;
                            projectiles.Add(new Projectile2("Arrow", arrowWorld, Direction));

                        }
                        for (int i = 0; i < brace.Length; i++)
                        {
                            bow3[i].Decompose(out scale, out rota, out trans);
                            bow2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            bow2[i].Decompose(out scale, out rota, out trans);
                            bow3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 7.0f)
                    {
                        if (arrow2Fired == false)
                        {
                            arrow2Fired = true;
                            projectiles.Add(new Projectile2("Arrow", arrowWorld, Direction));

                        }
                        for (int i = 0; i < brace.Length; i++)
                        {
                            bow3[i].Decompose(out scale, out rota, out trans);
                            bow2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 6.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 6.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            bow2[i].Decompose(out scale, out rota, out trans);
                            bow3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 7.0) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 7.0) / 2.0f));

                        }


                    }

                    else
                    {
                        if (arrow3Fired == false)
                        {
                            arrow3Fired = true;
                            projectiles.Add(new Projectile2("Arrow", arrowWorld, Direction));

                        }
                        currentAnimationTime = TimeSpan.Zero;
                        isBow = false;
                        isTripleBow = false;

                    }


                }




                //world = Matrix.Identity;
                //world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
                //world.Up = Up;
                //world.Right = Right;
                //world.Translation = Position + new Vector3(0.0f, 0.0f, 0.0f);


                //if (isAtk1)
                // upperBones.CopyTo(justBones, 0);
                //else

                // world = Matrix.Identity;
            }
            Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 5.0f;

            if (isKnockBack)
                Position = oldPosition- Direction * 1.2f;
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isBowSpecial)
                upperBones.CopyTo(justBones, 0);
            else if (isBow)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockedDown)
                knockDown.CopyTo(justBones, 0);
            else if (isGetUp)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);

            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();



            //  if (resetFormations)
            {
                //    resetFormations = false;

                formation = world;
            }
            // position = new Vector3(-100.0f, 0.0f, 0.0f);



        }
        public void UpdateParis(GameTime gameTime)
        {


            float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds;
            oldGamePadState = currentGamePadState;
            oldkeyBoardState = currentKeyBoardState;
            World.Decompose(out scale, out rota, out trans);
            oldPosition = Position;
            oldDirection = Direction;
            currentGamePadState = GamePad.GetState(PlayerIndex.One);

            foreach (Projectile2 pro in projectiles)
                pro.update2(gameTime);


            Vector2 rotationAmount = currentGamePadState.ThumbSticks.Left;

            Vector2 inputAmount = currentGamePadState.ThumbSticks.Right;

            //rotAmt = TurnToFace(ScreenManager.asterion.Position, ScreenManager.medusa.Position, Vector3.Zero);
            // Direction = new Vector3((float)Math.Sin(rotAmt), 0.0f, (float)Math.Cos(rotAmt));

            if (gameTime.TotalGameTime - playerMoveTime > MoveTimeOut)
            {
                playerMove = null;
            }
            //inputManager.Update(gameTime);
            Move newMove = ScreenManager.moveList.DetectMove(ScreenManager.inputManager);

            if (newMove != null)
            {
                playerMove = newMove;

                playerMoveTime = gameTime.TotalGameTime;

                if (playerMove.Name == "RS")
                {
                    projectiles.Add(new Projectile2("Fire", forwardSpell, Direction));

                }
                if (playerMove.Name == "LT")
                {
                    testingIndex++;
                    if (testingIndex > 2)
                        testingIndex = 0;

                }
                if (playerMove.Name == "RT")
                {
                    if (!isKnockBack)
                    {
                        isKnockBack = true;
                        currentAnimationTime = TimeSpan.Zero;
                        justBones.CopyTo(previousAnimation, 0);
                    }

                }
                if (playerMove.Name == "LS")
                {


                }



                if (playerMove.Name == "A")
                {
                    if (isKnockedDown)
                    {
                        isGetUp = true;
                        isKnockedDown = false;
                        currentAnimationTime = TimeSpan.Zero;


                    }

                    else if (!isBow)
                    {
                        isBow = true;
                        currentAnimationTime = TimeSpan.Zero;
                        justBones.CopyTo(previousAnimation, 0);

                        arrow1Fired = false;

                        //ScreenManager.spears[0].state = 1;
                        //need to set attack
                    }

                }
                if (playerMove.Name == "AA")
                {
                    //if (!isAtk1 && !isAtk2)

                    if (!isTripleBow)
                    {
                        
                        arrow2Fired = false;
                        arrow3Fired = false;

                        isTripleBow = true;
                        //currentAnimationTime = TimeSpan.Zero;
                        //justBones.CopyTo(previousAnimation, 0);

                        if (!isBow)
                        {
                            currentAnimationTime = TimeSpan.Zero;
                            arrow1Fired = false;
                        }


                    }


                }

                if (playerMove.Name == "X")
                {
                    if (!isBowSpecial)
                    {
                        isBowSpecial = true;
                        currentAnimationTime = TimeSpan.Zero;
                        arrow1Fired = false;
                    }
                    justBones.CopyTo(previousAnimation, 0);




                }
                Console.WriteLine(playerMove.Name);



            }


            //if (Math.Abs(rotationAmount.X) > .3f || Math.Abs(rotationAmount.Y) > .3f)
            {
                //Direction = new Vector3(rotationAmount.X, 0.0f, rotationAmount.Y);



                if ((rotationAmount.X) > .3f)
                {

                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, -.03f));
                }
                if ((rotationAmount.X) < -.3f)
                {
                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, .03f));

                }
                thrustAmount = -currentGamePadState.ThumbSticks.Left.Y;

                if (thrustAmount > 1)
                    thrustAmount = 1.0f;
                if (thrustAmount < -1)
                    thrustAmount = -1.0f;



                if (Math.Abs(thrustAmount) > 0.0f)
                {
                    isRun = true;
                    justBones.CopyTo(previousAnimation, 0);
                }
                else
                {
                    isRun = false;
                    runTime = TimeSpan.Zero;
                }
                //  else
                //  thrustAmount = rotationAmount.Y;
            }
            //else
            //    thrustAmount = 0.0f;


            Up.Normalize();
            Direction.Normalize();


            Right = Vector3.Cross(Direction, Up);

            //Have to put disqualifiers after all qualifiers

            if (isKnockedBack) //knock back = a lock
            {
                if (!isKnockBack)
                {
                    isKnockBack = true;
                    currentAnimationTime = TimeSpan.Zero;
                    justBones.CopyTo(previousAnimation, 0);
                    isBow = false;
                    isTripleBow = false;
                    isBowSpecial = false;
                    
                }

            }

            if (isKnockedDown || isKnockBack) //knockedown represents a lock and knockback is a playback lock
            {

                isBow = false;
                isRun = false;
                isTripleBow = false;
                isBowSpecial = false;
                isKnockedBack = false;
                thrustAmount = 0.0f;
                Direction = oldDirection;


            }

           
                if (isRun)
                {
                    runTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)3.0);
                    if (runTime.TotalSeconds < 9.0f)
                    {

                        //        if (runTime.TotalSeconds < 1.0f)
                        //        {

                        //            for (int i = 0; i < brace.Length; i++)
                        //            {
                        //                previousAnimation[i].Decompose(out scale, out rota, out trans);
                        //                run1a[i].Decompose(out scale2, out rota2, out trans2);
                        //                upperBones[i] = Matrix.CreateScale(scale2) *
                        //Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
                        //Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                        //            }

                        //        }
                        //        else 
                        if (runTime.TotalSeconds < 1.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                previousAnimation[i].Decompose(out scale, out rota, out trans);
                                lRun1[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                            }


                        }
                        else if (runTime.TotalSeconds < 2.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                lRun1[i].Decompose(out scale, out rota, out trans);
                                lRun2[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 1.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 1.0) / 1.0f));

                            }


                        }
                        else if (runTime.TotalSeconds < 3.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                lRun2[i].Decompose(out scale, out rota, out trans);
                                lRun3[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 2.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 2.0) / 1.0f));

                            }


                        }
                        else if (runTime.TotalSeconds < 4.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                lRun3[i].Decompose(out scale, out rota, out trans);
                                lRun4[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 3.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 3.0) / 1.0f));

                            }


                        }
                        else if (runTime.TotalSeconds < 5.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                lRun4[i].Decompose(out scale, out rota, out trans);
                                rRun1[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 4.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 4.0) / 1.0f));

                            }


                        }
                        else if (runTime.TotalSeconds < 6.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                rRun1[i].Decompose(out scale, out rota, out trans);
                                rRun2[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 5.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 5.0) / 1.0f));

                            }


                        }
                        else if (runTime.TotalSeconds < 7.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                rRun2[i].Decompose(out scale, out rota, out trans);
                                rRun3[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 6.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 6.0) / 1.0f));

                            }


                        }
                        else if (runTime.TotalSeconds < 8.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                rRun3[i].Decompose(out scale, out rota, out trans);
                                rRun4[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 7.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 7.0) / 1.0f));

                            }


                        }
                        else if (runTime.TotalSeconds < 9.0f)
                        {
                            for (int i = 0; i < brace.Length; i++)
                            {
                                rRun4[i].Decompose(out scale, out rota, out trans);
                                lRun1[i].Decompose(out scale2, out rota2, out trans2);
                                upperBones[i] = Matrix.CreateScale(scale2) *
                Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 8.0) / 1.0f)) *
                Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 8.0) / 1.0f));

                            }


                        }

                    }
                    else
                    {

                        runTime = TimeSpan.Zero;
                        lRun1.CopyTo(previousAnimation, 0);



                    }

                }
            
            currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)8);

            if (isGetUp)
            {
                if (currentAnimationTime.TotalSeconds < 2.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        previousAnimation[i].Decompose(out scale, out rota, out trans);
                        brace[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 2.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 2.0f));

                    }

                }
                else
                {

                    isGetUp = false;

                }





            }
            if (isKnockBack)
            {

                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            kb1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb1[i].Decompose(out scale, out rota, out trans);
                            kb2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb2[i].Decompose(out scale, out rota, out trans);
                            kb3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb3[i].Decompose(out scale, out rota, out trans);
                            knockDown[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }

                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isKnockBack = false;
                    isKnockedBack = false;
                    isKnockedDown = true;
                }












            }


            if (isBowSpecial)
            {


                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            bow2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            bow2[i].Decompose(out scale, out rota, out trans);
                            bow3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        if (arrow1Fired == false)
                            projectiles.Add(new Projectile2("Arrow", arrowWorld, Direction));
                        for (int i = 0; i < brace.Length; i++)
                        {
                            bow3[i].Decompose(out scale, out rota, out trans);
                            bow3FollowThru[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 2.0f));

                        }


                    }
                 
                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isBowSpecial = false;
                }

            }
            if (isBow)
            {
                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 2.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            bow2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 2.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            bow2[i].Decompose(out scale, out rota, out trans);
                            bow3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 4.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 4.0f));

                        }


                    }

                }
                else if (!isTripleBow)
                {
                    if (arrow1Fired == false)
                    {
                        arrow1Fired = true;
                        projectiles.Add(new Projectile2("Arrow", arrowWorld, Direction));

                    }

                    isBow = false;
                    currentAnimationTime = TimeSpan.Zero;



                }

                else if (currentAnimationTime.TotalSeconds < 5.0f)
                {
                    if (arrow1Fired == false)
                    {
                        arrow1Fired = true;
                        projectiles.Add(new Projectile2("Arrow", arrowWorld, Direction));

                    }
                    for (int i = 0; i < brace.Length; i++)
                    {
                        bow3[i].Decompose(out scale, out rota, out trans);
                        bow2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 6.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        bow2[i].Decompose(out scale, out rota, out trans);
                        bow3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 7.0f)
                {
                    if (arrow2Fired == false)
                    {
                        arrow2Fired = true;
                        projectiles.Add(new Projectile2("Arrow", arrowWorld, Direction));

                    }
                    for (int i = 0; i < brace.Length; i++)
                    {
                        bow3[i].Decompose(out scale, out rota, out trans);
                        bow2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 6.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 6.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 9.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        bow2[i].Decompose(out scale, out rota, out trans);
                        bow3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 7.0) / 2.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 7.0) / 2.0f));

                    }


                }

                else
                {
                    if (arrow3Fired == false)
                    {
                        arrow3Fired = true;
                        projectiles.Add(new Projectile2("Arrow", arrowWorld, Direction));

                    }
                    currentAnimationTime = TimeSpan.Zero;
                    isBow = false;
                    isTripleBow = false;
                    
                }


            }




            //world = Matrix.Identity;
            //world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            //world.Up = Up;
            //world.Right = Right;
            //world.Translation = Position + new Vector3(0.0f, 0.0f, 0.0f);


            //if (isAtk1)
            // upperBones.CopyTo(justBones, 0);
            //else

            // world = Matrix.Identity;

            Position += Direction * thrustAmount * 5.0f;

            if (isKnockBack)
                Position = oldPosition + knockBackVec * 1.2f;
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isBowSpecial)
                upperBones.CopyTo(justBones, 0);
            else if (isBow)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockedDown)
                knockDown.CopyTo(justBones, 0);
            else if (isGetUp)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);

            world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();



            //  if (resetFormations)
            {
                //    resetFormations = false;

                formation = world;
            }
            // position = new Vector3(-100.0f, 0.0f, 0.0f);



        }
        public void UpdateThorAgainstHercules(GameTime gameTime)
        {

            foreach (Projectile2 proj in projectiles)
                proj.update2E(gameTime);
            oldPosition = Position;

            float dToT = Vector3.Distance(Position, ScreenManager.HercTVH.World.Translation);
            float rotationAmount = 0.0f;
            rotationAmount = TurnToFace(position, ScreenManager.HercTVH.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
            if (isKnockedBack)
            {
                isKnockedBack = false;
                isKnockBack = true;
                justBones.CopyTo(previousAnimation, 0);
                currentAnimationTime = TimeSpan.Zero;
                isHammerStrike = false;


            }

            if (!isKnockBack)
            {
                if (dToT < 300.0f)
                {
                    if (dToT > 200.0f)
                    {
                        //  resetFormation = true;
                        thrustAmount = 1.0f;
                        if (!isRun)
                        {
                            isRun = true;
                            justBones.CopyTo(previousAnimation, 0);
                        }
                    }
                    else
                    {
                        //   resetFormation = false;
                        thrustAmount = 0.0f;
                        runTime = TimeSpan.Zero;
                        isRun = false;

                        if (dToT > 80)
                        {
                            thrustAmount = 0.3f;

                        }
                        else
                        {
                            thrustAmount = 0.0f;
                            if (!isHammerStrike && EternalStruggle.rageBlocks < 2)
                            {
                                EternalStruggle.LSs.Add(new EternalStruggle.RageHit(TimeSpan.FromSeconds(3.0)));
                                isHammerStrike = true;
                                currentAnimationTime = TimeSpan.Zero;
                                justBones.CopyTo(previousAnimation, 0);

                            }
                            else if (!isHammerStrike && EternalStruggle.rageBlocks >= 2)
                            {
                                EternalStruggle.LSs.Add(new EternalStruggle.RageHit(TimeSpan.FromSeconds(1.0)));
                                isHammerStrike = true;
                                isDoubleStrike = true;
                                justBones.CopyTo(previousAnimation, 0);



                            }
                        }

                    }
                }
                else //if greater than 300 fly back
                {

                    if (!isHammerFlight)
                    {
                        isHammerFlight = true;
                        currentAnimationTime = TimeSpan.Zero;
                        justBones.CopyTo(previousAnimation, 0);
                    }




                }
            }
            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);

            if (isRun)
            {
                runTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)3.0);
                if (runTime.TotalSeconds < 9.0f)
                {
                    if (runTime.TotalSeconds < 1.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun1[i].Decompose(out scale, out rota, out trans);
                            lRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun2[i].Decompose(out scale, out rota, out trans);
                            lRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun3[i].Decompose(out scale, out rota, out trans);
                            lRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun4[i].Decompose(out scale, out rota, out trans);
                            rRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun1[i].Decompose(out scale, out rota, out trans);
                            rRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 5.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 7.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun2[i].Decompose(out scale, out rota, out trans);
                            rRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 6.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 6.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 8.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun3[i].Decompose(out scale, out rota, out trans);
                            rRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 7.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 7.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun4[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 8.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 8.0) / 1.0f));

                        }


                    }

                }
                else
                {

                    runTime = TimeSpan.Zero;
                    lRun1.CopyTo(previousAnimation, 0);



                }

            }


            currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)3);
            foreach (EternalStruggle.RageHit rageHit in EternalStruggle.LSs)
                rageHit.update(gameTime );

            if (isHammerStrike)
            {
                if (currentAnimationTime.TotalSeconds < 3.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            hammerToss1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            hammerToss1[i].Decompose(out scale, out rota, out trans);
                            hammerToss2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        if (!arrow1Fired)
                        {
                            projectiles.Add(new Projectile2("Mjolnir", arrowWorld, Direction));
                            arrow1Fired = true;
                        }
                        for (int i = 0; i < brace.Length; i++)
                        {
                            hammerToss2[i].Decompose(out scale, out rota, out trans);
                            hammerToss3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }

                }
                else if (!isDoubleStrike)
                {
                    arrow1Fired = false;
                    isHammerStrike = false;
                    currentAnimationTime = TimeSpan.Zero;



                }

                else if (currentAnimationTime.TotalSeconds < 4.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        hammerStrike3[i].Decompose(out scale, out rota, out trans);
                        hammerStrike1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 5.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        hammerStrike1[i].Decompose(out scale, out rota, out trans);
                        hammerStrike2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                    }


                }

                else if (currentAnimationTime.TotalSeconds < 6.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        hammerStrike2[i].Decompose(out scale, out rota, out trans);
                        hammerStrike3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                    }


                }



                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isHammerStrike = false;
                    isDoubleStrike = false;
                    //lightningSuccess = true;

                    ScreenManager.HercTVH.lightninged = true;
                    ScreenManager.HercTVH.lightningTimer = TimeSpan.Zero;
                    ScreenManager.HercTVH.justBones.CopyTo(previousAnimation, 0);
                }


            }

           // currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)2);

            if (isKnockBack)
            {

                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            kb1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb1[i].Decompose(out scale, out rota, out trans);
                            kb2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb2[i].Decompose(out scale, out rota, out trans);
                            kb3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb3[i].Decompose(out scale, out rota, out trans);
                            knockDown[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }

                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isKnockBack = false;
                    isKnockedBack = false;
                    if (blocked)
                    {
                        blocked = false;
                    }
                    else
                    {
                        EternalStruggle.HercFinishThor = true;

                    }
 
                }

                            }


       
            Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 2.0f;

            if (EternalStruggle.HercFinishThor)
                knockDown.CopyTo(justBones, 0);
            else if (isKnockBack &! blocked)
                Position = oldPosition -Direction *2.0f;
            else if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isHammerStrike)
                upperBones.CopyTo(justBones, 0);
            else if (isHammerFlight)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;

            
            {
                UpdateWorldTransforms(Matrix.Identity);
                UpdateSkinTransforms();
            }
            
            //if(resetFormation)
            formation = world;




        }
        public void UpdateThor(GameTime gameTime)
        {


            float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds;
            oldGamePadState = currentGamePadState;
            oldkeyBoardState = currentKeyBoardState;
            World.Decompose(out scale, out rota, out trans);
            oldPosition = Position;
            oldDirection = Direction;
            currentGamePadState = GamePad.GetState(PlayerIndex.One);

            foreach (Projectile2 pro in projectiles)
                pro.update2(gameTime);


            Vector2 rotationAmount = currentGamePadState.ThumbSticks.Left;

            Vector2 inputAmount = currentGamePadState.ThumbSticks.Right;

            //rotAmt = TurnToFace(ScreenManager.asterion.Position, ScreenManager.medusa.Position, Vector3.Zero);
            // Direction = new Vector3((float)Math.Sin(rotAmt), 0.0f, (float)Math.Cos(rotAmt));

            if (gameTime.TotalGameTime - playerMoveTime > MoveTimeOut)
            {
                playerMove = null;
            }
            //inputManager.Update(gameTime);
            Move newMove = ScreenManager.moveList.DetectMove(ScreenManager.inputManager);
            if(!isKnockBack)

            if (newMove != null)
            {
                playerMove = newMove;

                playerMoveTime = gameTime.TotalGameTime;

                if (playerMove.Name == "RS")
                {
                    projectiles.Add(new Projectile2("Fire", forwardSpell, Direction));

                }
                if (playerMove.Name == "LT")
                {
                    testingIndex++;
                    if (testingIndex > 2)
                        testingIndex = 0;

                }
                if (playerMove.Name == "RT")
                {

                }
                if (playerMove.Name == "LS")
                {


                }



                if (playerMove.Name == "A")
                {

                    if (!isHammerStrike)
                    {
                        isHammerStrike = true;
                        currentAnimationTime = TimeSpan.Zero;
                        justBones.CopyTo(previousAnimation, 0);

                        //ScreenManager.spears[0].state = 1;
                        //need to set attack
                    }

                }
                if (playerMove.Name == "AA")
                {
                    //if (!isAtk1 && !isAtk2)

                    if (!isDoubleStrike)
                    {

                        isDoubleStrike = true;
                        //currentAnimationTime = TimeSpan.Zero;
                        //justBones.CopyTo(previousAnimation, 0);

                        if (!isHammerStrike)
                            currentAnimationTime = TimeSpan.Zero;


                    }


                }

                if (playerMove.Name == "X")
                {
                    if (!isHammerFlight)
                    {
                        isHammerFlight = true;
                        currentAnimationTime = TimeSpan.Zero;
                    }
                    justBones.CopyTo(previousAnimation, 0);




                }
                Console.WriteLine(playerMove.Name);

            }

            if (isKnockedBack)
            {
                if (!isKnockBack)
                {
                    isKnockBack = true;
                    currentAnimationTime = TimeSpan.Zero;
                    justBones.CopyTo(previousAnimation, 0);

                    isHammerFlight = false;
                    isHammerStrike = false;
                    isDoubleStrike = false;
                    isHammerToss = false;
                }

            }


            //if (Math.Abs(rotationAmount.X) > .3f || Math.Abs(rotationAmount.Y) > .3f)
            {
                //Direction = new Vector3(rotationAmount.X, 0.0f, rotationAmount.Y);



                if ((rotationAmount.X) > .3f)
                {

                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, -.03f));
                }
                if ((rotationAmount.X) < -.3f)
                {
                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, .03f));

                }
                thrustAmount = -currentGamePadState.ThumbSticks.Left.Y;

                if (thrustAmount > 1)
                    thrustAmount = 1.0f;
                if (thrustAmount < -1)
                    thrustAmount = -1.0f;



                if (Math.Abs(thrustAmount) > 0.0f)
                {
                    isRun = true;
                    justBones.CopyTo(previousAnimation, 0);
                }
                else
                {
                    isRun = false;
                    runTime = TimeSpan.Zero;
                }
                //  else
                //  thrustAmount = rotationAmount.Y;
            }
            //else
            //    thrustAmount = 0.0f;

            Up.Normalize();
            Direction.Normalize();




            Right = Vector3.Cross(Direction, Up);
            if (isRun)
            {
                runTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)3.0);
                if (runTime.TotalSeconds < 9.0f)
                {

                    //        if (runTime.TotalSeconds < 1.0f)
                    //        {

                    //            for (int i = 0; i < brace.Length; i++)
                    //            {
                    //                previousAnimation[i].Decompose(out scale, out rota, out trans);
                    //                run1a[i].Decompose(out scale2, out rota2, out trans2);
                    //                upperBones[i] = Matrix.CreateScale(scale2) *
                    //Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
                    //Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                    //            }

                    //        }
                    //        else 
                    if (runTime.TotalSeconds < 1.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun1[i].Decompose(out scale, out rota, out trans);
                            lRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun2[i].Decompose(out scale, out rota, out trans);
                            lRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun3[i].Decompose(out scale, out rota, out trans);
                            lRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun4[i].Decompose(out scale, out rota, out trans);
                            rRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun1[i].Decompose(out scale, out rota, out trans);
                            rRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 5.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 7.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun2[i].Decompose(out scale, out rota, out trans);
                            rRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 6.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 6.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 8.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun3[i].Decompose(out scale, out rota, out trans);
                            rRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 7.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 7.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun4[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 8.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 8.0) / 1.0f));

                        }


                    }

                }
                else
                {

                    runTime = TimeSpan.Zero;
                    lRun1.CopyTo(previousAnimation, 0);



                }

            }
            currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)2);

            if (isKnockBack)
            {

                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            kb1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb1[i].Decompose(out scale, out rota, out trans);
                            kb2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb2[i].Decompose(out scale, out rota, out trans);
                            kb3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb3[i].Decompose(out scale, out rota, out trans);
                            knockDown[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }

                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isKnockBack = false;
                    isKnockedBack = false;
                }












            }

            if (isHammerFlight)
            {


                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 2.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            hammerFlight1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 2.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            hammerFlight1[i].Decompose(out scale, out rota, out trans);
                            hammerFlight2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 2.0f));

                        }


                    }
                    else
                    {
                        currentAnimationTime = TimeSpan.Zero;
                        isHammerFlight = false;
                    }

                }
                    else
                    {
                        currentAnimationTime = TimeSpan.Zero;
                        isHammerFlight = false;
                    }

                
            }
            if (isHammerStrike)
            {
                if (currentAnimationTime.TotalSeconds < 3.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            hammerStrike1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            hammerStrike1[i].Decompose(out scale, out rota, out trans);
                            hammerStrike2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                                        else if (currentAnimationTime.TotalSeconds <3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            hammerStrike2[i].Decompose(out scale, out rota, out trans);
                            hammerStrike3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }

                }
                else if (!isDoubleStrike)
                {

                    isHammerStrike = false;
                    currentAnimationTime = TimeSpan.Zero;



                }

                else if (currentAnimationTime.TotalSeconds < 4.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        hammerStrike3[i].Decompose(out scale, out rota, out trans);
                        hammerStrike1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 5.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        hammerStrike1[i].Decompose(out scale, out rota, out trans);
                        hammerStrike2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                    }


                }
                                    
                else if (currentAnimationTime.TotalSeconds < 6.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        hammerStrike2[i].Decompose(out scale, out rota, out trans);
                        hammerStrike3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                    }


                }



                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isHammerStrike = false;
                    isDoubleStrike = false;

                }


            }




            //world = Matrix.Identity;
            //world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            //world.Up = Up;
            //world.Right = Right;
            //world.Translation = Position + new Vector3(0.0f, 0.0f, 0.0f);


            //if (isAtk1)
            // upperBones.CopyTo(justBones, 0);
            //else

            // world = Matrix.Identity;

            Position += Direction * thrustAmount * 5.0f;
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isHammerStrike)
                upperBones.CopyTo(justBones, 0);
            else if (isHammerFlight)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);

            world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);



            if (isKnockBack)
                Position = oldPosition + knockBackVec * 5.0f;

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();



            //  if (resetFormations)
            {
                //    resetFormations = false;

                formation = world;
            }
            // position = new Vector3(-100.0f, 0.0f, 0.0f);



        }
        public void UpdateUndead2(GameTime gameTime)
        {

            float dToT = Vector3.Distance(position, ScreenManager.AchillesRage1.World.Translation);
            float rotationAmount = 0.0f;
            rotationAmount = TurnToFace(position, ScreenManager.AchillesRage1.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
            if (dToT < 300.0f)//if it can be seen
                if (dToT > 200.0f)
                {
                    //  resetFormation = true;
                    thrustAmount = 1.0f;
                    if (!isRun)
                    {
                        isRun = true;
                        justBones.CopyTo(previousAnimation, 0);
                    }
                }
                else
                {
                    //   resetFormation = false;
                    thrustAmount = 0.0f;
                    runTime = TimeSpan.Zero;
                    isRun = false;

                    if (dToT > 80)
                    {
                        thrustAmount = 0.3f;

                    }
                    else
                    {
                        thrustAmount = 0.0f;

                        if (!isAtk1)
                        {
                            EternalStruggle.Xs.Add(new EternalStruggle.RageHit(TimeSpan.FromSeconds(4.0)));
                            isAtk1 = true;
                            justBones.CopyTo(previousAnimation, 0);
                            currentAnimationTime = TimeSpan.Zero;
                        }
                    }

                }

            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);

            if (isRun)
            {
                runTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)3.0);
                if (runTime.TotalSeconds < 9.0f)
                {
                    if (runTime.TotalSeconds < 1.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun1[i].Decompose(out scale, out rota, out trans);
                            lRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun2[i].Decompose(out scale, out rota, out trans);
                            lRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun3[i].Decompose(out scale, out rota, out trans);
                            lRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun4[i].Decompose(out scale, out rota, out trans);
                            rRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun1[i].Decompose(out scale, out rota, out trans);
                            rRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 5.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 7.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun2[i].Decompose(out scale, out rota, out trans);
                            rRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 6.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 6.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 8.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun3[i].Decompose(out scale, out rota, out trans);
                            rRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 7.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 7.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun4[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 8.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 8.0) / 1.0f));

                        }


                    }

                }
                else
                {

                    runTime = TimeSpan.Zero;
                    lRun1.CopyTo(previousAnimation, 0);



                }

            }

            currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks);
            foreach (EternalStruggle.RageHit rageHit in EternalStruggle.Xs)
                rageHit.update(gameTime);

            if (isAtk3)
            {


                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            atk3a[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk3a[i].Decompose(out scale, out rota, out trans);
                            atk3b[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk3b[i].Decompose(out scale, out rota, out trans);
                            atk3c[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk3c[i].Decompose(out scale, out rota, out trans);
                            atk3b[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }




                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isAtk3 = false;
                }

            }
            if (isAtk1)
            {
                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            atk1a[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk1a[i].Decompose(out scale, out rota, out trans);
                            atk1b[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk1b[i].Decompose(out scale, out rota, out trans);
                            atk1c[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk1c[i].Decompose(out scale, out rota, out trans);
                            atk1d[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }




                }
                else if (!isDoubleStrike)
                {

                    isAtk1 = false;
                    currentAnimationTime = TimeSpan.Zero;



                }

                else if (currentAnimationTime.TotalSeconds < 5.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk1d[i].Decompose(out scale, out rota, out trans);
                        atk2a[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 6.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk2a[i].Decompose(out scale, out rota, out trans);
                        atk2b[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                    }


                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isAtk1 = false;
                    isDoubleStrike = false;

                }


            }

            Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 2.0f;
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);



            int pX = (int)position.X / 100;
            int pZ = (int)position.Z / 100;

            if (Position.X < 0)
                pX = 0;
            if (Position.Z < 0)
                pZ = 0;
            if (position.X > 12799)
                pX = 127;
            if (position.Z > 12799)
                pZ = 127;
            //Console.WriteLine(
            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;




            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            //if(resetFormation)
            formation = world;



        }
        public void UpdateUndead3(GameTime gameTime)
        {

            float dToT = Vector3.Distance(position, ScreenManager.AchillesRage1.World.Translation);
            float rotationAmount = 0.0f;
            rotationAmount = TurnToFace(position, ScreenManager.AchillesRage1.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
            if (dToT < 300.0f)//if it can be seen
                if (dToT > 200.0f)
                {
                    //  resetFormation = true;
                    thrustAmount = 1.0f;
                    if (!isRun)
                    {
                        isRun = true;
                        justBones.CopyTo(previousAnimation, 0);
                    }
                }
                else
                {
                    //   resetFormation = false;
                    thrustAmount = 0.0f;
                    runTime = TimeSpan.Zero;
                    isRun = false;

                    if (dToT > 80)
                    {
                        thrustAmount = 0.3f;

                    }
                    else
                    {
                        thrustAmount = 0.0f;

                        if (!isAtk1)
                        {
                            EternalStruggle.Ys.Add(new EternalStruggle.RageHit(TimeSpan.FromSeconds(4.0)));
                            isAtk1 = true;
                            justBones.CopyTo(previousAnimation, 0);
                            currentAnimationTime = TimeSpan.Zero;
                        }
                    }

                }

            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);

            if (isRun)
            {
                runTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)3.0);
                if (runTime.TotalSeconds < 9.0f)
                {
                    if (runTime.TotalSeconds < 1.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun1[i].Decompose(out scale, out rota, out trans);
                            lRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun2[i].Decompose(out scale, out rota, out trans);
                            lRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun3[i].Decompose(out scale, out rota, out trans);
                            lRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun4[i].Decompose(out scale, out rota, out trans);
                            rRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun1[i].Decompose(out scale, out rota, out trans);
                            rRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 5.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 7.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun2[i].Decompose(out scale, out rota, out trans);
                            rRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 6.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 6.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 8.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun3[i].Decompose(out scale, out rota, out trans);
                            rRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 7.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 7.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun4[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 8.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 8.0) / 1.0f));

                        }


                    }

                }
                else
                {

                    runTime = TimeSpan.Zero;
                    lRun1.CopyTo(previousAnimation, 0);



                }

            }

            currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks);
            foreach (EternalStruggle.RageHit rageHit in EternalStruggle.Ys)
                rageHit.update(gameTime);

            if (isAtk3)
            {


                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            atk3a[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk3a[i].Decompose(out scale, out rota, out trans);
                            atk3b[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk3b[i].Decompose(out scale, out rota, out trans);
                            atk3c[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk3c[i].Decompose(out scale, out rota, out trans);
                            atk3b[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }




                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isAtk3 = false;
                }

            }
            if (isAtk1)
            {
                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            atk1a[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk1a[i].Decompose(out scale, out rota, out trans);
                            atk1b[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk1b[i].Decompose(out scale, out rota, out trans);
                            atk1c[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk1c[i].Decompose(out scale, out rota, out trans);
                            atk1d[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }




                }
                else if (!isDoubleStrike)
                {

                    isAtk1 = false;
                    currentAnimationTime = TimeSpan.Zero;



                }

                else if (currentAnimationTime.TotalSeconds < 5.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk1d[i].Decompose(out scale, out rota, out trans);
                        atk2a[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 6.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk2a[i].Decompose(out scale, out rota, out trans);
                        atk2b[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                    }


                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isAtk1 = false;
                    isDoubleStrike = false;

                }


            }

            Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 2.0f;
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);



            int pX = (int)position.X / 100;
            int pZ = (int)position.Z / 100;

            if (Position.X < 0)
                pX = 0;
            if (Position.Z < 0)
                pZ = 0;
            if (position.X > 12799)
                pX = 127;
            if (position.Z > 12799)
                pZ = 127;
            //Console.WriteLine(
            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;




            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            //if(resetFormation)
            formation = world;



        }
        public void UpdateUndead1(GameTime gameTime)
        {

            float dToT = Vector3.Distance(position, ScreenManager.AchillesRage1.World.Translation);
            float rotationAmount = 0.0f;
            rotationAmount = TurnToFace(position, ScreenManager.AchillesRage1.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
            if (dToT < 300.0f)//if it can be seen
                if (dToT > 200.0f)
                {
                    //  resetFormation = true;
                    thrustAmount = 1.0f;
                    if (!isRun)
                    {
                        isRun = true;
                        justBones.CopyTo(previousAnimation, 0);
                    }
                }
                else
                {
                    //   resetFormation = false;
                    thrustAmount = 0.0f;
                    runTime = TimeSpan.Zero;
                    isRun = false;

                    if (dToT > 80)
                    {
                        thrustAmount = 0.3f;

                    }
                    else
                    {
                        thrustAmount = 0.0f;

                        if (!isAtk1)
                        {
                            EternalStruggle.Bs.Add(new EternalStruggle.RageHit(TimeSpan.FromSeconds(4.0)));
                            isAtk1 = true;
                            justBones.CopyTo(previousAnimation, 0);
                            currentAnimationTime = TimeSpan.Zero;
                        }
                    }

                }

            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);

            if (isRun)
            {
                runTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)3.0);
                if (runTime.TotalSeconds < 9.0f)
                {
                    if (runTime.TotalSeconds < 1.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun1[i].Decompose(out scale, out rota, out trans);
                            lRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun2[i].Decompose(out scale, out rota, out trans);
                            lRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun3[i].Decompose(out scale, out rota, out trans);
                            lRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun4[i].Decompose(out scale, out rota, out trans);
                            rRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun1[i].Decompose(out scale, out rota, out trans);
                            rRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 5.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 7.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun2[i].Decompose(out scale, out rota, out trans);
                            rRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 6.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 6.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 8.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun3[i].Decompose(out scale, out rota, out trans);
                            rRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 7.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 7.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun4[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 8.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 8.0) / 1.0f));

                        }


                    }

                }
                else
                {

                    runTime = TimeSpan.Zero;
                    lRun1.CopyTo(previousAnimation, 0);



                }

            }

            currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks);
            foreach (EternalStruggle.RageHit rageHit in EternalStruggle.Bs)
                rageHit.update(gameTime);

            if (isAtk3)
            {


                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            atk3a[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk3a[i].Decompose(out scale, out rota, out trans);
                            atk3b[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk3b[i].Decompose(out scale, out rota, out trans);
                            atk3c[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk3c[i].Decompose(out scale, out rota, out trans);
                            atk3b[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }




                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isAtk3 = false;
                }

            }
            if (isAtk1)
            {
                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            atk1a[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk1a[i].Decompose(out scale, out rota, out trans);
                            atk1b[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk1b[i].Decompose(out scale, out rota, out trans);
                            atk1c[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk1c[i].Decompose(out scale, out rota, out trans);
                            atk1d[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }




                }
                else if (!isDoubleStrike)
                {

                    isAtk1 = false;
                    currentAnimationTime = TimeSpan.Zero;



                }

                else if (currentAnimationTime.TotalSeconds < 5.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk1d[i].Decompose(out scale, out rota, out trans);
                        atk2a[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 6.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk2a[i].Decompose(out scale, out rota, out trans);
                        atk2b[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                    }


                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isAtk1 = false;
                    isDoubleStrike = false;

                }


            }

            Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 2.0f;
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);



            int pX = (int)position.X / 100;
            int pZ = (int)position.Z / 100;

            if (Position.X < 0)
                pX = 0;
            if (Position.Z < 0)
                pZ = 0;
            if (position.X > 12799)
                pX = 127;
            if (position.Z > 12799)
                pZ = 127;
            //Console.WriteLine(
            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;




            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            //if(resetFormation)
            formation = world;



        }
        public void UpdateUndeadLeader2(GameTime gameTime)
        {

            float dToT = Vector3.Distance(position, ScreenManager.AchillesRage1.World.Translation);
            float rotationAmount = 0.0f;
            rotationAmount = TurnToFace(position, ScreenManager.AchillesRage1.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
           
            if(!isAddRageAtk)
            {
                isAddRageAtk = true;
                currentAnimationTime = TimeSpan.Zero;
                EternalStruggle.LSs.Add(new EternalStruggle.RageHit(TimeSpan.FromSeconds(6)));
            }
            currentAnimationTime += gameTime.ElapsedGameTime;
            foreach (EternalStruggle.RageHit rageHit in EternalStruggle.LSs)
                rageHit.update(gameTime);

            if (currentAnimationTime.TotalSeconds > 6 )
            {

                isAddRageAtk = false;

            }
            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);

          
            Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 2.0f;
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);



            int pX = (int)position.X / 100;
            int pZ = (int)position.Z / 100;

            if (Position.X < 0)
                pX = 0;
            if (Position.Z < 0)
                pZ = 0;
            if (position.X > 12799)
                pX = 127;
            if (position.Z > 12799)
                pZ = 127;
            //Console.WriteLine(
            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;




            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            //if(resetFormation)
            formation = world;



        }
        public void UpdateUndeadLeader(GameTime gameTime)
        {

            float dToT = Vector3.Distance(position, ScreenManager.AchillesRage1.World.Translation);
            float rotationAmount = 0.0f;
            rotationAmount = TurnToFace(position, ScreenManager.AchillesRage1.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
            if (dToT < 300.0f)//if it can be seen
                if (dToT > 200.0f)
                {
                    //  resetFormation = true;
                    thrustAmount = 1.0f;
                    if (!isRun)
                    {
                        isRun = true;
                        justBones.CopyTo(previousAnimation, 0);
                    }
                }
                else
                {
                    //   resetFormation = false;
                    thrustAmount = 0.0f;
                    runTime = TimeSpan.Zero;
                    isRun = false;

                    if (dToT > 80)
                    {
                        thrustAmount = 0.3f;

                    }
                    else
                    {
                        thrustAmount = 0.0f;
 
                        if (!isAtk1)
                        {
                            EternalStruggle.As.Add(new EternalStruggle.RageHit(TimeSpan.FromSeconds(4.0)));
                            isAtk1 = true;
                            justBones.CopyTo(previousAnimation, 0);
                            currentAnimationTime = TimeSpan.Zero;
                        }
                    }

                }

            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);

            if (isRun)
            {
                runTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)3.0);
                if (runTime.TotalSeconds < 9.0f)
                {
                    if (runTime.TotalSeconds < 1.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun1[i].Decompose(out scale, out rota, out trans);
                            lRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun2[i].Decompose(out scale, out rota, out trans);
                            lRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun3[i].Decompose(out scale, out rota, out trans);
                            lRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun4[i].Decompose(out scale, out rota, out trans);
                            rRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun1[i].Decompose(out scale, out rota, out trans);
                            rRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 5.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 7.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun2[i].Decompose(out scale, out rota, out trans);
                            rRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 6.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 6.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 8.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun3[i].Decompose(out scale, out rota, out trans);
                            rRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 7.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 7.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun4[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 8.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 8.0) / 1.0f));

                        }


                    }

                }
                else
                {

                    runTime = TimeSpan.Zero;
                    lRun1.CopyTo(previousAnimation, 0);



                }

            }

            currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks);
            foreach (EternalStruggle.RageHit rageHit in EternalStruggle.As)
                rageHit.update(gameTime);

            if (isAtk3)
            {


                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            atk3a[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk3a[i].Decompose(out scale, out rota, out trans);
                            atk3b[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk3b[i].Decompose(out scale, out rota, out trans);
                            atk3c[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk3c[i].Decompose(out scale, out rota, out trans);
                            atk3b[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }




                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isAtk3 = false;
                }

            }
            if (isAtk1)
            {
                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            atk1a[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk1a[i].Decompose(out scale, out rota, out trans);
                            atk1b[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk1b[i].Decompose(out scale, out rota, out trans);
                            atk1c[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            atk1c[i].Decompose(out scale, out rota, out trans);
                            atk1d[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }




                }
                else if (!isDoubleStrike)
                {

                    isAtk1 = false;
                    currentAnimationTime = TimeSpan.Zero;



                }

                else if (currentAnimationTime.TotalSeconds < 5.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk1d[i].Decompose(out scale, out rota, out trans);
                        atk2a[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 6.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk2a[i].Decompose(out scale, out rota, out trans);
                        atk2b[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                    }


                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isAtk1 = false;
                    isDoubleStrike = false;

                }


            }

            Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 2.0f;
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);



            int pX = (int)position.X / 100;
            int pZ = (int)position.Z / 100;

            if (Position.X < 0)
                pX = 0;
            if (Position.Z < 0)
                pZ = 0;
            if (position.X > 12799)
                pX = 127;
            if (position.Z > 12799)
                pZ = 127;
            //Console.WriteLine(
            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;




            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            //if(resetFormation)
            formation = world;

            

        }

        public Vector3 toVec(Point inPt)
        {
           // return (new Vector3(inPt.X * 30.0f + 15, 0.0f, inPt.Y * 30.0f + 15));
            return (new Vector3(inPt.X * 100.0f + 50, 0.0f, inPt.Y * 100.0f + 50));
        }
        public Point mFromVec(Vector3 inVec)
        {

            return (new Point((int)inVec.X / 60, (int)inVec.Z / 60));
        }
        
        public Point fromVec(Vector3 inVec)
        {

           // return (new Point((int)inVec.X / 30, (int)inVec.Z / 30));
            return (new Point((int)inVec.X / 100, (int)inVec.Z / 100));
        }

        public Vector3 toVecLS(Point inPt)
        {
            // return (new Vector3(inPt.X * 30.0f + 15, 0.0f, inPt.Y * 30.0f + 15));
            return (new Vector3(inPt.X * 30 + 15, 0.0f, inPt.Y * 30 + 15));
        }
        public Point fromVecLS(Vector3 inVec)
        {

            // return (new Point((int)inVec.X / 30, (int)inVec.Z / 30));
            return (new Point((int)inVec.X / 30, (int)inVec.Z / 30));
        }

        public void UpdateGhost(GameTime gameTime)
        {
            oldPosition = Position;
            if (gState == 0)
                runDestination = ScreenManager.gates[0].Center;
            else if (gState == 1)
                runDestination = ScreenManager.gates[1].Center;
            else if (gState == 2)
                runDestination = ScreenManager.gates[2].Center;
            else if (gState == 3)
                runDestination = ScreenManager.gates[3].Center;
            else if (gState == 4)
                runDestination = ScreenManager.gates[4].Center;
            //else if (gState == 5)
            //    runDestination = ScreenManager.gates[2].Center;

            float dToT = Vector3.Distance(position, runDestination);
            float rotationAmount = 0.0f;
            rotationAmount = TurnToFace(position, runDestination, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));


            if (dToT >= 10)
                Position += Direction * 5.0f;
            else
            {
                gState++;
                if (gState > 4)
                    activated = false;

            }

            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);

            brace.CopyTo(justBones, 0);
            world.Up = Up;
            world.Forward = Direction;
            world.Right = Right;
            world.Translation = Position;

            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            formation = world;


        }

        public void LSPathing(GameTime gameTime)
        {
            oldPosition = Position;
            float dToT = Vector3.Distance(position, runDestination);
            float rotationAmount = 0.0f;
            rotationAmount = TurnToFace(position, runDestination, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
            //Console.WriteLine(runDestination);
            if (pathState == 0)
            {
                if (flag == 0)
                    //uiPath = new UnitPathing(fromVec(position), fromVec(Vector3.Zero));
                        uiPath = new UnitPathing(fromVecLS(position), fromVecLS(ScreenManager.cupidTemple.position - new Vector3(0.0f, 0.0f, 30.0f)));
                    //Console.WriteLine("UnitPathing active");
                if (flag == 1)
                    //uiPath.Reset( fromVec(position), fromVec(new Vector3(500.0f, 0.0f, 0.0f)));
                    uiPath.Reset(fromVecLS(ScreenManager.cupidTemple.position - new Vector3(0.0f, 0.0f, 30.0f)), fromVecLS(Vector3.Zero));
                if (flag == 2)
                {
                    uiPath.Reset(fromVec(position), fromVec(new Vector3(90, 0.0f, 90.0f)));

                }
                if (flag == 3)
                {
                    uiPath.Reset(fromVecLS(position), fromVecLS(new Vector3(120.0f, 0.0f, 90)));
                }
                pathState = 1;


            }

            if (pathState == 1)
            {

                if (uiPath.SearchStatus == SearchStatus.Stopped)
                    uiPath.SearchStatus = SearchStatus.Searching;
                pathState = 2;
            }
            if (pathState == 2)
            {
                while (uiPath.SearchStatus == SearchStatus.Searching)
                {

                    uiPath.DoSearchStep();


                }

                if (uiPath.SearchStatus == SearchStatus.PathFound)
                {
                    foreach (Point point in uiPath.FinalPath())
                    {
                        pathing.Add(point);
                    }
                    pathState = 3;

                    if (pathing.Count > 1)
                    {
                        runDestination = toVecLS(pathing[0]);
                        pathing.RemoveAt(0);

                    }
                }

            }

            if (pathState == 3)
            {


                if (dToT >= 15)
                    Position += Direction * .50f;
                if (dToT < 15f)
                {
                    if (pathing.Count >= 1)
                    {
                        runDestination = toVecLS(pathing[0]);
                        pathing.RemoveAt(0);

                    }
                    else
                    {
                        if (flag == 0)
                        {
                            flag = 1;
                            pathState = 0;
                        }
                        else if (flag == 1)
                        {
                            flag = 0;
                            pathState = 0;
                        }
                        else if (flag == 2)
                        {
                            flag = 3;
                            pathState = 0;
                        }
                        else if (flag == 3)
                        {
                            flag = 0;
                            pathState = 0;

                        }
                    }


                }





            }

            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);

            brace.CopyTo(justBones, 0);
            world.Up = Up;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            formation = world;
            


        }


            
        public void PathingUpdate1(GameTime gameTime)
        {

            oldPosition = Position;
            float dToT = Vector3.Distance(position, runDestination);
            float rotationAmount = 0.0f;
            rotationAmount = TurnToFace(position, runDestination, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

            if (pathState == 0)
            {
                if(flag == 0)
                //uiPath = new UnitPathing(fromVec(position), fromVec(Vector3.Zero));
                    uiPath = new UnitPathing(fromVec(ScreenManager.LSMino.Position), fromVec(ScreenManager.cupidTemple.position - new Vector3(0.0f, 0.0f, 30.0f)));
                if (flag == 1)
                    //uiPath.Reset( fromVec(position), fromVec(new Vector3(500.0f, 0.0f, 0.0f)));
                    uiPath.Reset(fromVec(ScreenManager.cupidTemple.position - new Vector3(0.0f, 0.0f, 30.0f)), fromVec(ScreenManager.LSMino.Position));
                if (flag == 2)
                {
                    uiPath.Reset(fromVec(position), fromVec(new Vector3(500.0f, 0.0f, 500.0f)));

                }
                if (flag == 3)
                {
                    uiPath.Reset(fromVec(position), fromVec(new Vector3(0.0f, 0.0f, 500.0f)));
                }
                pathState = 1;

                
            }

            if (pathState == 1)
            {

                if (uiPath.SearchStatus == SearchStatus.Stopped)
                    uiPath.SearchStatus = SearchStatus.Searching;
                pathState = 2; 
            }
            if (pathState == 2)
            {
                while (uiPath.SearchStatus == SearchStatus.Searching)
                {

                    uiPath.DoSearchStep();


                }

                if (uiPath.SearchStatus == SearchStatus.PathFound)
                {
                    foreach (Point point in uiPath.FinalPath())
                    {
                        pathing.Add(point);
                    }
                    pathState = 3;

                    if (pathing.Count > 1)
                    {
                        runDestination = toVec(pathing[0]);
                        pathing.RemoveAt(0);

                    }
                }

            }

            if (pathState == 3)
            {


                if(dToT >= 30)
                Position += Direction * .50f;
                if (dToT < 30.0f)
                {
                    if (pathing.Count >= 1)
                    {
                        runDestination = toVec(pathing[0]);
                        pathing.RemoveAt(0);

                    }
                    else  
                    {
                        if (flag == 0)
                        {
                            flag = 1;
                            pathState = 0;
                        }
                        else if (flag == 1)
                        {
                            flag = 2;
                            pathState = 0;
                        }
                        else if (flag == 2)
                        {
                            flag = 3;
                            pathState = 0; 
                        }
                        else if (flag == 3)
                        {
                            flag = 0;
                            pathState = 0; 

                        }
                    }


                }
                




            }

            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);
            
            brace.CopyTo(justBones, 0);
            world.Up = Up;
            world.Forward = Direction;
            world.Right = Right;
            world.Translation = Position;

            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            formation = world;

        }
        public void UpdateEnemyRunner(GameTime gameTime)
        {
            oldPosition = Position;
            float dToT = Vector3.Distance(position, runDestination);
            float rotationAmount = 0.0f;
            rotationAmount = TurnToFace(position, runDestination, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

            if (pathState == 0)
            {
                uiPath = new UnitPathing(fromVec(Position), fromVec(new Vector3(Position.X, 0.0f, 0.0f)));
                pathState = 1; 
            }
            if (pathState == 1)
            {

                if (uiPath.SearchStatus == SearchStatus.Stopped)
                    uiPath.SearchStatus = SearchStatus.Searching;
                pathState = 2;
            }

            if (pathState == 2)
            {
                while (uiPath.SearchStatus == SearchStatus.Searching)
                {

                    uiPath.DoSearchStep();


                }

                if (uiPath.SearchStatus == SearchStatus.PathFound)
                {
                    foreach (Point point in uiPath.FinalPath())
                    {
                        pathing.Add(point);
                    }
                    pathState = 3;

                    if (pathing.Count > 1)
                    {
                        runDestination = toVec(pathing[0]);
                        pathing.RemoveAt(0);

                    }
                }

            }
            if (pathState == 3)
            {


                if (dToT >= 30)
                    Position += Direction * .50f;
                if (dToT < 30.0f)
                {
                    if (pathing.Count >= 1)
                    {
                        runDestination = toVec(pathing[0]);
                        pathing.RemoveAt(0);

                    }
                    else
                    {
                        successRun = true;

                    }
                }
            }


            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);

            brace.CopyTo(justBones, 0);
            world.Up = Up;
            world.Forward = Direction;
            world.Right = Right;
            world.Translation = Position;

            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            formation = world;

        }

        public void UpdateSword(GameTime gameTime)
        {
            int i = 0;
            float dToT = 0; 
            float rotationAmount = 0;
            foreach(JuneXnaModel eRun in ScreenManager.enemyRunners)
            {


                oldPosition = Position;
                dToT = Vector3.Distance(position, eRun.World.Translation);
                 rotationAmount = 0.0f;
                 rotationAmount = TurnToFace(position, eRun.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                if (dToT < 60.0f)
                {
                    targetIndex = i;
                    isAtk1 = true;
                    break;                   
                }
                i++;

            }

            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            if (isAtk1)
                UpdateBasic1(gameTime);


            if (isAtk1)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();


        }
        public void hurtUpdate(GameTime gameTime)
        {
            currentAnimationTime += TimeSpan.FromTicks(gameTime.ElapsedGameTime.Ticks * 3);
            if (currentAnimationTime.TotalSeconds < 2.0f)
            {

                for (int i = 0; i < brace.Length; i++)
                {
                    previousAnimation[i].Decompose(out scale, out rota, out trans);
                    kb2[i].Decompose(out scale2, out rota2, out trans2);
                    upperBones[i] = Matrix.CreateScale(scale2) *
    Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 2.0f)) *
    Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 2.0f));

                }

            }
            else
            {
                isHurt = false;
                currentAnimationTime = TimeSpan.Zero;
                standing.CopyTo(previousAnimation, 0); 
            }

            //standing.CopyTo(upperBones, 0);
            world.Up = Vector3.Up;
            world.Forward = Vector3.Backward;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            formation = world;

        }
        public void UpdateShield(GameTime gameTime)
        {
            
            shield2.CopyTo(upperBones, 0);
            shield2.CopyTo(previousAnimation, 0);
            world.Up = Vector3.Up;
            world.Forward = Vector3.Backward;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            formation = world;
            
        }

        public void UpdateHurt(GameTime gameTime)
        {

            currentAnimationTime += TimeSpan.FromTicks(gameTime.ElapsedGameTime.Ticks * 3);
            if (currentAnimationTime.TotalSeconds < 2.0f)
            {

                for (int i = 0; i < brace.Length; i++)
                {
                    previousAnimation[i].Decompose(out scale, out rota, out trans);
                    hurt1[i].Decompose(out scale2, out rota2, out trans2);
                    upperBones[i] = Matrix.CreateScale(scale2) *
    Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 2.0f)) *
    Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 2.0f));

                }

            }
            else
            {
                isHurt = false;
                currentAnimationTime = TimeSpan.Zero;
                standing.CopyTo(previousAnimation, 0);
            }

            //standing.CopyTo(upperBones, 0);
            world.Up = Vector3.Up;
            world.Forward = Vector3.Backward;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            formation = world;



        }
        public void UpdateBrace(GameTime gameTime)
        {

            brace.CopyTo(justBones, 0);
            brace.CopyTo(previousAnimation, 0);
            world.Up = Vector3.Up;
            world.Forward = Vector3.Backward;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;
            
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            formation = world;

        }

        public void UpdatePlayerRts(GameTime gameTime)
        {







        }
        public void UpdateRogue(GameTime gameTime)
        {

            oldPosition = position;

            float dToA = Vector3.Distance(position, ScreenManager.Theseus.Position);
            float rotationAmount = 0.0f;
            rotationAmount = TurnToFace(position, ScreenManager.Theseus.Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
            float dToS = 0;

            bodySphere = new BoundingSphere(position + new Vector3(0.0f, 70.0f, 0.0f), 20.0f);
            //have to do something to keep them only getting valid movement positions
            //if (dToT < 280)
            //{
            //  fstate = 0;
            //    setSpheres.Clear();
            //}


            if (setSpheres.Count > 0 && fstate != 2)
            {
                dToS = Vector3.Distance(position, setSpheres[0].Center);
                rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                fstate = 1;
                if (dToA < 60)//in a set sphere and can atk so you can stop
                {
                    fstate = 0;
                    setSpheres.Clear();
                    rotationAmount = TurnToFace(position, ScreenManager.Theseus.Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                }

            }
            // else
            //     fstate = 0; 





            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);

            if (health <= 0)
            {
                if (!dead)
                {
                    currentAnimationTime = TimeSpan.Zero;
                    justBones.CopyTo(previousAnimation, 0);
                    isKnockDown = true;
                    dead = true;

                }
                updateKnockDown(gameTime);
            }
            else
            {






                if (!active && state == 0)
                    restTimer += gameTime.ElapsedGameTime;

                if (restTimer > TimeSpan.FromSeconds(3.0))
                {
                    restTimer = TimeSpan.FromSeconds(3.0);
                    active = true;
                }
                if (isKnockedBack)
                {
                    if (!isKnockBack)
                    {
                       // isKnockedBack = false;
   
                        isKnockBack = true;
                        justBones.CopyTo(previousAnimation, 0);
                        currentAnimationTime = TimeSpan.Zero;

                        isAtk1 = false;
                        isAtk2 = false;
                        isAtk3 = false;
                        isRun = false;
                    }
                }




                //if (dToT < 300.0f)//if it can be seen
                if (fstate == 0)
                {
                    if (dToA > 60)
                    {
                        //  resetFormation = true;
                        thrustAmount = 1.0f;
                        if (!isRun)
                        {
                            isRun = true;
                            justBones.CopyTo(previousAnimation, 0);
                        }

                    }
                    else
                    {


                        //   resetFormation = false;
                        thrustAmount = 0.0f;
                        runTime = TimeSpan.Zero;
                        isRun = false;

                        if (dToA > 60)
                        {
                            thrustAmount = 1.3f;

                        }
                        else
                        {
                            thrustAmount = 0.0f;

                            if (restTimer > TimeSpan.FromSeconds(.5) & !isAtk1 & !isAtk2 & !isAtk3)
                            {

                                int random = ScreenManager.rand.Next();
                                {
                                    if (random % 3 == 1)
                                    {
                                        currentAtkTime = new TimeSpan(0, 0, 1);
                                        active = true;
                                        isAtk1 = true;

                                        justBones.CopyTo(previousAnimation, 0);

                                        openStrike = true;
                                        restTimer = TimeSpan.Zero;
                                    }
                                    if (random % 3 == 2)
                                    {
                                        currentAtkTime = new TimeSpan(0, 0, 1);
                                        justBones.CopyTo(previousAnimation, 0);
                                        isAtk2 = true;
                                        isAtk1 = true;
                                    }
                                    if (random % 3 == 0)
                                    {
                                        currentAtkTime = new TimeSpan(0, 0, 1);
                                        justBones.CopyTo(previousAnimation, 0);
                                        isAtk3 = true;
                                        isAtk2 = true;
                                        isAtk1 = true;
                                    }

                                }


                                if (!isAtk1)
                                {
                                    isAtk1 = true;
                                    active = true;

                                }
                            }

                        }

                    }
                    // Console.WriteLine(restTimer);
                }
                if (fstate == 1)
                {
                    if (dToS > 10)
                    {
                        //  resetFormation = true;
                        thrustAmount = 1.0f;
                        if (!isRun)
                        {
                            isRun = true;
                            justBones.CopyTo(previousAnimation, 0);
                        }

                    }

                    // Console.WriteLine(restTimer);
                }
                if (fstate == 2)
                {



                }
            }
            if (setSpheres.Count > 0)
                if (setSpheres[0].Contains(position + new Vector3(0.0f, 70.0f, 0.0f)) == ContainmentType.Contains)
                    setSpheres.RemoveAt(0);

            if (setSpheres.Count == 0)
            {
                miniPathSet = false;


                //West to East South to North each sphere has radius of 40
                moveSpheres[0][0] = new BoundingSphere(position - new Vector3(80.0f, -70.0f, -80.0f), 20.0f);
                moveSpheres[0][1] = new BoundingSphere(position - new Vector3(80.0f, -70.0f, -40.0f), 20.0f);
                moveSpheres[0][2] = new BoundingSphere(position - new Vector3(80.0f, -70.0f, 0.0f), 20.0f);
                moveSpheres[0][3] = new BoundingSphere(position - new Vector3(80.0f, -70.0f, 40.0f), 20.0f);
                moveSpheres[0][4] = new BoundingSphere(position - new Vector3(80.0f, -70.0f, 80.0f), 20.0f);
                moveSpheres[1][0] = new BoundingSphere(position - new Vector3(40.0f, -70.0f, -80.0f), 20.0f);
                moveSpheres[1][1] = new BoundingSphere(position - new Vector3(40.0f, -70.0f, -40.0f), 20.0f);
                moveSpheres[1][2] = new BoundingSphere(position - new Vector3(40.0f, -70.0f, 0.0f), 20.0f);
                moveSpheres[1][3] = new BoundingSphere(position - new Vector3(40.0f, -70.0f, 80.0f), 20.0f);
                moveSpheres[1][4] = new BoundingSphere(position - new Vector3(40.0f, -70.0f, 40.0f), 20.0f);
                moveSpheres[2][0] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, -80.0f), 20.0f);
                moveSpheres[2][1] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, -40.0f), 20.0f);
                moveSpheres[2][2] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, 0.0f), 20.0f);
                moveSpheres[2][3] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, 40.0f), 20.0f);
                moveSpheres[2][4] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, 80.0f), 20.0f);
                moveSpheres[3][0] = new BoundingSphere(position - new Vector3(-40.0f, -70.0f, -80.0f), 20.0f);
                moveSpheres[3][1] = new BoundingSphere(position - new Vector3(-40.0f, -70.0f, -40.0f), 20.0f);
                moveSpheres[3][2] = new BoundingSphere(position - new Vector3(-40.0f, -70.0f, 0.0f), 20.0f);
                moveSpheres[3][3] = new BoundingSphere(position - new Vector3(-40.0f, -70.0f, 80.0f), 20.0f);
                moveSpheres[3][4] = new BoundingSphere(position - new Vector3(-40.0f, -70.0f, 40.0f), 20.0f);
                moveSpheres[4][0] = new BoundingSphere(position - new Vector3(-80.0f, -70.0f, -80.0f), 20.0f);
                moveSpheres[4][1] = new BoundingSphere(position - new Vector3(-80.0f, -70.0f, -40.0f), 20.0f);
                moveSpheres[4][2] = new BoundingSphere(position - new Vector3(-80.0f, -70.0f, 0.0f), 20.0f);
                moveSpheres[4][3] = new BoundingSphere(position - new Vector3(-80.0f, -70.0f, 80.0f), 20.0f);
                moveSpheres[4][4] = new BoundingSphere(position - new Vector3(-80.0f, -70.0f, 40.0f), 20.0f);


                for (int i = 0; i < 5; i++)
                    for (int j = 0; j < 5; j++)
                        open[i][j] = true;
                for (int i = 0; i < 5; i++)
                    for (int j = 0; j < 5; j++)
                        for (int k = 0; k < ScreenManager.fighters.Count; k++)
                        {
                            if (k != fighterIndex)
                            {
                                if (moveSpheres[i][j].Contains(ScreenManager.fighters[k].collisionS[1].BS) != ContainmentType.Disjoint)
                                {
                                    open[i][j] = false;
                                    //    Console.WriteLine(fighterIndex + " " + k);
                                }
                                else
                                    k = k;
                            }
                        }
                //find the closest open tile
                int thisI = 0;
                int thisJ = 0;
                float lowest = 99999999;
                float check = 0;
                for (int i = 0; i < 5; i++)
                    for (int j = 0; j < 5; j++)
                    {
                        if (open[i][j])
                        {
                            check = Vector3.Distance(moveSpheres[i][j].Center, ScreenManager.Theseus.Position);
                            if (check < lowest)
                            {
                                thisI = i;
                                thisJ = j;
                                lowest = check;
                            }
                        }
                    }

               // if (thisI == 2 && thisJ == 2)
               //     fstate = 2;

                Reset(new Point(2, 2), new Point(thisI, thisJ));
                JsearchStatus = JSearchStatus.Searching;

                while (JsearchStatus == JSearchStatus.Searching)
                {

                    DoSearchStep();
                }

                if (myJSearchStatus == JSearchStatus.PathFound)
                {
                    foreach (Point point in FinalPath())
                    {
                        setSpheres.Add(moveSpheres[point.X][point.Y]);
                    }
                }
                //else
                //    fstate = 2;


            }

            if (!miniPathSet)
            {
                //find the next two spheres that player will use //looks ahead two steps
                //Vector3 pos1 = position + new Vector3(0.0f, 70.0f, 0.0f) + Direction * 40;
                //Vector3 pos2 = position + new Vector3(0.0f, 70.0f, 0.0f) + Direction * 60;

                //for (int i = 0; i < 5; i++)
                //    for (int j = 0; j < 5; j++)
                //    {
                //        //if (moveSpheres[i][j].Contains(position) == ContainmentType.Contains)
                //        //    setSpheres.Add(moveSpheres[i][j]);
                //        if (moveSpheres[i][j].Contains(pos1) == ContainmentType.Contains)
                //            setSpheres.Add(moveSpheres[i][j]);
                //        if (moveSpheres[i][j].Contains(pos2) == ContainmentType.Contains)
                //            setSpheres.Add(moveSpheres[i][j]);

                //    }

                //for(int i = 0; i<fighterIndex; i++)
                //{
                //    if (i != fighterIndex)
                //    {



                //    }

                //}


                miniPathSet = true;
            }




            if (isAtk1 || isAtk2 || isAtk3)
            {
                if (currentAnimationTime.TotalMilliseconds < 500)
                    thrustAmount = .5f;
                else
                    Direction = oldDirection;
            }
            x = (float)Math.Sin(rotationAmount);
            y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);




            if (isRun)
                updateRun(gameTime);

            if (isAtk1)
                UpdateBasic1(gameTime);
            else if (isAtk2)
                UpdateBasic2(gameTime);
            else if (isAtk3)
                UpdateBasic3(gameTime);

            if (isKnockBack)
                UpdateKnockBack(gameTime);
            if (isKnockDown)
                updateKnockDown(gameTime);

            if (!dead)
            {
                if (state == 1)
                    Position += new Vector3(DirToFormation.X, DirToFormation.Y, DirToFormation.Z) * 2.0f;
                else if (isRun)
                    Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 1.0f;
            }
            //if(isKnockBack)
            //    Position -= new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 2.0f;

            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1 || isAtk2 || isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockDown)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);


            if (isKnockBack)
            {
               // Console.WriteLine(kbTimer);
                Position = oldPosition + knockBackVec * 5.0f;
                Position = oldPosition + kbVec * 5.0f;
                kbTimer -= gameTime.ElapsedGameTime;
                if (kbTimer < TimeSpan.Zero)
                    isKnockBack = false;
            }



            int pX = (int)position.X / 100;
            int pZ = (int)position.Z / 100;

            if (Position.X < 0)
                pX = 0;
            if (Position.Z < 0)
                pZ = 0;
            if (position.X > 12799)
                pX = 127;
            if (position.Z > 12799)
                pZ = 127;
            //Console.WriteLine(
            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;




            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            //if(resetFormation)
            formation = world;


        }
        public void fighterNextTarget()
        {
            float current = 0;
            float lowest= 1000000;
            int index = 0;
            int counter = 0;
            foreach (Tower tower in ScreenManager.Towers)
            {
                if (tower.alive)
                {
                    current = Vector3.Distance(tower.translation, position);
                    if (current < lowest)
                    {
                        lowest = current;
                        index = counter;
                        fighterState = 2;
                        towerIndex = index;
                    }
                    counter++;
                }
            }

            float dToP = 0;

            current = Vector3.Distance(ScreenManager.Theseus.position, position);
            if (current < lowest  && current < 300)
            {
                lowest = current;
                fighterState = 1;

            }

            current = Vector3.Distance(Vector3.Zero, position);
            if (current < lowest)
            {
                lowest = current;
                fighterState = 0;
                
            }




        }
        public bool onTheBoardFunction(Point point, int maxBounds)
        {
            if (point.X < maxBounds && point.X > 0)
                if (point.Y < maxBounds && point.Y > 0)
                    return true;

            return false;


        }
        public void calculateFutureMovement(GameTime gameTime)
        {
            futureMovement.Clear();
            //target is 30 fps  60 seconds well start off seeing every 10th of a second
           // futureMovement
            Vector3 futPosition = Position;
            float futDisFromGoal = 0; 
            float futRotationAmount=0;
            //if(moveState == 0)
            futRotationAmount = TurnToFace(position, plannedPosition, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
            float x = (float)Math.Sin(futRotationAmount);
            float y = (float)Math.Cos(futRotationAmount);
            Vector3 futDirection = new Vector3(x, 0.0f, y);
            
            //use elapsed game time to guess update loop

            //for case when running to a point
            if (moveState == 0)
            {
                futRotationAmount = TurnToFace(position, plannedPosition, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                for (int i = 0; i < 10; i++)
                {
                    if (Vector3.Distance(futPosition, plannedPosition) > 10)
                    {
                        futPosition += futDirection * i * (float)gameTime.ElapsedGameTime.TotalSeconds * 100;
                        futureMovement.Add(new BoundingSphere(futPosition + new Vector3(0.0f, 70.0f, 0.0f), 25.6f));

                    }

                }
            }

            Vector3 futIntervalDirection = Direction;
            if(setSpheres.Count > 0)
            futRotationAmount = TurnToFace(position, setSpheres[0].Center, 
                new Vector3(0.0f, (float)Math.Atan((double)(futIntervalDirection.Z / futIntervalDirection.X)), 0.0f));
             x = (float)Math.Sin(futRotationAmount);
             y = (float)Math.Cos(futRotationAmount);
             futIntervalDirection = new Vector3(x, 0.0f, y);
            Vector3 futIntervalPosition = position;
            int setSphereCount = 0; 
            int increment = 0;
            if (moveState == 2)
            {
                for (int i = 0; i < 10; i++)
                {
                    if (setSphereCount < setSpheres.Count)
                    {
                        if (Vector3.Distance(futIntervalPosition, setSpheres[setSphereCount].Center) > 10)
                        {
                            futIntervalPosition += futIntervalDirection * increment * (float)gameTime.ElapsedGameTime.TotalSeconds * 100;
                            futureMovement.Add(new BoundingSphere(futIntervalPosition + new Vector3(0.0f, 70.0f, 0.0f), 25.6f));
                        }
                        else
                        {
                            setSphereCount++;
                            if (setSphereCount < setSpheres.Count)
                            {
                                futRotationAmount = TurnToFace(position, setSpheres[setSphereCount].Center,
        new Vector3(0.0f, (float)Math.Atan((double)(futIntervalDirection.Z / futIntervalDirection.X)), 0.0f));
                                x = (float)Math.Sin(futRotationAmount);
                                y = (float)Math.Cos(futRotationAmount);
                                futIntervalDirection = new Vector3(x, 0.0f, y);
                            }
                        }
                    }
                }
            }



        }
        
        public void checkMoveValidity( int bounds)
        {
            float rotationAmount = 0.0f;
            Vector3 sepDirection = Vector3.Zero;
            Vector3 delta = Vector3.Zero;
            moveWait = false;
            float x = 0;
            float y = 0;

            if (Position.X <= 0)
                xOnZero = true;
            if (Position.X > bounds)
                xOnBounds = true;
            if (Position.Y <= 0)
                yOnZero = true;
            if (Position.Y > bounds)
                yOnBounds = true;
            if (xOnZero)
                while (Position.X < 0)
                    Position += new Vector3(1.0f, 0.0f, 0.0f);
            if (xOnBounds)
                while (Position.X > bounds)
                    Position += new Vector3(-1.0f, 0.0f, 0.0f);
            if (yOnZero)
                while (Position.Z < 0)
                    Position += new Vector3(0.0f, 0.0f, 1.0f);
            if (yOnBounds)
                while (position.Z > bounds)
                    Position += new Vector3(0.0f, 0.0f, -1.0f);

            collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
           // getCollisions();
            //must push these so that everyone on board //assumes that if move isnt valid it
            //for (int i = 0; i < ScreenManager.collisionGroups[assignedColGroup].Count; i++)
            //{
            //    if(fighterIndex != ScreenManager.collisionGroups[assignedColGroup][i])
            //    while (collisionS[1].BS.Contains(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][i]].collisionS[1].BS) != ContainmentType.Disjoint)
            //    {
            //        rotationAmount = TurnToFace(Position, ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][i]].Position, new Vector3(0.0f, (float)Math.Atan((double)(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][i]].Direction.Z / ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][i]].Direction.X)), 0.0f));
            //        x = (float)Math.Sin(rotationAmount);
            //        y = (float)Math.Cos(rotationAmount);
            //        sepDirection = new Vector3(x, 0.0f, y);

            //        ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][i]].Position += sepDirection * 10;
            //        ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][i]].collisionS[1].BS = new BoundingSphere(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][i]].Position + new Vector3(0.0f, 70.0f, 0.0f), ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][i]].collisionS[1].BS.Radius);
            //    }

            //}
        }
        public void getCollisions2()
        {
            collisionCount = 0;
            bool foundThisIndex = false;
            int colGroupIndex = 0;
            bool colGroupFound = false;
            //check to see if fighterIndex is already in a collision group
            for (int i = 0; i < ScreenManager.collisionGroups.Count; i++)
            {
                if (ScreenManager.collisionGroups[i].Contains(fighterIndex))
                {
                    colGroupIndex = i;
                    colGroupFound = true;
                }



            }
            if (collisionS[1].BS.Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
            {
                int i = 99;
                collisionCount++;
                // if (collisionCount == 1)
                // {
                for (int j = 0; j < ScreenManager.collisionGroups.Count; j++)
                //if you collide with it see if it has a collision group and if so that is your collisiong roup
                //foreach (List<int> list in ScreenManager.collisionGroups)
                {
                    if (ScreenManager.collisionGroups[j].Contains(99))
                    {
                        foundThisIndex = true;
                        colGroupIndex = j;
                        break;
                    }
                }
                if (!foundThisIndex)
                {
                    ScreenManager.collisionGroups.Add(new List<int>());
                    ScreenManager.collisionGroups[ScreenManager.collisionGroups.Count - 1].Add(fighterIndex);
                    colGroupIndex = ScreenManager.collisionGroups.Count - 1;
                    foundThisIndex = true;
                }
                //}
                //add the 
                foundThisIndex = false;
                if (!ScreenManager.collisionGroups[colGroupIndex].Contains(i))
                    ScreenManager.collisionGroups[colGroupIndex].Add(i);


            }
            for (int i = 0; i < ScreenManager.dummies.Count; i++)
                if (collisionS[1].BS.Contains(ScreenManager.dummies[i].collisionS[1].BS) != ContainmentType.Disjoint)
                {
                    if (i != fighterIndex)
                    {
                        collisionCount++;
                        //   if (collisionCount == 1)
                        //{
                        for (int j = 0; j < ScreenManager.collisionGroups.Count; j++)
                        {
                            if (ScreenManager.collisionGroups[j].Contains(i))
                            {
                                foundThisIndex = true;
                                colGroupIndex = j;
                                break;
                            }
                        }
                        if (!foundThisIndex)
                        {
                            ScreenManager.collisionGroups.Add(new List<int>());
                            ScreenManager.collisionGroups[ScreenManager.collisionGroups.Count - 1].Add(fighterIndex);
                            colGroupIndex = ScreenManager.collisionGroups.Count - 1;
                            foundThisIndex = true;
                        }
                        // }
                        //add the 
                        if (!ScreenManager.collisionGroups[colGroupIndex].Contains(i))
                            ScreenManager.collisionGroups[colGroupIndex].Add(i);

                    }
                }
            if (collisionCount > 2)
                collisionCount = collisionCount + 1 - 1;
        }
        public void getCollisions4()
        {

            collisionCount = 0;
            bool foundThisIndex = false;
            int colGroupIndex = 0;
            bool colGroupFound = false;
            int index = 0;

            for (int i = 0; i < ScreenManager.collisionGroups.Count; i++)
            {
                if (ScreenManager.collisionGroups[i].Contains(index))
                {
                    colGroupIndex = i;
                    colGroupFound = true;
                }
            }
            if (collisionS[1].BS.Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
            {
                int i = 99;
                collisionCount++;
                // if (collisionCount == 1)
                // {
                for (int j = 0; j < ScreenManager.collisionGroups.Count; j++)
                //if you collide with it see if it has a collision group and if so that is your collisiong roup
                //foreach (List<int> list in ScreenManager.collisionGroups)
                {
                    if (ScreenManager.collisionGroups[j].Contains(99))
                    {
                        foundThisIndex = true;
                        colGroupIndex = j;
                        break;
                    }
                }
                if (!foundThisIndex)
                {
                    ScreenManager.collisionGroups.Add(new List<int>());
                    ScreenManager.collisionGroups[ScreenManager.collisionGroups.Count - 1].Add(index);
                    colGroupIndex = ScreenManager.collisionGroups.Count - 1;
                    foundThisIndex = true;
                }
                //}
                //add the 
                foundThisIndex = false;
                if (!ScreenManager.collisionGroups[colGroupIndex].Contains(i))
                    ScreenManager.collisionGroups[colGroupIndex].Add(i);


            }

            foreach (JuneXnaModel june in ScreenManager.dummies)
            {
                if (june != this)
                {
                    if (collisionS[1].BS.Contains(june.collisionS[1].BS) != ContainmentType.Disjoint)
                    {
                        collisionCount++;
                        for (int j = 0; j < ScreenManager.collisionGroups.Count; j++)
                        {
                            if (ScreenManager.collisionGroups[j].Contains(june.fighterIndex))
                            {
                                foundThisIndex = true;
                                colGroupIndex = j;
                                break;
                            }
                        }
                        if (!foundThisIndex)
                        {
                            ScreenManager.collisionGroups.Add(new List<int>());
                            ScreenManager.collisionGroups[ScreenManager.collisionGroups.Count - 1].Add(fighterIndex);
                            colGroupIndex = ScreenManager.collisionGroups.Count - 1;
                            foundThisIndex = true;
                        }

                        if (!ScreenManager.collisionGroups[colGroupIndex].Contains(june.fighterIndex))
                            ScreenManager.collisionGroups[colGroupIndex].Add(june.fighterIndex);


                    }
                }
            }
                foreach(JuneXnaModel june in ScreenManager.runners)
                {

                    if (june != this)
                    {
                        if (collisionS[1].BS.Contains(june.collisionS[1].BS) != ContainmentType.Disjoint)
                        {
                            collisionCount++;
                            for (int j = 0; j < ScreenManager.collisionGroups.Count; j++)
                            {
                                if (ScreenManager.collisionGroups[j].Contains(june.fighterIndex))
                                {
                                    foundThisIndex = true;
                                    colGroupIndex = j;
                                    break;
                                }
                            }
                            if (!foundThisIndex)
                            {
                                ScreenManager.collisionGroups.Add(new List<int>());
                                ScreenManager.collisionGroups[ScreenManager.collisionGroups.Count - 1].Add(fighterIndex);
                                colGroupIndex = ScreenManager.collisionGroups.Count - 1;
                                foundThisIndex = true;
                            }

                            if (!ScreenManager.collisionGroups[colGroupIndex].Contains(june.fighterIndex))
                                ScreenManager.collisionGroups[colGroupIndex].Add(june.fighterIndex);


                        }
                    }




                }



            


        }
        public void getCollisions3()
        {
            if (fighterIndex == 15)
                Console.WriteLine("p");
            collisionCount = 0;
            bool foundThisIndex = false;
            int colGroupIndex = 0;
            bool colGroupFound = false;
            int index = 0;
            if (isRunner)
                index = fighterIndex + 100;
            else if (isFighter)
                index = fighterIndex;

            int index2 = 0;
            //check to see if fighterIndex is already in a collision group
            for (int i = 0; i < ScreenManager.collisionGroups.Count; i++)
            {
                if (ScreenManager.collisionGroups[i].Contains(index))
                {
                    colGroupIndex = i;
                    colGroupFound = true;
                }



            }
            if (collisionS[1].BS.Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
            {
                int i = 99;
                collisionCount++;
                // if (collisionCount == 1)
                // {
                for (int j = 0; j < ScreenManager.collisionGroups.Count; j++)
                //if you collide with it see if it has a collision group and if so that is your collisiong roup
                //foreach (List<int> list in ScreenManager.collisionGroups)
                {
                    if (ScreenManager.collisionGroups[j].Contains(99))
                    {
                        foundThisIndex = true;
                        colGroupIndex = j;
                        break;
                    }
                }
                if (!foundThisIndex)
                {
                    ScreenManager.collisionGroups.Add(new List<int>());
                    ScreenManager.collisionGroups[ScreenManager.collisionGroups.Count - 1].Add(index);
                    colGroupIndex = ScreenManager.collisionGroups.Count - 1;
                    foundThisIndex = true;
                }
                //}
                //add the 
                foundThisIndex = false;
                if (!ScreenManager.collisionGroups[colGroupIndex].Contains(i))
                    ScreenManager.collisionGroups[colGroupIndex].Add(i);


            }
            for (int i = 0; i < ScreenManager.dummies.Count; i++)
                if (collisionS[1].BS.Contains(ScreenManager.dummies[i].collisionS[1].BS) != ContainmentType.Disjoint)
                {

                    if (isFighter)
                    {
                        if (i != index)
                        {
                            collisionCount++;
                            //   if (collisionCount == 1)
                            //{
                            for (int j = 0; j < ScreenManager.collisionGroups.Count; j++)
                            {
                                if (ScreenManager.collisionGroups[j].Contains(i))
                                {
                                    foundThisIndex = true;
                                    colGroupIndex = j;
                                    break;
                                }
                            }
                            if (!foundThisIndex)
                            {
                                ScreenManager.collisionGroups.Add(new List<int>());
                                ScreenManager.collisionGroups[ScreenManager.collisionGroups.Count - 1].Add(fighterIndex);
                                colGroupIndex = ScreenManager.collisionGroups.Count - 1;
                                foundThisIndex = true;
                            }
                            // }
                            //add the 
                            if (!ScreenManager.collisionGroups[colGroupIndex].Contains(i))
                                ScreenManager.collisionGroups[colGroupIndex].Add(i);
                        }
                    }
                        if (isRunner)
                        
                            {
                                collisionCount++;
                                //   if (collisionCount == 1)
                                //{
                                for (int j = 0; j < ScreenManager.collisionGroups.Count; j++)
                                {
                                    if (ScreenManager.collisionGroups[j].Contains(i))
                                    {
                                        foundThisIndex = true;
                                        colGroupIndex = j;
                                        break;
                                    }
                                }
                                if (!foundThisIndex)
                                {
                                    ScreenManager.collisionGroups.Add(new List<int>());
                                    ScreenManager.collisionGroups[ScreenManager.collisionGroups.Count - 1].Add(fighterIndex);
                                    colGroupIndex = ScreenManager.collisionGroups.Count - 1;
                                    foundThisIndex = true;
                                }
                                // }
                                //add the 
                                if (!ScreenManager.collisionGroups[colGroupIndex].Contains(i))
                                    ScreenManager.collisionGroups[colGroupIndex].Add(i);


                            }

                        }
                    
                

            for (int i = 0; i < ScreenManager.runners.Count; i++)
            {
                int fIndex = ScreenManager.runners[i].fighterIndex;
                if(isRunner)
                {
                    if (collisionS[1].BS.Contains(ScreenManager.runners[i].collisionS[1].BS) != ContainmentType.Disjoint)
                    {
                        //index2 = fighterIndex + 100;

                        if (fIndex != fighterIndex)
                        {
                            collisionCount++;
                            //   if (collisionCount == 1)
                            //{
                            for (int j = 0; j < ScreenManager.collisionGroups.Count; j++)
                            {
                                if (ScreenManager.collisionGroups[j].Contains(fIndex + 100))
                                {
                                    foundThisIndex = true;
                                    colGroupIndex = j;
                                    break;
                                }
                            }
                            if (!foundThisIndex)
                            {
                                ScreenManager.collisionGroups.Add(new List<int>());
                                ScreenManager.collisionGroups[ScreenManager.collisionGroups.Count - 1].Add(fighterIndex + 100);
                                colGroupIndex = ScreenManager.collisionGroups.Count - 1;
                                foundThisIndex = true;
                            }
                            // }
                            //add the 
                            if (!ScreenManager.collisionGroups[colGroupIndex].Contains(i + 100))
                                ScreenManager.collisionGroups[colGroupIndex].Add(i + 100);

                        }
                    }
                }
                if (isFighter)
                {
                    if (collisionS[1].BS.Contains(ScreenManager.runners[i].collisionS[1].BS) != ContainmentType.Disjoint)
                    {
                        //index2 = fighterIndex + 100;

                       // if (fIndex != fighterIndex)
                        {
                            collisionCount++;
                            //   if (collisionCount == 1)
                            //{
                            for (int j = 0; j < ScreenManager.collisionGroups.Count; j++)
                            {
                                if (ScreenManager.collisionGroups[j].Contains(fIndex))
                                {
                                    foundThisIndex = true;
                                    colGroupIndex = j;
                                    break;
                                }
                            }
                            if (!foundThisIndex)
                            {
                                ScreenManager.collisionGroups.Add(new List<int>());
                                ScreenManager.collisionGroups[ScreenManager.collisionGroups.Count - 1].Add(fighterIndex + 100);
                                colGroupIndex = ScreenManager.collisionGroups.Count - 1;
                                foundThisIndex = true;
                            }
                            // }
                            //add the 
                            if (!ScreenManager.collisionGroups[colGroupIndex].Contains(fIndex))
                                ScreenManager.collisionGroups[colGroupIndex].Add(fIndex);

                        }
                    }
                }
            }


            assignedColGroup = colGroupIndex;
            // if (collisionCount > 2)
            //  collisionCount = collisionCount + 1 -1;
        }
        public void getCollisions()
        {
            if (fighterIndex == 15)
                Console.WriteLine("p");
            collisionCount = 0;
            bool foundThisIndex = false;
            int colGroupIndex = 0;
            bool colGroupFound = false;
            int checkFighterIndex = 0;
            if (isRunner)
                checkFighterIndex = fighterIndex;
            else if (isFighter)
                checkFighterIndex = fighterIndex;
            //check to see if fighterIndex is already in a collision group
            for(int i = 0; i<ScreenManager.collisionGroups.Count; i++)
            {
                if (ScreenManager.collisionGroups[i].Contains(fighterIndex))
                {
                    colGroupIndex = i;
                    colGroupFound = true;
                }
                


            }
            if (!colGroupFound)
            {


            }
            if (collisionS[1].BS.Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
            {
                int i = 99;
                collisionCount++;
               // if (collisionCount == 1)
               // {
                    for (int j = 0; j < ScreenManager.collisionGroups.Count; j++)
                        //if you collide with it see if it has a collision group and if so that is your collisiong roup
                    //foreach (List<int> list in ScreenManager.collisionGroups)
                    {
                        if (ScreenManager.collisionGroups[j].Contains(99))
                        {
                            foundThisIndex = true;
                            colGroupIndex = j;
                            break;
                        }
                    }
                    if (!foundThisIndex)
                    {
                        ScreenManager.collisionGroups.Add(new List<int>());
                        ScreenManager.collisionGroups[ScreenManager.collisionGroups.Count - 1].Add(fighterIndex);
                        colGroupIndex = ScreenManager.collisionGroups.Count - 1;
                        foundThisIndex = true;
                    }
                //}
                //add the 
                    foundThisIndex = false;
                if (!ScreenManager.collisionGroups[colGroupIndex].Contains(i))
                    ScreenManager.collisionGroups[colGroupIndex].Add(i);


            }
            for (int i = 0; i < ScreenManager.dummies.Count; i++)
                if (collisionS[1].BS.Contains(ScreenManager.dummies[i].collisionS[1].BS) != ContainmentType.Disjoint)
                {
                    if (i != fighterIndex)
                    {
                        collisionCount++;
                     //   if (collisionCount == 1)
                        //{
                            for (int j = 0; j < ScreenManager.collisionGroups.Count; j++)
                            {
                                if (ScreenManager.collisionGroups[j].Contains(i))
                                {
                                    foundThisIndex = true;
                                    colGroupIndex = j;
                                    break;
                                }
                            }
                            if (!foundThisIndex)
                            {
                                ScreenManager.collisionGroups.Add(new List<int>());
                                ScreenManager.collisionGroups[ScreenManager.collisionGroups.Count-1].Add(fighterIndex);
                                colGroupIndex = ScreenManager.collisionGroups.Count - 1;
                                foundThisIndex = true;
                            }
                       // }
                        //add the 
                        if(!ScreenManager.collisionGroups[colGroupIndex].Contains(i))
                        ScreenManager.collisionGroups[colGroupIndex].Add(i);

                    }
                }

            assignedColGroup = colGroupIndex;
           // if (collisionCount > 2)
              //  collisionCount = collisionCount + 1 -1;
        }

        public void checkMove3(GameTime gameTime)
        {
            float rotationAmount = 0.0f;
            Vector3 sepDirection = Vector3.Zero;
            bool safeMove = false;
            float checkLeft = 0.0f;
            float checkRight = 0.0f;
            bool goLeft = false;
            bool goRight = false;
            getCollisions4();

            if (Position.X < 0)
                Position = new Vector3(0.1f, Position.Y, Position.Z);
            if (Position.Z < 0)
                Position = new Vector3(Position.X, Position.Y, 0.1f);
            if (Position.X >1200)
                Position = new Vector3(1199.0f, Position.Y, Position.Z);
            if (Position.Z > 1200)
                Position = new Vector3(Position.X, Position.Y, 1199.0f);

            if (collisionCount > 0)
            {
                if(moveState !=1)
                position = oldPosition;
                collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
                int check = ScreenManager.collisionGroups[assignedColGroup][0];
                if (check >= 100)
                    check -= 100;
                if((ScreenManager.collisionGroups[assignedColGroup][0] == fighterIndex )
                    )
                
                {
                   
                    moveState = 1;

                    Matrix sepWorld = Matrix.Identity;
                    sepWorld.Up =Vector3.Up;
                    rotationAmount = TurnToFace(Position, moveSpheres[targetI][targetJ].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    float x = (float)Math.Sin(rotationAmount);
                    float y = (float)Math.Cos(rotationAmount);
                    sepDirection = new Vector3(x, 0.0f, y);
                    sepWorld.Forward = sepDirection;
                    sepWorld.Left = Vector3.Cross(sepWorld.Forward, Vector3.Up);
                    checkLeft =Vector3.Distance(sepDirection, world.Left);
                    checkRight = Vector3.Distance(sepDirection, world.Right);
                    
                    //sepDirection.Normalize();

                    for (int j = 0; j < ScreenManager.collisionGroups[assignedColGroup].Count; j++)
                    {
                        if (fighterIndex != ScreenManager.collisionGroups[assignedColGroup][j])// ||
                        //(isRunner && fighterIndex != ScreenManager.collisionGroups[assignedColGroup][j]))
                        {
                            if (ScreenManager.collisionGroups[assignedColGroup][j] < 99)
                            {
                                rotationAmount = TurnToFace(Position, ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                                 x = (float)Math.Sin(rotationAmount);
                                 y = (float)Math.Cos(rotationAmount);
                                sepDirection = new Vector3(x, 0.0f, y);

                                checkLeft = Vector3.Distance(sepDirection, world.Left);
                                checkRight = Vector3.Distance(sepDirection, world.Right);
                                if (checkLeft < checkRight)
                                    ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].outOfWayPos = ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].position + world.Left * 25.6f;
                                else
                                    ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].outOfWayPos = ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].position + world.Right * 25.6f;
                               // ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].position = ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].oldPosition;
                                ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].mSphereIndex = ScreenManager.collisionGroups[assignedColGroup][0];
                                ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].moveState = 5;
                                ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].waitTime = TimeSpan.FromSeconds(1.0);
                              //   ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].outofWayPos =  ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].position +       
                            }
                            else if(ScreenManager.collisionGroups[assignedColGroup][j] > 99)
                            {
                             //   ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j] - 100].position = ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j] - 100].oldPosition;
                                ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j] - 100].moveState = 3;
                                ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j] - 100].waitTime = TimeSpan.FromSeconds(1.0);
                            }
                        }
    //                    if (ScreenManager.collisionGroups[assignedColGroup][j] >= 100)
    //                        rotationAmount = TurnToFace(Position, ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j] - 100].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
    //                    else
    //                        rotationAmount = TurnToFace(Position, ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
    //                    x = (float)Math.Sin(rotationAmount);
    //                    y = (float)Math.Cos(rotationAmount);
    //                    sepDirection = new Vector3(x, 0.0f, y);
    //                    if (fighterIndex != ScreenManager.collisionGroups[assignedColGroup][j] &&
    //ScreenManager.collisionGroups[assignedColGroup][j] < 99)
    //                        while (collisionS[1].BS.Contains(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].collisionS[1].BS) != ContainmentType.Disjoint)
    //                        {
    //                            //ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].Position += sepDirection * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;
    //                            //ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].collisionS[1].BS = new BoundingSphere(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
    //                            position -= sepDirection * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;
    //                            collisionS[1].BS = new BoundingSphere(position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);

    //                        }
    //                    else if (fighterIndex != ScreenManager.collisionGroups[assignedColGroup][j] &&
    //                        ScreenManager.collisionGroups[assignedColGroup][j] > 99)
    //                        while (collisionS[1].BS.Contains(ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j] - 100].collisionS[1].BS) != ContainmentType.Disjoint)
    //                        {
    //                            //ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j] - 100].Position += sepDirection * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;
    //                            //ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j] - 100].collisionS[1].BS = new BoundingSphere(ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j] - 100].Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
    //                            position -= sepDirection * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;
    //                            collisionS[1].BS = new BoundingSphere(position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
    //                        }

                       
                    }
                   /* for (int j = 0; j < ScreenManager.collisionGroups[assignedColGroup].Count; j++)
                    {
                        if (ScreenManager.collisionGroups[assignedColGroup][j] != 99)
                        {
                            if(fighterIndex!=ScreenManager.collisionGroups[assignedColGroup][j])// ||
                                //(isRunner && fighterIndex != ScreenManager.collisionGroups[assignedColGroup][j]))
                            {
                                if (ScreenManager.collisionGroups[assignedColGroup][j] < 100)
                                {
                                    ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].moveState = 3;
                                    ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].waitTime = TimeSpan.FromSeconds(1.0);
                                }
                                else
                                {
                                    ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j]-100].moveState = 3;
                                    ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j]-100].waitTime = TimeSpan.FromSeconds(1.0);
                                }
                            }
                            if(ScreenManager.collisionGroups[assignedColGroup][j] >= 100)
                                rotationAmount = TurnToFace(Position, ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j] - 100].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                            else
                            rotationAmount = TurnToFace(Position, ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                            x = (float)Math.Sin(rotationAmount);
                            y = (float)Math.Cos(rotationAmount);
                            sepDirection = new Vector3(x, 0.0f, y);

                            //checkLeft = Vector3.Distance(sepDirection, world.Left);
                            //checkRight = Vector3.Distance(sepDirection, world.Right);
                            //if (checkLeft < checkRight)
                            //    sepDirection = world.Left;
                            //else
                            //    sepDirection = world.Right;
                        }

                            if(fighterIndex !=ScreenManager.collisionGroups[assignedColGroup][j] &&
                                ScreenManager.collisionGroups[assignedColGroup][j] < 99)
                                while (collisionS[1].BS.Contains(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].collisionS[1].BS) != ContainmentType.Disjoint)
                                {
                                    //ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].Position += sepDirection * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;
                                    //ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].collisionS[1].BS = new BoundingSphere(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
                                    position -= sepDirection * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;
                                    collisionS[1].BS = new BoundingSphere(position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);

                                }
                            else if(fighterIndex !=ScreenManager.collisionGroups[assignedColGroup][j] &&
                                ScreenManager.collisionGroups[assignedColGroup][j] > 99)
                                while (collisionS[1].BS.Contains(ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j]-100].collisionS[1].BS) != ContainmentType.Disjoint)
                                {
                                    //ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j] - 100].Position += sepDirection * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;
                                    //ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j] - 100].collisionS[1].BS = new BoundingSphere(ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j] - 100].Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
                                    position -= sepDirection * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;
                                    collisionS[1].BS = new BoundingSphere(position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
                                }

        //                if (isFighter && fighterIndex != ScreenManager.collisionGroups[assignedColGroup][j]
        //&& ScreenManager.collisionGroups[assignedColGroup][j] != 99 && ScreenManager.collisionGroups[assignedColGroup][j] < 100)
        //                {
        //                    while (collisionS[1].BS.Contains(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].collisionS[1].BS) != ContainmentType.Disjoint)
        //                    {
        //                        ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].Position += sepDirection * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;
        //                             ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].collisionS[1].BS = new BoundingSphere(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
                                
        //                    }

        //                    //ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].moveState = 2;
        //                }
        //                else if(isRunner && fighterIndex != ScreenManager.collisionGroups[assignedColGroup][j]
        //&& ScreenManager.collisionGroups[assignedColGroup][j] != 99)
        //                {
        //                    while (collisionS[1].BS.Contains(ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j]-100].collisionS[1].BS) != ContainmentType.Disjoint)
        //                    {
        //                    ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j]-100].Position += sepDirection * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;
        //                    ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j]-100].collisionS[1].BS = new BoundingSphere(ScreenManager.runners[ScreenManager.collisionGroups[assignedColGroup][j]-100].Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
        //                    }

        //                }
                        else if (ScreenManager.collisionGroups[assignedColGroup][j] == 99)
                        {
                           // Position = oldPosition;
                            //while (collisionS[1].BS.Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                            //{
                            //    //Position -= sepDirection * (float)gameTime.ElapsedGameTime.TotalSeconds * 101 * 1.0f;
                            //    //collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
                            //    Position = oldPosition;
                            //}
                        }
                    }*/
                   // ScreenManager.collisionGroups[0].RemoveAt(0);
                }

                // }
                //else
                //{
                //    position = oldPosition;
                //    setSpheres.Clear();
                //}
            }
            else
            {
                // if(setSpheres.Count==0)
               // moveState = 0;
                //setSpheres.Clear();
            }
            //collisionCount = 0;
            //List<int> collisionIndices = new List<int>();
            //for (int i = 0; i < ScreenManager.dummies.Count; i++)
            //    {
            //        if (i != fighterIndex)
            //            {
            //                if (ScreenManager.dummies[i].collisionS[1].BS.Contains(collisionS[1].BS) != ContainmentType.Disjoint)
            //                    {
            //                        collisionCount++;
            //                        collisionIndices.Add(i);
            //                    }

            //            }
            //    }
            //if (collisionCount > 0)
            //{
            //    Position = oldPosition;
            //    moveState = 1;
            //}



        }
        public void checkMove2(GameTime gameTime)
        {
            float rotationAmount = 0.0f;
            Vector3 sepDirection = Vector3.Zero;
            bool safeMove = false;
            getCollisions();
            if (collisionCount > 0)
            {
                moveState = 1;
                Position = oldPosition;


                for (int i = 1; i < 3; i++)
                {
                    for (int j = 1; j < 3; j++)
                    {
                        if (open[i][j])
                        {
                            targetI = i;
                            targetJ = j;
                            safeMove = true;
                            break;
                        }

                    }
                    if (safeMove)
                        break;
                }


                if (safeMove)
                {

                    rotationAmount = TurnToFace(Position, moveSpheres[targetI][targetJ].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    float x = (float)Math.Sin(rotationAmount);
                    float y = (float)Math.Cos(rotationAmount);
                    sepDirection = new Vector3(x, 0.0f, y);
                    //sepDirection.Normalize();

                    for (int j = 0; j < ScreenManager.collisionGroups[assignedColGroup].Count; j++)
                    {
                        if (fighterIndex != ScreenManager.collisionGroups[assignedColGroup][j]
        && ScreenManager.collisionGroups[assignedColGroup][j] != 99)
                        {
                            while (collisionS[1].BS.Contains(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].collisionS[1].BS) != ContainmentType.Disjoint)
                            {
                                Position += sepDirection * (float)gameTime.ElapsedGameTime.TotalSeconds * 101 * 1.0f;
                                collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);

                            }

                        }
                        else if (ScreenManager.collisionGroups[assignedColGroup][j] == 99)
                        {
                            while (collisionS[1].BS.Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                            {
                                Position += sepDirection * (float)gameTime.ElapsedGameTime.TotalSeconds * 101 * 1.0f;
                                collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);

                            }
                        }
                    }

                }
                else
                {
                    position = oldPosition;
                    setSpheres.Clear();
                }
                
            }
            else
            {
                // if(setSpheres.Count==0)
                moveState = 0;
                //setSpheres.Clear();
            }
            //collisionCount = 0;
            //List<int> collisionIndices = new List<int>();
            //for (int i = 0; i < ScreenManager.dummies.Count; i++)
            //    {
            //        if (i != fighterIndex)
            //            {
            //                if (ScreenManager.dummies[i].collisionS[1].BS.Contains(collisionS[1].BS) != ContainmentType.Disjoint)
            //                    {
            //                        collisionCount++;
            //                        collisionIndices.Add(i);
            //                    }

            //            }
            //    }
            //if (collisionCount > 0)
            //{
            //    Position = oldPosition;
            //    moveState = 1;
            //}



        }
        public void UpdateAIRunner2(GameTime gameTIme)
        {
            float rotationAmount = 0.0f;
            float dToRest = 0.0f;
            oldPosition = position;
            cullSphere = new BoundingSphere(position + new Vector3(0.0f, 70.0f, 0.0f), 204.8f);
            List<int> unculledDummies = new List<int>();
            List<int> unculledRunners = new List<int>();

            for (int i2 = 0; i2 < 5; i2++)
                for (int j2 = 0; j2 < 5; j2++)
                {
                    moveSpheres[i2][j2] = new BoundingSphere(position - new Vector3(102.4f - 51.2f * (float)(i2), -70.0f, 102.4f - 51.2f * (float)(j2)), 25.6f);
                    // moveSpheres[i2][j2] = new BoundingSphere(position - new Vector3(51.2f - 25.6f * (float)(i2), -70.0f, 51.2f - 25.6f * (float)(j2)), 12.8f);
                }
            for (int i = 0; i < ScreenManager.dummies.Count; i++)
            {
                //if (i != fighterIndex)
                {

                    if (cullSphere.Contains(ScreenManager.dummies[i].collisionS[1].BS) != ContainmentType.Disjoint)
                    {
                        unculledDummies.Add(i);

                    }
                }
            }
            for (int i = 0; i < ScreenManager.runners.Count; i++)
            {
                if (i != fighterIndex)
                {
                    if (cullSphere.Contains(ScreenManager.runners[i].collisionS[1].BS) != ContainmentType.Disjoint)
                    {
                        unculledRunners.Add(i);

                    }


                }
                
            }



        }

        public void UpdateAIMonster2(GameTime gameTime)
        {
            if (fighterIndex == 13)
                Console.WriteLine("#");
            futureMovement.Clear();
            float rotationAmount = 0.0f;
            float dToP = 0.0f;
            float dToS = 0.0f;
            float dToT = 0.0f;
            oldPosition = position;
            cullSphere = new BoundingSphere(position + new Vector3(0.0f, 70.0f, 0.0f), 204.8f);
            List<int> unculledDummies = new List<int>();
            if (health > 0)
            {
                for (int i2 = 0; i2 < 5; i2++)
                    for (int j2 = 0; j2 < 5; j2++)
                    {
                        moveSpheres[i2][j2] = new BoundingSphere(position - new Vector3(102.4f - 51.2f * (float)(i2), -70.0f, 102.4f - 51.2f * (float)(j2)), 25.6f);
                        // moveSpheres[i2][j2] = new BoundingSphere(position - new Vector3(51.2f - 25.6f * (float)(i2), -70.0f, 51.2f - 25.6f * (float)(j2)), 12.8f);
                    }
                for (int i = 0; i < ScreenManager.dummies.Count; i++)
                {
                    if (i != fighterIndex)
                    {

                        if (cullSphere.Contains(ScreenManager.dummies[i].collisionS[1].BS) != ContainmentType.Disjoint)
                        {
                            unculledDummies.Add(i);

                        }
                    }
                }
                for (int i = 0; i < unculledDummies.Count; i++)
                    if (setSpheres.Count == 1)
                    {
                        if (setSpheres[0].Contains(ScreenManager.dummies[unculledDummies[i]].collisionS[1].BS) != ContainmentType.Disjoint)
                        {
                            setSpheres.Clear();
                            havePlannedPosition = false;
                        }

                    }
                if (setSpheres.Count == 1)
                    if (setSpheres[0].Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                    {
                        setSpheres.Clear();
                        havePlannedPosition = false;
                    }
                for (int i = 0; i < 5; i++)
                    for (int j = 0; j < 5; j++)
                    {
                        open[i][j] = true;
                        for (int a = 0; a < ScreenManager.runners.Count; a++)

                            if (moveSpheres[i][j].Contains(ScreenManager.runners[a].collisionS[1].BS) != ContainmentType.Disjoint)
                                open[i][j] = false;
                        if (moveSpheres[i][j].Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                            open[i][j] = false;
                        if (moveSpheres[i][j].Center.X < 0 || moveSpheres[i][j].Center.X > 1200 ||
          moveSpheres[i][j].Center.Z < 0 || moveSpheres[i][j].Center.Z > 1200)
                        {
                            open[i][j] = false;
                            //break
                        }
                        for (int k = 0; k < unculledDummies.Count; k++)
                        {
                            if (moveSpheres[i][j].Contains(ScreenManager.dummies[unculledDummies[k]].collisionS[1].BS) != ContainmentType.Disjoint)
                            {
                                open[i][j] = false;
                                // break;
                            }
                            for (int m = 0; m < ScreenManager.dummies[k].setSpheres.Count && m < 1; m++)
                            {
                                if (moveSpheres[i][j].Contains(ScreenManager.dummies[k].setSpheres[m]) != ContainmentType.Disjoint)
                                {
                                    open[i][j] = false;
                                    //break;
                                }
                            }
                        }
                    }
                float checkDistance = 0.0f;
                float targetDistance = 400.0f;
                if (!hasTarget)
                {
                    for (int i = 0; i < ScreenManager.runners.Count; i++)
                    {
                        checkDistance = Vector3.Distance(position, ScreenManager.runners[i].Position);


                        if (checkDistance < 400.0f)
                        {
                            hasTarget = true;


                            if (checkDistance < targetDistance)
                            {
                                targetIndex = i;
                                targetDistance = checkDistance;


                            }


                        }


                    }
                }
                if (hasTarget)
                {
                    dToT = Vector3.Distance(position, ScreenManager.runners[targetIndex].Position);
                    if (dToT < 55)
                    {
                        rotationAmount = TurnToFace(position, ScreenManager.runners[targetIndex].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                        if (!isAtk1)
                        {
                            isAtk1 = true;
                            justBones.CopyTo(previousAnimation, 0);
                        }
                        thrustAmount = 0.0f;
                        isRun = false;



                    }
                    rotationAmount = TurnToFace(position, ScreenManager.runners[targetIndex].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                        plannedPosition = ScreenManager.runners[targetIndex].Position;
                    //else if (dToT < 200)
                    //{
                    //    plannedPosition = ScreenManager.Theseus.Position;
                    //    havePlannedPosition = true;


                    //}
                }
                else if (!havePlannedPosition)
                {
                    int i = 0;
                    int j = 0;
                    int randomNumber = ScreenManager.rand.Next(25);

                    int counter = 0;
                    for (int i2 = 0; i2 < 5; i2++)
                    {
                        for (int j2 = 0; j2 < 5; j2++)
                        {
                            if (counter == randomNumber)
                            {
                                // i = i2;
                                //  j = j2;
                                break;
                            }

                            if (open[i2][j2])
                            {
                                i = i2;
                                j = j2;
                                counter++;
                            }

                        }
                        if (counter == randomNumber)
                            break;
                    }
                    plannedPosition = moveSpheres[i][j].Center - new Vector3(0.0f, 70.0f, 0.0f);
                    havePlannedPosition = true;
                }

                if (moveState == 0 & !isAtk1)
                {
                    dToT = Vector3.Distance(position, Vector3.Zero);
                    dToP = Vector3.Distance(position, plannedPosition);
                    rotationAmount = TurnToFace(position, plannedPosition, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    //if (dToT < 60)
                    //{
                    //    rotationAmount = TurnToFace(position, ScreenManager.Theseus.Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    //    if (!isAtk1)
                    //    {
                    //        isAtk1 = true;
                    //        justBones.CopyTo(previousAnimation, 0);
                    //    }
                    //    thrustAmount = 0.0f;
                    //    isRun = false;



                    //}

                    if (dToP < 10)
                    {
                        havePlannedPosition = false;
                        setSpheres.Clear();
                    }
                    else
                    {
                        thrustAmount = 1.0f;
                        if (!isRun)
                        {
                            isRun = true;
                            justBones.CopyTo(previousAnimation, 0);
                        }

                    }
                }
                else if (moveState == 1 & !isAtk1)
                {
                    dToT = Vector3.Distance(position, Vector3.Zero);
                    dToP = Vector3.Distance(position, plannedPosition);
                    if (dToT < 60)
                    {
                        moveState = 0;
                    }
                    else
                    {
                        if (dToP < 10)
                        {
                            havePlannedPosition = false;
                            setSpheres.Clear();
                            moveState = 0;
                        }

                        if (setSpheres.Count > 0)
                        {
                            dToS = Vector3.Distance(position + new Vector3(0.0f, 70.0f, 0.0f), setSpheres[0].Center);
                            if (dToS > 10)
                            {
                                thrustAmount = 1.0f;
                                if (!isRun)
                                {
                                    isRun = true;
                                    justBones.CopyTo(previousAnimation, 0);
                                }
                            }
                            else
                            {
                                setSpheres.RemoveAt(0);
                                if (setSpheres.Count == 0)
                                {
                                    havePlannedPosition = false;
                                    moveState = 0;
                                }
                            }
                        }
                        else
                        {
                            isRun = false;
                            thrustAmount = 0.0f;
                        }

                        if (havePlannedPosition)
                        {

                            if (setSpheres.Count == 0)
                            {
                                miniPathSet = false;

                                int thisI = 0;
                                int thisJ = 0;
                                //were being used so that the first setshpere was valid
                                //int startI = 0;
                                //int startJ = 0;
                                float lowest = 99999999;
                                float check = 0;
                                for (int i = 0; i < 5; i++)
                                    for (int j = 0; j < 5; j++)
                                    {
                                        if (open[i][j])
                                        {
                                            check = Vector3.Distance(moveSpheres[i][j].Center, plannedPosition);
                                            if (check < lowest)
                                            {
                                                thisI = i;
                                                thisJ = j;
                                                lowest = check;
                                            }
                                        }
                                    }
                                if (open[2][2] == false)
                                {
                                    for (int i = 1; i < 3; i++)
                                    {
                                        for (int j = 1; j < 3; j++)
                                        {
                                            if (open[i][j])
                                            {

                                            }
                                        }
                                    }

                                }


                                Reset(new Point(2, 2), new Point(thisI, thisJ));
                                JsearchStatus = JSearchStatus.Searching;

                                while (JsearchStatus == JSearchStatus.Searching)
                                {

                                    DoSearchStep();
                                }

                                if (myJSearchStatus == JSearchStatus.PathFound)
                                {
                                    //just to get to first point
                                    moveState = 1;
                                    foreach (Point point in FinalPath())
                                    {
                                        setSpheres.Add(moveSpheres[point.X][point.Y]);
                                    }
                                    if (setSpheres.Count == 1)
                                    {
                                        setSpheres.Clear();
                                        moveState = 0;
                                    }
                                }
                                if (myJSearchStatus == JSearchStatus.NoPath)
                                {
                                    moveState = 0;
                                    havePlannedPosition = false;
                                    setSpheres.Clear();

                                }

                                if (!miniPathSet)
                                {
                                    miniPathSet = true;
                                }

                            }

                        }
                        else if (!havePlannedPosition)
                        {
                            aiDecisionTimer += gameTime.ElapsedGameTime;
                            isRun = false;
                            thrustAmount = 0.0f;
                            runTime = TimeSpan.Zero;
                            double split = rand.NextDouble();
                            cutOffTime = cutOffTime = TimeSpan.FromMilliseconds(maxDecisionTimer.TotalMilliseconds * split);
                            if (cutOffTime < minDecisionTimer)
                                cutOffTime = minDecisionTimer;

                            if (aiDecisionTimer > cutOffTime)
                            {
                                havePlannedPosition = false;
                                aiDecisionTimer = TimeSpan.Zero;
                            }



                        }

                        if (setSpheres.Count > 0)
                            rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    }



                }
                if (moveState == 3 & !isAtk1)
                {
                    waitTime -= gameTime.ElapsedGameTime;

                    if (waitTime < TimeSpan.Zero)
                    {
                        moveState = 0;
                        waitTime = TimeSpan.Zero;
                    }

                    isRun = false;
                    thrustAmount = 0.0f;


                }
            }
            else
            {
                if (!isDead)
                {
                    isDead = true;
                    justBones.CopyTo(previousAnimation, 0);
                    isRun = false;
                    thrustAmount = 0.0f;
                    currentAnimationTime = TimeSpan.Zero;




                }




            }
            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);
            if (isRun)
                Position += Direction * thrustAmount * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;

            if (isRun)
                updateRun(gameTime);
            if (isAtk1)
                UpdateBasic1(gameTime);
            else if (isAtk2)
                UpdateBasic2(gameTime);
            else if (isAtk3)
                UpdateBasic3(gameTime);
            else if (isHammerFlight)
                UpdateHammerFlight(gameTime);
            else if (isDead)
                UpdateDead(gameTime);
            else if (isKnockBack)
                UpdateKnockBack(gameTime);
            else if (isKnockDown)
                updateKnockDown(gameTime);

            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1 || isAtk2 || isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockDown)
                upperBones.CopyTo(justBones, 0);
            else if (isHammerFlight)
                upperBones.CopyTo(justBones, 0);
            else if (isDead)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;

            for (int i = 0; i < 2; i++)
            {
                futureMovement.Add(new BoundingSphere((Position + new Vector3(0.0f, 70.0f, 0.0f)) + Direction * 51.2f *
                                   (i + 1), collisionS[1].BS.Radius));


            }
            collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            checkMove3(gameTime);


        }

        public void UpdateAIRunner(GameTime gameTime)
        {
            if (fighterIndex == 13)
                Console.WriteLine("#");
            futureMovement.Clear();
            float rotationAmount = 0.0f;
            float dToP = 0.0f;
            float dToS = 0.0f;
            float dToT = 0.0f;
            float dToB = 0.0f;
            oldPosition = position;
            cullSphere = new BoundingSphere(position + new Vector3(0.0f, 70.0f, 0.0f), 204.8f);
            List<int> unculledDummies = new List<int>();
            if (health > 0)
            {
                for (int i2 = 0; i2 < 5; i2++)
                    for (int j2 = 0; j2 < 5; j2++)
                    {
                        moveSpheres[i2][j2] = new BoundingSphere(position - new Vector3(102.4f - 51.2f * (float)(i2), -70.0f, 102.4f - 51.2f * (float)(j2)), 25.6f);
                        // moveSpheres[i2][j2] = new BoundingSphere(position - new Vector3(51.2f - 25.6f * (float)(i2), -70.0f, 51.2f - 25.6f * (float)(j2)), 12.8f);
                    }
                for (int i = 0; i < ScreenManager.dummies.Count; i++)
                {
                    if (i != fighterIndex)
                    {

                        if (cullSphere.Contains(ScreenManager.dummies[i].collisionS[1].BS) != ContainmentType.Disjoint)
                        {
                            unculledDummies.Add(i);

                        }
                    }
                }
                for (int i = 0; i < unculledDummies.Count; i++)
                    if (setSpheres.Count == 1)
                    {
                        if (setSpheres[0].Contains(ScreenManager.dummies[unculledDummies[i]].collisionS[1].BS) != ContainmentType.Disjoint)
                        {
                            setSpheres.Clear();
                            havePlannedPosition = false;
                        }

                    }
                if (setSpheres.Count == 1)
                    if (setSpheres[0].Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                    {
                        setSpheres.Clear();
                        havePlannedPosition = false;
                    }
                for (int i = 0; i < 5; i++)
                    for (int j = 0; j < 5; j++)
                    {
                        open[i][j] = true;
                        for (int a = 0; a < ScreenManager.runners.Count; a++)

                            if (moveSpheres[i][j].Contains(ScreenManager.runners[a].collisionS[1].BS) != ContainmentType.Disjoint)
                                open[i][j] = false;
                        if (moveSpheres[i][j].Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                            open[i][j] = false;
                        if (moveSpheres[i][j].Center.X < 0 || moveSpheres[i][j].Center.X > 1200 ||
          moveSpheres[i][j].Center.Z < 0 || moveSpheres[i][j].Center.Z > 1200)
                        {
                            open[i][j] = false;
                            //break
                        }
                        for (int k = 0; k < unculledDummies.Count; k++)
                        {
                            if (moveSpheres[i][j].Contains(ScreenManager.dummies[unculledDummies[k]].collisionS[1].BS) != ContainmentType.Disjoint)
                            {
                                open[i][j] = false;
                                // break;
                            }
                            for (int m = 0; m < ScreenManager.dummies[k].setSpheres.Count && m < 1; m++)
                            {
                                if (moveSpheres[i][j].Contains(ScreenManager.dummies[k].setSpheres[m]) != ContainmentType.Disjoint)
                                {
                                    open[i][j] = false;
                                    //break;
                                }
                            }
                        }
                    }

                dToB = Vector3.Distance(position, Vector3.Zero);
                dToT = Vector3.Distance(position, ScreenManager.Theseus.Position);
                if (dToB < 200)
                {
                    runToBase = true;
                    rotationAmount = TurnToFace(position, Vector3.Zero, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    plannedPosition = Vector3.Zero;
                    //if (!isAtk1)
                    //{
                    //    isAtk1 = true;
                    //    justBones.CopyTo(previousAnimation, 0);
                    //}
                    thrustAmount = 0.0f;
                    isRun = false;

                    //atBase = true;
                    baseTime += gameTime.ElapsedGameTime;


                }
                 else if (dToT < 200)
                {
                    followTheseus = true;
                    plannedPosition = ScreenManager.Theseus.Position;
                    havePlannedPosition = true;


                }
                havePlannedPosition = true;
                plannedPosition = Vector3.Zero;
                if (!havePlannedPosition)
                {
                    int i = 0;
                    int j = 0;
                    int randomNumber = ScreenManager.rand.Next(25);

                    int counter = 0;
                    for (int i2 = 0; i2 < 5; i2++)
                    {
                        for (int j2 = 0; j2 < 5; j2++)
                        {
                            if (counter == randomNumber)
                            {
                                // i = i2;
                                //  j = j2;
                                break;
                            }

                            if (open[i2][j2])
                            {
                                i = i2;
                                j = j2;
                                counter++;
                            }

                        }
                        if (counter == randomNumber)
                            break;
                    }
                    plannedPosition = moveSpheres[i][j].Center - new Vector3(0.0f, 70.0f, 0.0f);
                    havePlannedPosition = true;
                }

                if (moveState == 0 & !isAtk1)
                {
                    dToT = Vector3.Distance(position, Vector3.Zero);
                    dToP = Vector3.Distance(position, plannedPosition);
                    rotationAmount = TurnToFace(position, plannedPosition, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    //if (dToT < 60)
                    //{
                    //    rotationAmount = TurnToFace(position, ScreenManager.Theseus.Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    //    if (!isAtk1)
                    //    {
                    //        isAtk1 = true;
                    //        justBones.CopyTo(previousAnimation, 0);
                    //    }
                    //    thrustAmount = 0.0f;
                    //    isRun = false;



                    //}

                    if (dToP < 10)
                    {
                        havePlannedPosition = false;
                        setSpheres.Clear();
                    }
                    else
                    {
                        thrustAmount = 1.0f;
                        if (!isRun)
                        {
                            isRun = true;
                            justBones.CopyTo(previousAnimation, 0);
                        }

                    }
                }
                else if (moveState == 1 & !isAtk1)
                {
                    dToT = Vector3.Distance(position, Vector3.Zero);
                    dToP = Vector3.Distance(position, plannedPosition);
                    if (dToT < 60)
                    {
                        moveState = 0;
                    }
                    else
                    {
                        if (dToP < 10)
                        {
                            havePlannedPosition = false;
                            setSpheres.Clear();
                            moveState = 0;
                        }

                        if (setSpheres.Count > 0)
                        {
                            dToS = Vector3.Distance(position + new Vector3(0.0f, 70.0f, 0.0f), setSpheres[0].Center);
                            if (dToS > 10)
                            {
                                thrustAmount = 1.0f;
                                if (!isRun)
                                {
                                    isRun = true;
                                    justBones.CopyTo(previousAnimation, 0);
                                }
                            }
                            else
                            {
                                setSpheres.RemoveAt(0);
                                if (setSpheres.Count == 0)
                                {
                                    havePlannedPosition = false;
                                    moveState = 0;
                                }
                            }
                        }
                        else
                        {
                            isRun = false;
                            thrustAmount = 0.0f;
                        }

                        if (havePlannedPosition)
                        {

                            if (setSpheres.Count == 0)
                            {
                                miniPathSet = false;

                                int thisI = 0;
                                int thisJ = 0;
                                //were being used so that the first setshpere was valid
                                //int startI = 0;
                                //int startJ = 0;
                                float lowest = 99999999;
                                float check = 0;
                                for (int i = 0; i < 5; i++)
                                    for (int j = 0; j < 5; j++)
                                    {
                                        if (open[i][j])
                                        {
                                            check = Vector3.Distance(moveSpheres[i][j].Center, plannedPosition);
                                            if (check < lowest)
                                            {
                                                thisI = i;
                                                thisJ = j;
                                                lowest = check;
                                            }
                                        }
                                    }
                                if (open[2][2] == false)
                                {
                                    for (int i = 1; i < 3; i++)
                                    {
                                        for (int j = 1; j < 3; j++)
                                        {
                                            if (open[i][j])
                                            {

                                            }
                                        }
                                    }

                                }


                                Reset(new Point(2, 2), new Point(thisI, thisJ));
                                JsearchStatus = JSearchStatus.Searching;

                                while (JsearchStatus == JSearchStatus.Searching)
                                {

                                    DoSearchStep();
                                }

                                if (myJSearchStatus == JSearchStatus.PathFound)
                                {
                                    //just to get to first point
                                    moveState = 1;
                                    foreach (Point point in FinalPath())
                                    {
                                        setSpheres.Add(moveSpheres[point.X][point.Y]);
                                    }
                                    if (setSpheres.Count == 1)
                                    {
                                        setSpheres.Clear();
                                        moveState = 0;
                                    }
                                }
                                if (myJSearchStatus == JSearchStatus.NoPath)
                                {
                                    moveState = 0;
                                    havePlannedPosition = false;
                                    setSpheres.Clear();

                                }

                                if (!miniPathSet)
                                {
                                    miniPathSet = true;
                                }

                            }

                        }
                        else if (!havePlannedPosition)
                        {
                            aiDecisionTimer += gameTime.ElapsedGameTime;
                            isRun = false;
                            thrustAmount = 0.0f;
                            runTime = TimeSpan.Zero;
                            double split = rand.NextDouble();
                            cutOffTime = cutOffTime = TimeSpan.FromMilliseconds(maxDecisionTimer.TotalMilliseconds * split);
                            if (cutOffTime < minDecisionTimer)
                                cutOffTime = minDecisionTimer;

                            if (aiDecisionTimer > cutOffTime)
                            {
                                havePlannedPosition = false;
                                aiDecisionTimer = TimeSpan.Zero;
                            }



                        }

                        if (setSpheres.Count > 0)
                            rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    }



                }
                if (moveState == 3 & !isAtk1)
                {
                    waitTime -= gameTime.ElapsedGameTime;

                    if (waitTime < TimeSpan.Zero)
                    {
                        moveState = 0;
                        waitTime = TimeSpan.Zero;
                    }

                    isRun = false;
                    thrustAmount = 0.0f;


                }
            }
            else
            {
                if (!isDead)
                {
                    isDead = true;
                    justBones.CopyTo(previousAnimation, 0);
                    isRun = false;
                    thrustAmount = 0.0f;
                    currentAnimationTime = TimeSpan.Zero;




                }




            }
            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);
            if (isRun)
                Position += Direction * thrustAmount * (float)gameTime.ElapsedGameTime.TotalSeconds * 50.0f;

            if (isRun)
                updateRun(gameTime);
            if (isAtk1)
                UpdateBasic1(gameTime);
            else if (isAtk2)
                UpdateBasic2(gameTime);
            else if (isAtk3)
                UpdateBasic3(gameTime);
            else if (isHammerFlight)
                UpdateHammerFlight(gameTime);
            else if (isDead)
                UpdateDead(gameTime);
            else if (isKnockBack)
                UpdateKnockBack(gameTime);
            else if (isKnockDown)
                updateKnockDown(gameTime);

            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1 || isAtk2 || isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockDown)
                upperBones.CopyTo(justBones, 0);
            else if (isHammerFlight)
                upperBones.CopyTo(justBones, 0);
            else if (isDead)
                upperBones.CopyTo(justBones, 0);
            else
                standing.CopyTo(justBones, 0);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;

            for (int i = 0; i < 2; i++)
            {
                futureMovement.Add(new BoundingSphere((Position + new Vector3(0.0f, 70.0f, 0.0f)) + Direction * 51.2f *
                                   (i + 1), collisionS[1].BS.Radius));


            }
            collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            checkMove3(gameTime);


        }
        public bool Dead()
        {
            if (health <= 0)
                return true;
            else
                return false;
        }
        public void UpdateAIMonsterB(GameTime gameTime)
        {
        //    if (fighterIndex == 1)
          //      Console.WriteLine("#");
            futureMovement.Clear();
            toTarget.Clear();
            float rotationAmount = 0.0f;
            float dToP = 0.0f;
            float dToS = 0.0f;
            float dToT = 0.0f;
            oldPosition = position;
            cullSphere = new BoundingSphere(position + new Vector3(0.0f, 70.0f, 0.0f), 204.8f);
            List<int> unculledDummies = new List<int>();

            //IncrementalSpheres[0][0] = position + (2.0f, 0.0f, 2.0f);
            //IncrementalSpheres[0][1] = position + (2.0f, 0.0f, 0.0f);
            for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                {
                    IncrementalSpheres[i][j] = new BoundingSphere(new Vector3(position.X + -2.0f + 2.0f * i, 70.0f, position.Z + -2.0f + 2.0f * j), 12.8f);



                }
            if (health > 0)
            {
                for (int i2 = 0; i2 < 5; i2++)
                    for (int j2 = 0; j2 < 5; j2++)
                    {
                        //moveSpheres[i2][j2] = new BoundingSphere(position - new Vector3(102.4f - 51.2f * (float)(i2), -70.0f, 102.4f - 51.2f * (float)(j2)), 25.6f);
                        moveSpheres[i2][j2] = new BoundingSphere(position - new Vector3(51.2f - 25.6f * (float)(i2), -70.0f, 51.2f - 25.6f * (float)(j2)), 12.8f);
                    }
                open[2][2] = true;
                for (int a = 0; a < ScreenManager.dummies.Count; a++)
                {
                    if (fighterIndex != ScreenManager.dummies[a].fighterIndex)
                        if (moveSpheres[2][2].Contains(ScreenManager.dummies[a].collisionS[1].BS) != ContainmentType.Disjoint)
                            open[2][2] = false;

                }





                for (int i = 0; i < ScreenManager.dummies.Count; i++)
                {
                    if (i != fighterIndex)
                    {

                        if (cullSphere.Contains(ScreenManager.dummies[i].collisionS[1].BS) != ContainmentType.Disjoint)
                        {
                            unculledDummies.Add(i);

                        }
                    }
                }
                for (int i = 0; i < unculledDummies.Count; i++)
                    if (setSpheres.Count == 1)
                    {
                        if (setSpheres[0].Contains(ScreenManager.dummies[unculledDummies[i]].collisionS[1].BS) != ContainmentType.Disjoint)
                        {
                            setSpheres.Clear();
                            havePlannedPosition = false;
                        }

                    }
                if (setSpheres.Count == 1)
                    if (setSpheres[0].Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                    {
                        setSpheres.Clear();
                        havePlannedPosition = false;
                    }





                //if (moveState != 3)
                {
                    for (int i = 0; i < 5; i++)
                        for (int j = 0; j < 5; j++)
                        {
                            open[i][j] = true;
                            for (int a = 0; a < ScreenManager.runners.Count; a++)
                            {

                                if (moveSpheres[i][j].Contains(ScreenManager.runners[a].collisionS[1].BS) != ContainmentType.Disjoint)
                                    open[i][j] = false;

                            }
                            if (moveSpheres[i][j].Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                                open[i][j] = false;
                            if (moveSpheres[i][j].Center.X < 0 || moveSpheres[i][j].Center.X > 1200 ||
              moveSpheres[i][j].Center.Z < 0 || moveSpheres[i][j].Center.Z > 1200)
                            {
                                open[i][j] = false;
                                //break
                            }
                            for (int a = 0; a < ScreenManager.dummies.Count; a++)
                            {
                                if (a != fighterIndex)
                                {
                                    if (moveSpheres[i][j].Contains(ScreenManager.dummies[a].collisionS[1].BS) != ContainmentType.Disjoint)
                                        open[i][j] = false;
                                    //    for (int b = 0; b < ScreenManager.dummies[a].setSpheres.Count; b++)
                                    //        if (moveSpheres[i][j].Contains(ScreenManager.dummies[a].setSpheres[b]) != ContainmentType.Disjoint)
                                    //            open[i][j] = false;
                                }
                                //if (moveSpheres[i][j].Contains(ScreenManager.dummies[a].setSpheres[1]) != ContainmentType.Disjoint)
                                // open[i][j] = false;




                            }
                            //    for (int k = 0; k < unculledDummies.Count; k++)
                            //    {
                            //        if (moveSpheres[i][j].Contains(ScreenManager.dummies[unculledDummies[k]].collisionS[1].BS) != ContainmentType.Disjoint)
                            //        {
                            //            open[i][j] = false;
                            //            // break;
                            //        }
                            //        //for (int m = 0; m < ScreenManager.dummies[k].setSpheres.Count && m < 1; m++)
                            //        //{
                            //        //    if (moveSpheres[i][j].Contains(ScreenManager.dummies[k].setSpheres[m]) != ContainmentType.Disjoint)
                            //        //    {
                            //        //        open[i][j] = false;
                            //        //        //break;
                            //        //    }
                            //        //}
                            //    }
                        }
                }

                open[2][2] = true;
                for (int i = 0; i < ScreenManager.runners.Count; i++)
                {




                }

                dToT = Vector3.Distance(position, ScreenManager.Theseus.Position);
                float lowDist = 11000.0f;
                float rDist = 10000;
                //bool chaseRunner = false;
                for (int i = 0; i < ScreenManager.runners.Count; i++)
                {
                    rDist = Vector3.Distance(position, ScreenManager.runners[i].Position);

                    if (rDist < lowDist)
                    {
                        targetIndex = i;
                        lowDist = rDist;
                        //chaseRunner = true;

                    }

                }

                if (dToT < lowDist)
                {
                    targetIndex = 99;
                    lowDist = dToT;
                }



                if (lowDist < 55)
                {
                    if (targetIndex == 99)
                        rotationAmount = TurnToFace(position, ScreenManager.Theseus.Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    else
                        rotationAmount = TurnToFace(position, ScreenManager.runners[targetIndex].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    if (!isAtk1)
                    {
                        hits.Clear();
                        //chaseDown = true;
                        isAtk1 = true;
                        justBones.CopyTo(previousAnimation, 0);
                    }

                    //if (chaseDown)
                    //{
                    //    isRun = true;
                    //    thrustAmount = 3.0f;
                    //    if (lowDist < 51.2)
                    //    {
                    //        chaseDown = false;
                    //        isRun = false;
                    //        thrustAmount = 0.0f;
                    //    }
                    //}



                }
                else if (lowDist < 400)
                {
                    if (targetIndex == 99)
                        plannedPosition = ScreenManager.Theseus.Position;
                    else
                        plannedPosition = ScreenManager.runners[targetIndex].Position;
                    havePlannedPosition = true;


                }
                else if (!havePlannedPosition)
                {
                    int i = 0;
                    int j = 0;
                    int randomNumber = ScreenManager.rand.Next(25);

                    int counter = 0;
                    for (int i2 = 0; i2 < 5; i2++)
                    {
                        for (int j2 = 0; j2 < 5; j2++)
                        {
                            if (counter == randomNumber)
                            {
                                // i = i2;
                                //  j = j2;
                                break;
                            }

                            if (open[i2][j2])
                            {
                                i = i2;
                                j = j2;
                                counter++;
                            }

                        }
                        if (counter == randomNumber)
                            break;
                    }
                    plannedPosition = moveSpheres[i][j].Center - new Vector3(0.0f, 70.0f, 0.0f);
                    havePlannedPosition = true;
                }
                if (isAtk1)
                {
                    if (lowDist > 50)
                        thrustAmount = 1.0f;
                    else
                        thrustAmount = 0.0f;
                }

                if (moveState == 0 & !isAtk1)
                {
                    dToT = Vector3.Distance(position, ScreenManager.Theseus.Position);
                    dToP = Vector3.Distance(position, plannedPosition);
                    rotationAmount = TurnToFace(position, plannedPosition, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    //if (dToT < 60)
                    //{
                    //    rotationAmount = TurnToFace(position, ScreenManager.Theseus.Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    //    if (!isAtk1)
                    //    {
                    //        isAtk1 = true;
                    //        justBones.CopyTo(previousAnimation, 0);
                    //    }
                    //    thrustAmount = 0.0f;
                    //    isRun = false;



                    //}

                    if (dToP < 10)
                    {
                        havePlannedPosition = false;
                        setSpheres.Clear();
                    }
                    else
                    {
                        thrustAmount = 1.0f;
                        if (!isRun)
                        {
                            isRun = true;
                            justBones.CopyTo(previousAnimation, 0);
                        }

                    }
                }
                else if (moveState == 1 & !isAtk1)
                {
                    // dToT = Vector3.Distance(position, ScreenManager.Theseus.Position);


                    dToP = Vector3.Distance(position, plannedPosition);
                    if (dToT < 60)
                    {
                        moveState = 0;
                    }
                    else
                    {
                        if (dToP < 10)
                        {
                            havePlannedPosition = false;
                            setSpheres.Clear();
                            moveState = 0;
                        }

                        if (setSpheres.Count > 0)
                        {
                            dToS = Vector3.Distance(position + new Vector3(0.0f, 70.0f, 0.0f), setSpheres[0].Center);
                            if (dToS > 5)
                            {
                                thrustAmount = 1.0f;
                                if (!isRun)
                                {
                                    isRun = true;
                                    justBones.CopyTo(previousAnimation, 0);
                                }
                            }
                            else
                            {
                                setSpheres.RemoveAt(0);
                                if (setSpheres.Count == 0)
                                {
                                    havePlannedPosition = false;
                                    moveState = 0;
                                }
                            }
                        }
                        else
                        {
                            isRun = false;
                            thrustAmount = 0.0f;
                        }

                        if (havePlannedPosition)
                        {

                            if (setSpheres.Count == 0)
                            {
                                miniPathSet = false;

                                int thisI = 0;
                                int thisJ = 0;
                                //were being used so that the first setshpere was valid
                                //int startI = 0;
                                //int startJ = 0;
                                float lowest = 99999999;
                                float check = 0;
                                float[] distances = new float [25];
                               int distanceCount = 0;

                                for (int i = 0; i < 5; i++)
                                    for (int j = 0; j < 5; j++)
                                    {
                                        if (open[i][j])
                                        {
                                            distances[distanceCount] = Vector3.Distance(moveSpheres[i][j].Center, plannedPosition);
                                            if (distances[distanceCount] < lowest)
                                            {
                                                thisI = i;
                                                thisJ = j;
                                                lowest = distances[distanceCount];
                                                distanceCount++;
                                            }
                                        }
                                    }
                               
                                float secondLowest;
                                secondLowest = 9999999;
                                if (open[2][2] == false)
                                {
                                 

                                }



                                Reset(new Point(2, 2), new Point(thisI, thisJ));
                                JsearchStatus = JSearchStatus.Searching;

                                while (JsearchStatus == JSearchStatus.Searching)
                                {

                                    DoSearchStep();
                                }

                                if (myJSearchStatus == JSearchStatus.PathFound)
                                {
                                    //just to get to first point
                                    moveState = 1;
                                    foreach (Point point in FinalPath())
                                    {
                                        setSpheres.Add(moveSpheres[point.X][point.Y]);
                                        open[point.X][point.Y] = false;
                                    }
                                    if (setSpheres.Count == 1)
                                    {
                                        setSpheres.Clear();
                                        moveState = 0;
                                    }
                                }
                                if (myJSearchStatus == JSearchStatus.NoPath)
                                {
                                    moveState = 0;
                                    havePlannedPosition = false;
                                    setSpheres.Clear();

                                }

                                if (!miniPathSet)
                                {
                                    miniPathSet = true;
                                }

                            }

                        }
                        else if (!havePlannedPosition)
                        {
                            aiDecisionTimer += gameTime.ElapsedGameTime;
                            isRun = false;
                            thrustAmount = 0.0f;
                            runTime = TimeSpan.Zero;
                            double split = rand.NextDouble();
                            cutOffTime = cutOffTime = TimeSpan.FromMilliseconds(maxDecisionTimer.TotalMilliseconds * split);
                            if (cutOffTime < minDecisionTimer)
                                cutOffTime = minDecisionTimer;

                            if (aiDecisionTimer > cutOffTime)
                            {
                                havePlannedPosition = false;
                                aiDecisionTimer = TimeSpan.Zero;
                            }



                        }

                        if (setSpheres.Count > 0)
                            rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    }



                }
                if (moveState == 3 & !isAtk1)
                {
                    setSpheres.Clear();
                    //waitTime -= gameTime.ElapsedGameTime;

                    //if (waitTime < TimeSpan.Zero)
                    //{
                    //    moveState = 0;
                    //    waitTime = TimeSpan.Zero;
                    //}

                    isRun = false;
                    thrustAmount = 0.0f;
                    int pNum1 = 0;
                    int pNum2 = 0;
                    int num1 = 0;
                    int num2 = 0;
                    for (int i = 0; i < 5; i++)
                        for (int j = 0; j < 5; j++)
                        {
                            if (mSphereIndex < 99)
                            {
                                moveSpheres[i][j] = ScreenManager.dummies[mSphereIndex].moveSpheres[i][j];
                                open[i][j] = ScreenManager.dummies[mSphereIndex].open[i][j];

                            }
                            else if (mSphereIndex > 99)
                            {
                                moveSpheres[i][j] = ScreenManager.runners[mSphereIndex-100].moveSpheres[i][j];
                                open[i][j] = ScreenManager.runners[mSphereIndex-100].open[i][j];


                            }
                            

                            if (moveSpheres[i][j].Contains(position) != ContainmentType.Disjoint)
                            {
                                open[i][j] = true;
                                num1 = i;
                                num2 = j;
                            }

                        }
                    open[2][2] = false;
                    float check = 0;
                    float lowest = 0;
                    int thisI = 0;
                    int thisJ = 0;
                    for (int i = 0; i < 5; i++)
                        for (int j = 0; j < 5; j++)
                        {
                            if (open[i][j])
                            {
                                check = Vector3.Distance(moveSpheres[i][j].Center, plannedPosition);
                                if (check < lowest)
                                {
                                    thisI = i;
                                    thisJ = j;
                                    lowest = check;
                                }
                            }
                        }

                    Reset(new Point(num1, num2), new Point(thisI, thisJ));
                    JsearchStatus = JSearchStatus.Searching;

                    while (JsearchStatus == JSearchStatus.Searching)
                    {

                        DoSearchStep();
                    }

                    if (myJSearchStatus == JSearchStatus.PathFound)
                    {
                        //just to get to first point
                       
                        moveState = 4;
                        foreach (Point point in FinalPath())
                        {
                            setSpheres.Add(moveSpheres[point.X][point.Y]);
                        }
                        //if (setSpheres.Count == 1)
                        //{
                        //    setSpheres.Clear();
                        //    moveState = 0;
                        //}
                    }
                    if (myJSearchStatus == JSearchStatus.NoPath)
                    {
                        moveState = 0;
                        havePlannedPosition = false;
                        setSpheres.Clear();

                    }

                    if (!miniPathSet)
                    {
                        miniPathSet = true;
                    }

                    if (setSpheres.Count > 0)
                    {
                        rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                        isRun = true;
                        thrustAmount = 1.0f;
                    }


                }
                else if(moveState == 4)
                {

                                      dToP = Vector3.Distance(position, plannedPosition);
                                      if (dToT < 60)
                                      {
                                          moveState = 0;
                                      }
                                      else
                                      {
                                          if (dToP < 10)
                                          {
                                              havePlannedPosition = false;
                                              setSpheres.Clear();
                                              moveState = 0;
                                          }

                                          if (setSpheres.Count > 0)
                                          {
                                              dToS = Vector3.Distance(position + new Vector3(0.0f, 70.0f, 0.0f), setSpheres[0].Center);
                                              if (dToS > 5)
                                              {
                                                  thrustAmount = 1.0f;
                                                  if (!isRun)
                                                  {
                                                      isRun = true;
                                                      justBones.CopyTo(previousAnimation, 0);
                                                  }
                                              }
                                              else
                                              {
                                                  setSpheres.RemoveAt(0);
                                                  if (setSpheres.Count == 0)
                                                  {
                                                      havePlannedPosition = false;
                                                      moveState = 0;
                                                  }
                                              }
                                          }
                                          else
                                          {
                                              isRun = false;
                                              thrustAmount = 0.0f;
                                          }
                                      }
                                      if (setSpheres.Count > 0)
                                      {
                                          rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                                      }
                                      if (setSpheres.Count == 0)
                                          moveState = 0; 

                }
                else if (moveState == 5)
                {
                    dToS = Vector3.Distance(position, outOfWayPos);

                    if (dToS > 5)
                    {
                        rotationAmount = TurnToFace(position, outOfWayPos, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                        thrustAmount = 1.0f;


                    }
                    else
                    {
                        thrustAmount = 0.0f;
                        moveState = 0;

                    }








                }
            }
            else
            {
                if (!isDead)
                {
                    isDead = true;
                    justBones.CopyTo(previousAnimation, 0);
                    isRun = false;
                    thrustAmount = 0.0f;
                    currentAnimationTime = TimeSpan.Zero;
                    ScreenManager.items.Add(new Item(position, 0, 2));
                    ScreenManager.items.Add(new Item(position, 1, 3));



                }




            }
            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);
            if (thrustAmount > 0.0f)
                Position += Direction * thrustAmount * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;
            //if(isAtk1)
            //    Position += Direction * .3f * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;
            if (isRun)
                updateRun(gameTime);
            if (isAtk1)
                UpdateBasic1(gameTime);
            else if (isAtk2)
                UpdateBasic2(gameTime);
            else if (isAtk3)
                UpdateBasic3(gameTime);
            else if (isHammerFlight)
                UpdateHammerFlight(gameTime);
            else if (isDead)
                UpdateDead(gameTime);
            else if (isKnockBack)
                UpdateKnockBack(gameTime);
            else if (isKnockDown)
                updateKnockDown(gameTime);

            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1 || isAtk2 || isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockDown)
                upperBones.CopyTo(justBones, 0);
            else if (isHammerFlight)
                upperBones.CopyTo(justBones, 0);
            else if (isDead)
                upperBones.CopyTo(justBones, 0);
            else
                standing.CopyTo(justBones, 0);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;

            for (int i = 0; i < 2; i++)
            {
                futureMovement.Add(new BoundingSphere((Position + new Vector3(0.0f, 70.0f, 0.0f)) + Direction * 51.2f *
                                   (i + 1), collisionS[1].BS.Radius));


            }
            collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
            collisionBox = new BoundingBox(Position - new Vector3(12.8f, 0.0f, 12.8f), Position + new Vector3(12.8f, 70.0f, 12.8f));
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            checkMove3(gameTime);

            //open[2][2] = true;
            //for (int a = 0; a < ScreenManager.dummies.Count; a++)
            //{
            //    if (fighterIndex != ScreenManager.dummies[a].fighterIndex)
            //        if (moveSpheres[2][2].Contains(ScreenManager.dummies[a].collisionS[1].BS) != ContainmentType.Disjoint)
            //            open[2][2] = false;

            //}
            if (open[2][2] = false)
            {
                separate(gameTime);


            }
            for (int g = 0; g < spheres.Count; g++)
            {
                oldSpheres[g] = new BoundingSphere(spheres[g].BS.Center, spheres[g].BS.Radius);

            }

            Matrix targetMat = new Matrix();
            Matrix []transforms = new Matrix[ScreenManager.spearSphere.Bones.Count];
            ScreenManager.spearSphere.CopyAbsoluteBoneTransformsTo(transforms);
             int z = 0;
             int c = 0;
            int k = 0;
            int arrowInt = 0;
            foreach (ModelMesh mesh in ScreenManager.spearSphere.Meshes)
            {
                // draw = false;
                foreach (BasicEffect effect in mesh.Effects)
                {
                    if (mesh.Name == "arrowS1" || mesh.Name == "arrowS2" || mesh.Name == "arrowS3")
                    {
                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.rHand];
                        targetMat.Decompose(out scale, out rota, out trans);
                        arrow[arrowInt++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * Math.Abs(scale.Z) * 10.0f));


                    }
                    if (mesh.Name == "rSwordS1" || mesh.Name == "rSwordS2" || mesh.Name == "rSwordS3")
                    {

                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.rHand];
                        targetMat.Decompose(out scale, out rota, out trans);
                        rSword[k++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * Math.Abs(scale.Z)));
                        if (isAtk1 || isAtk2 || isAtk3)
                        {
                            if (mesh.Name == "rSwordS1" && active)
                                slashPoints.Add(trans);
                            if (mesh.Name == "rSwordS3" && active)
                                slashPoints.Add(trans);
                        }

                    }

                    if (mesh.Name == "shieldS1" || mesh.Name == "shieldS2" || mesh.Name == "shieldS3" || mesh.Name == "shieldS4" || mesh.Name == "shieldS5")
                    {

                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.lHand];
                        targetMat.Decompose(out scale, out rota, out trans);
                        roundShield[c++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * Math.Abs(scale.Z)));

                    }
                    //if (mesh.Name == "forwardSpell")
                    //{
                    //    World.Decompose(out scale, out rota, out trans);

                    //    forwardSpell = Matrix.Transform(transforms[mesh.ParentBone.Index], rota) * Matrix.CreateTranslation(trans);




                    //}
                    if (mesh.Name == "headS1")
                    {
                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.head];
                        targetMat.Decompose(out scale, out rota, out trans);
                        spheres[z++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * Math.Abs(scale.Z)));


                    }
                    if (mesh.Name == "chestS")
                    {

                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.spine1];
                        targetMat.Decompose(out scale, out rota, out trans);
                        spheres[z++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * Math.Abs(scale.Z)));
                        collisionS[0] = new boundingSphere("collisionS", new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), mesh.BoundingSphere.Radius * Math.Abs(scale.X) * 2.0f));
                        collisionS[1] = new boundingSphere("collisionS", new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), mesh.BoundingSphere.Radius * Math.Abs(scale.X)));

                    }
                    if (mesh.Name == "hipS")
                    {
                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.hips];
                        targetMat.Decompose(out scale, out rota, out trans);
                        spheres[z++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * Math.Abs(scale.Z)));
                    }
                    if (mesh.Name == "lULegS")
                    {
                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.lULeg];
                        targetMat.Decompose(out scale, out rota, out trans);
                        spheres[z++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * Math.Abs(scale.Z)));
                    }
                    if (mesh.Name == "lLLegS")
                    {
                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.lLLeg];
                        targetMat.Decompose(out scale, out rota, out trans);
                        spheres[z++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * Math.Abs(scale.Z)));
                    }
                    if (mesh.Name == "rULegS")
                    {
                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.rULeg];
                        targetMat.Decompose(out scale, out rota, out trans);
                        spheres[z++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * Math.Abs(scale.Z)));
                    }
                    if (mesh.Name == "rLLegS")
                    {
                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.rLLeg];
                        targetMat.Decompose(out scale, out rota, out trans);
                        spheres[z++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * Math.Abs(scale.Z)));
                    }
                    //if (mesh.Name == "lFootS")
                    //{

                    //    targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.rFoot];
                    //    targetMat.Decompose(out scale, out rota, out trans);
                    //    physicalSphere[x++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * scale.Y));

                    //}
                }

            }

        }
        public void UpdateAIRange(GameTime gameTime)
        {
            foreach (Arrow arrow in arrows)
            {
                arrow.updateE(gameTime);
            }
           // if (fighterIndex == 1)
              //  Console.WriteLine("#");
            futureMovement.Clear();
            toTarget.Clear();
            float rotationAmount = 0.0f;
            float dToP = 0.0f;
            float dToS = 0.0f;
            float dToT = 0.0f;
            oldPosition = position;
            cullSphere = new BoundingSphere(position + new Vector3(0.0f, 70.0f, 0.0f), 204.8f);
            List<int> unculledDummies = new List<int>();

            //IncrementalSpheres[0][0] = position + (2.0f, 0.0f, 2.0f);
            //IncrementalSpheres[0][1] = position + (2.0f, 0.0f, 0.0f);
            for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                {
                    IncrementalSpheres[i][j] = new BoundingSphere(new Vector3(position.X + -2.0f + 2.0f * i, 70.0f, position.Z + -2.0f + 2.0f * j), 12.8f);



                }
            if (health > 0)
            {
                for (int i2 = 0; i2 < 5; i2++)
                    for (int j2 = 0; j2 < 5; j2++)
                    {
                        //moveSpheres[i2][j2] = new BoundingSphere(position - new Vector3(102.4f - 51.2f * (float)(i2), -70.0f, 102.4f - 51.2f * (float)(j2)), 25.6f);
                        moveSpheres[i2][j2] = new BoundingSphere(position - new Vector3(51.2f - 25.6f * (float)(i2), -70.0f, 51.2f - 25.6f * (float)(j2)), 12.8f);
                    }
                open[2][2] = true;
                for (int a = 0; a < ScreenManager.dummies.Count; a++)
                {
                    if (fighterIndex != ScreenManager.dummies[a].fighterIndex)
                        if (moveSpheres[2][2].Contains(ScreenManager.dummies[a].collisionS[1].BS) != ContainmentType.Disjoint)
                            open[2][2] = false;

                }





                for (int i = 0; i < ScreenManager.dummies.Count; i++)
                {
                    if (i != fighterIndex)
                    {

                        if (cullSphere.Contains(ScreenManager.dummies[i].collisionS[1].BS) != ContainmentType.Disjoint)
                        {
                            unculledDummies.Add(i);

                        }
                    }
                }
                for (int i = 0; i < unculledDummies.Count; i++)
                    if (setSpheres.Count == 1)
                    {
                        if (setSpheres[0].Contains(ScreenManager.dummies[unculledDummies[i]].collisionS[1].BS) != ContainmentType.Disjoint)
                        {
                            setSpheres.Clear();
                            havePlannedPosition = false;
                        }

                    }
                if (setSpheres.Count == 1)
                    if (setSpheres[0].Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                    {
                        setSpheres.Clear();
                        havePlannedPosition = false;
                    }





                //if (moveState != 3)
                {
                    for (int i = 0; i < 5; i++)
                        for (int j = 0; j < 5; j++)
                        {
                            open[i][j] = true;
                            for (int a = 0; a < ScreenManager.runners.Count; a++)
                            {

                                if (moveSpheres[i][j].Contains(ScreenManager.runners[a].collisionS[1].BS) != ContainmentType.Disjoint)
                                    open[i][j] = false;

                            }
                            if (moveSpheres[i][j].Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                                open[i][j] = false;
                            if (moveSpheres[i][j].Center.X < 0 || moveSpheres[i][j].Center.X > 1200 ||
              moveSpheres[i][j].Center.Z < 0 || moveSpheres[i][j].Center.Z > 1200)
                            {
                                open[i][j] = false;
                                //break
                            }
                            for (int a = 0; a < ScreenManager.dummies.Count; a++)
                            {
                                if (a != fighterIndex)
                                {
                                    if (moveSpheres[i][j].Contains(ScreenManager.dummies[a].collisionS[1].BS) != ContainmentType.Disjoint)
                                        open[i][j] = false;
                                    //    for (int b = 0; b < ScreenManager.dummies[a].setSpheres.Count; b++)
                                    //        if (moveSpheres[i][j].Contains(ScreenManager.dummies[a].setSpheres[b]) != ContainmentType.Disjoint)
                                    //            open[i][j] = false;
                                }
                                //if (moveSpheres[i][j].Contains(ScreenManager.dummies[a].setSpheres[1]) != ContainmentType.Disjoint)
                                // open[i][j] = false;




                            }
                            //    for (int k = 0; k < unculledDummies.Count; k++)
                            //    {
                            //        if (moveSpheres[i][j].Contains(ScreenManager.dummies[unculledDummies[k]].collisionS[1].BS) != ContainmentType.Disjoint)
                            //        {
                            //            open[i][j] = false;
                            //            // break;
                            //        }
                            //        //for (int m = 0; m < ScreenManager.dummies[k].setSpheres.Count && m < 1; m++)
                            //        //{
                            //        //    if (moveSpheres[i][j].Contains(ScreenManager.dummies[k].setSpheres[m]) != ContainmentType.Disjoint)
                            //        //    {
                            //        //        open[i][j] = false;
                            //        //        //break;
                            //        //    }
                            //        //}
                            //    }
                        }
                }

                open[2][2] = true;
                for (int i = 0; i < ScreenManager.runners.Count; i++)
                {




                }

                dToT = Vector3.Distance(position, ScreenManager.Theseus.Position);
                float lowDist = 11000.0f;
                float rDist = 10000;
                //bool chaseRunner = false;
                for (int i = 0; i < ScreenManager.runners.Count; i++)
                {
                    rDist = Vector3.Distance(position, ScreenManager.runners[i].Position);

                    if (rDist < lowDist)
                    {
                        targetIndex = i;
                        lowDist = rDist;
                        //chaseRunner = true;

                    }

                }

                if (dToT < lowDist)
                {
                    targetIndex = 99;
                    lowDist = dToT;
                }

                

                if (lowDist < 500)
                {
                    if (targetIndex == 99)
                        rotationAmount = TurnToFace(position, ScreenManager.Theseus.Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    else
                        rotationAmount = TurnToFace(position, ScreenManager.runners[targetIndex].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    if (!isBow)
                    {
                        hits.Clear();
                        //chaseDown = true;
                        isBow = true;
                        justBones.CopyTo(previousAnimation, 0);
                    }

                    //if (chaseDown)
                    //{
                    //    isRun = true;
                    //    thrustAmount = 3.0f;
                    //    if (lowDist < 51.2)
                    //    {
                    //        chaseDown = false;
                    //        isRun = false;
                    //        thrustAmount = 0.0f;
                    //    }
                    //}



                }
                else if (lowDist < 600)
                {
                    if (targetIndex == 99)
                        plannedPosition = ScreenManager.Theseus.Position;
                    else
                        plannedPosition = ScreenManager.runners[targetIndex].Position;
                    havePlannedPosition = true;


                }
                else if (!havePlannedPosition)
                {
                    int i = 0;
                    int j = 0;
                    int randomNumber = ScreenManager.rand.Next(25);

                    int counter = 0;
                    for (int i2 = 0; i2 < 5; i2++)
                    {
                        for (int j2 = 0; j2 < 5; j2++)
                        {
                            if (counter == randomNumber)
                            {
                                // i = i2;
                                //  j = j2;
                                break;
                            }

                            if (open[i2][j2])
                            {
                                i = i2;
                                j = j2;
                                counter++;
                            }

                        }
                        if (counter == randomNumber)
                            break;
                    }
                    plannedPosition = moveSpheres[i][j].Center - new Vector3(0.0f, 70.0f, 0.0f);
                    havePlannedPosition = true;
                }
                if (isBow)
                {
                    if (lowDist > 400)
                        thrustAmount = 1.0f;
                    else
                        thrustAmount = 0.0f;
                }

                if (moveState == 0 & !isBow)
                {
                    dToT = Vector3.Distance(position, ScreenManager.Theseus.Position);
                    dToP = Vector3.Distance(position, plannedPosition);
                    rotationAmount = TurnToFace(position, plannedPosition, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    //if (dToT < 60)
                    //{
                    //    rotationAmount = TurnToFace(position, ScreenManager.Theseus.Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    //    if (!isAtk1)
                    //    {
                    //        isAtk1 = true;
                    //        justBones.CopyTo(previousAnimation, 0);
                    //    }
                    //    thrustAmount = 0.0f;
                    //    isRun = false;



                    //}

                    if (dToP < 10)
                    {
                        havePlannedPosition = false;
                        setSpheres.Clear();
                    }
                    else
                    {
                        thrustAmount = 1.0f;
                        if (!isRun)
                        {
                            isRun = true;
                            justBones.CopyTo(previousAnimation, 0);
                        }

                    }
                }
                else if (moveState == 1 & !isBow)
                {
                    // dToT = Vector3.Distance(position, ScreenManager.Theseus.Position);


                    dToP = Vector3.Distance(position, plannedPosition);
                    if (dToT < 60)
                    {
                        moveState = 0;
                    }
                    else
                    {
                        if (dToP < 10)
                        {
                            havePlannedPosition = false;
                            setSpheres.Clear();
                            moveState = 0;
                        }

                        if (setSpheres.Count > 0)
                        {
                            dToS = Vector3.Distance(position + new Vector3(0.0f, 70.0f, 0.0f), setSpheres[0].Center);
                            if (dToS > 5)
                            {
                                thrustAmount = 1.0f;
                                if (!isRun)
                                {
                                    isRun = true;
                                    justBones.CopyTo(previousAnimation, 0);
                                }
                            }
                            else
                            {
                                setSpheres.RemoveAt(0);
                                if (setSpheres.Count == 0)
                                {
                                    havePlannedPosition = false;
                                    moveState = 0;
                                }
                            }
                        }
                        else
                        {
                            isRun = false;
                            thrustAmount = 0.0f;
                        }

                        if (havePlannedPosition)
                        {

                            if (setSpheres.Count == 0)
                            {
                                miniPathSet = false;

                                int thisI = 0;
                                int thisJ = 0;
                                //were being used so that the first setshpere was valid
                                //int startI = 0;
                                //int startJ = 0;
                                float lowest = 99999999;
                                float check = 0;
                                for (int i = 0; i < 5; i++)
                                    for (int j = 0; j < 5; j++)
                                    {
                                        if (open[i][j])
                                        {
                                            check = Vector3.Distance(moveSpheres[i][j].Center, plannedPosition);
                                            if (check < lowest)
                                            {
                                                thisI = i;
                                                thisJ = j;
                                                lowest = check;
                                            }
                                        }
                                    }
                                if (open[2][2] == false)
                                {
                                    for (int i = 1; i < 3; i++)
                                    {
                                        for (int j = 1; j < 3; j++)
                                        {
                                            if (open[i][j])
                                            {

                                            }
                                        }
                                    }

                                }



                                Reset(new Point(2, 2), new Point(thisI, thisJ));
                                JsearchStatus = JSearchStatus.Searching;

                                while (JsearchStatus == JSearchStatus.Searching)
                                {

                                    DoSearchStep();
                                }

                                if (myJSearchStatus == JSearchStatus.PathFound)
                                {
                                    //just to get to first point
                                    moveState = 1;
                                    foreach (Point point in FinalPath())
                                    {
                                        setSpheres.Add(moveSpheres[point.X][point.Y]);
                                        open[point.X][point.Y] = false;
                                    }
                                    if (setSpheres.Count == 1)
                                    {
                                        setSpheres.Clear();
                                        moveState = 0;
                                    }
                                }
                                if (myJSearchStatus == JSearchStatus.NoPath)
                                {
                                    moveState = 0;
                                    havePlannedPosition = false;
                                    setSpheres.Clear();

                                }

                                if (!miniPathSet)
                                {
                                    miniPathSet = true;
                                }

                            }

                        }
                        else if (!havePlannedPosition)
                        {
                            aiDecisionTimer += gameTime.ElapsedGameTime;
                            isRun = false;
                            thrustAmount = 0.0f;
                            runTime = TimeSpan.Zero;
                            double split = rand.NextDouble();
                            cutOffTime = cutOffTime = TimeSpan.FromMilliseconds(maxDecisionTimer.TotalMilliseconds * split);
                            if (cutOffTime < minDecisionTimer)
                                cutOffTime = minDecisionTimer;

                            if (aiDecisionTimer > cutOffTime)
                            {
                                havePlannedPosition = false;
                                aiDecisionTimer = TimeSpan.Zero;
                            }



                        }

                        if (setSpheres.Count > 0)
                            rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    }



                }
                if (moveState == 3 & !isBow)
                {
                    setSpheres.Clear();
                    //waitTime -= gameTime.ElapsedGameTime;

                    //if (waitTime < TimeSpan.Zero)
                    //{
                    //    moveState = 0;
                    //    waitTime = TimeSpan.Zero;
                    //}

                    isRun = false;
                    thrustAmount = 0.0f;
                    int pNum1 = 0;
                    int pNum2 = 0;
                    int num1 = 0;
                    int num2 = 0;
                    for (int i = 0; i < 5; i++)
                        for (int j = 0; j < 5; j++)
                        {
                            if (mSphereIndex < 99)
                            {
                                moveSpheres[i][j] = ScreenManager.dummies[mSphereIndex].moveSpheres[i][j];
                                open[i][j] = ScreenManager.dummies[mSphereIndex].open[i][j];

                            }
                            else if (mSphereIndex > 99)
                            {
                                moveSpheres[i][j] = ScreenManager.runners[mSphereIndex - 100].moveSpheres[i][j];
                                open[i][j] = ScreenManager.runners[mSphereIndex - 100].open[i][j];


                            }


                            if (moveSpheres[i][j].Contains(position) != ContainmentType.Disjoint)
                            {
                                open[i][j] = true;
                                num1 = i;
                                num2 = j;
                            }

                        }
                    open[2][2] = false;
                    float check = 0;
                    float lowest = 0;
                    int thisI = 0;
                    int thisJ = 0;
                    for (int i = 0; i < 5; i++)
                        for (int j = 0; j < 5; j++)
                        {
                            if (open[i][j])
                            {
                                check = Vector3.Distance(moveSpheres[i][j].Center, plannedPosition);
                                if (check < lowest)
                                {
                                    thisI = i;
                                    thisJ = j;
                                    lowest = check;
                                }
                            }
                        }

                    Reset(new Point(num1, num2), new Point(thisI, thisJ));
                    JsearchStatus = JSearchStatus.Searching;

                    while (JsearchStatus == JSearchStatus.Searching)
                    {

                        DoSearchStep();
                    }

                    if (myJSearchStatus == JSearchStatus.PathFound)
                    {
                        //just to get to first point

                        moveState = 4;
                        foreach (Point point in FinalPath())
                        {
                            setSpheres.Add(moveSpheres[point.X][point.Y]);
                        }
                        //if (setSpheres.Count == 1)
                        //{
                        //    setSpheres.Clear();
                        //    moveState = 0;
                        //}
                    }
                    if (myJSearchStatus == JSearchStatus.NoPath)
                    {
                        moveState = 0;
                        havePlannedPosition = false;
                        setSpheres.Clear();

                    }

                    if (!miniPathSet)
                    {
                        miniPathSet = true;
                    }

                    if (setSpheres.Count > 0)
                    {
                        rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                        isRun = true;
                        thrustAmount = 1.0f;
                    }


                }
                else if (moveState == 4)
                {

                    dToP = Vector3.Distance(position, plannedPosition);
                    if (dToT < 60)
                    {
                        moveState = 0;
                    }
                    else
                    {
                        if (dToP < 10)
                        {
                            havePlannedPosition = false;
                            setSpheres.Clear();
                            moveState = 0;
                        }

                        if (setSpheres.Count > 0)
                        {
                            dToS = Vector3.Distance(position + new Vector3(0.0f, 70.0f, 0.0f), setSpheres[0].Center);
                            if (dToS > 5)
                            {
                                thrustAmount = 1.0f;
                                if (!isRun)
                                {
                                    isRun = true;
                                    justBones.CopyTo(previousAnimation, 0);
                                }
                            }
                            else
                            {
                                setSpheres.RemoveAt(0);
                                if (setSpheres.Count == 0)
                                {
                                    havePlannedPosition = false;
                                    moveState = 0;
                                }
                            }
                        }
                        else
                        {
                            isRun = false;
                            thrustAmount = 0.0f;
                        }
                    }
                    if (setSpheres.Count > 0)
                    {
                        rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                    }
                    if (setSpheres.Count == 0)
                        moveState = 0;

                }
                else if (moveState == 5)
                {
                    dToS = Vector3.Distance(position, outOfWayPos);

                    if (dToS > 5)
                    {
                        rotationAmount = TurnToFace(position, outOfWayPos, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                        thrustAmount = 1.0f;


                    }
                    else
                    {
                        thrustAmount = 0.0f;
                        moveState = 0;

                    }








                }
            }
            else
            {
                if (!isDead)
                {
                    isDead = true;
                    justBones.CopyTo(previousAnimation, 0);
                    isRun = false;
                    thrustAmount = 0.0f;
                    currentAnimationTime = TimeSpan.Zero;
                    ScreenManager.items.Add(new Item(position, 0, 2));
                    ScreenManager.items.Add(new Item(position, 1, 3));



                }




            }
            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);
            if (thrustAmount > 0.0f)
                Position += Direction * thrustAmount * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;

            if (isRun)
                updateRun(gameTime);
            if (isAtk1)
                UpdateBasic1(gameTime);
            else if (isAtk2)
                UpdateBasic2(gameTime);
            else if (isAtk3)
                UpdateBasic3(gameTime);
            else if (isBow)
                UpdateBow(gameTime);
            else if (isHammerFlight)
                UpdateHammerFlight(gameTime);
            else if (isDead)
                UpdateDead(gameTime);
            else if (isKnockBack)
                UpdateKnockBack(gameTime);
            else if (isKnockDown)
                updateKnockDown(gameTime);

            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1 || isAtk2 || isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockDown)
                upperBones.CopyTo(justBones, 0);
            else if (isHammerFlight)
                upperBones.CopyTo(justBones, 0);
            else if (isDead)
                upperBones.CopyTo(justBones, 0);
            else if (isBow)
                upperBones.CopyTo(justBones, 0);
            else
                standing.CopyTo(justBones, 0);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;

            for (int i = 0; i < 2; i++)
            {
                futureMovement.Add(new BoundingSphere((Position + new Vector3(0.0f, 70.0f, 0.0f)) + Direction * 51.2f *
                                   (i + 1), collisionS[1].BS.Radius));


            }
            collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
            collisionBox = new BoundingBox(Position - new Vector3(12.8f, 0.0f, 12.8f), Position + new Vector3(12.8f, 70.0f, 12.8f));
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            checkMove3(gameTime);

            //open[2][2] = true;
            //for (int a = 0; a < ScreenManager.dummies.Count; a++)
            //{
            //    if (fighterIndex != ScreenManager.dummies[a].fighterIndex)
            //        if (moveSpheres[2][2].Contains(ScreenManager.dummies[a].collisionS[1].BS) != ContainmentType.Disjoint)
            //            open[2][2] = false;

            //}
            if (open[2][2] = false)
            {
                separate(gameTime);


            }

        }
        public void UpdateAIMonster(GameTime gameTime)
        {
            if (fighterIndex == 1)
                Console.WriteLine("#");
            futureMovement.Clear();
            toTarget.Clear();
            float rotationAmount = 0.0f;
            float dToP = 0.0f;
            float dToS = 0.0f;
            float dToT = 0.0f;
            oldPosition = position;
            cullSphere = new BoundingSphere(position + new Vector3(0.0f, 70.0f, 0.0f), 204.8f);
            List<int> unculledDummies = new List<int>();

            //IncrementalSpheres[0][0] = position + (2.0f, 0.0f, 2.0f);
            //IncrementalSpheres[0][1] = position + (2.0f, 0.0f, 0.0f);
            for(int i = 0; i< 3; i++)
                for ( int j = 0; j<3; j++)
                {
                    IncrementalSpheres[i][j] = new BoundingSphere(new Vector3(position.X + -2.0f + 2.0f * i, 70.0f, position.Z + -2.0f + 2.0f * j), 12.8f);



                }
            if (health > 0)
            {
                  for (int i2 = 0; i2 < 5; i2++)
                    for (int j2 = 0; j2 < 5; j2++)
                    {
                        //moveSpheres[i2][j2] = new BoundingSphere(position - new Vector3(102.4f - 51.2f * (float)(i2), -70.0f, 102.4f - 51.2f * (float)(j2)), 25.6f);
                         moveSpheres[i2][j2] = new BoundingSphere(position - new Vector3(51.2f - 25.6f * (float)(i2), -70.0f, 51.2f - 25.6f * (float)(j2)), 12.8f);
                    }
                open[2][2] = true;
                for (int a = 0; a < ScreenManager.dummies.Count; a++)
                {
                    if(fighterIndex!= ScreenManager.dummies[a].fighterIndex)
                    if (moveSpheres[2][2].Contains(ScreenManager.dummies[a].collisionS[1].BS) != ContainmentType.Disjoint)
                        open[2][2] = false;

                }




  
                for (int i = 0; i < ScreenManager.dummies.Count; i++)
                {
                    if (i != fighterIndex)
                    {

                        if (cullSphere.Contains(ScreenManager.dummies[i].collisionS[1].BS) != ContainmentType.Disjoint)
                        {
                            unculledDummies.Add(i);

                        }
                    }
                }
                for (int i = 0; i < unculledDummies.Count; i++)
                    if (setSpheres.Count == 1)
                    {
                        if (setSpheres[0].Contains(ScreenManager.dummies[unculledDummies[i]].collisionS[1].BS) != ContainmentType.Disjoint)
                        {
                            setSpheres.Clear();
                            havePlannedPosition = false;
                        }

                    }
                if (setSpheres.Count == 1)
                    if (setSpheres[0].Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                    {
                        setSpheres.Clear();
                        havePlannedPosition = false;
                    }


                
                


                for (int i = 0; i < 5; i++)
                    for (int j = 0; j < 5; j++)
                    {
                        open[i][j] = true;
                        for (int a = 0; a < ScreenManager.runners.Count; a++)
                        {

                            if (moveSpheres[i][j].Contains(ScreenManager.runners[a].collisionS[1].BS) != ContainmentType.Disjoint)
                                open[i][j] = false;
                
                        }
                        if (moveSpheres[i][j].Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                            open[i][j] = false;
                        if (moveSpheres[i][j].Center.X < 0 || moveSpheres[i][j].Center.X > 1200 ||
          moveSpheres[i][j].Center.Z < 0 || moveSpheres[i][j].Center.Z > 1200)
                        {
                            open[i][j] = false;
                            //break
                        }
                        for (int a = 0; a < ScreenManager.dummies.Count; a++)
                        {
                            if (a != fighterIndex)
                            {
                                if (moveSpheres[i][j].Contains(ScreenManager.dummies[a].collisionS[1].BS) != ContainmentType.Disjoint)
                                    open[i][j] = false;
                                for (int b = 0; b < ScreenManager.dummies[a].rangeSpheres.Count; b++)
                                {
                                    if (moveSpheres[i][j].Contains(ScreenManager.dummies[a].rangeSpheres[b]) != ContainmentType.Disjoint)
                                        open[i][j] = false;
                                }
                            //    for (int b = 0; b < ScreenManager.dummies[a].setSpheres.Count; b++)
                            //        if (moveSpheres[i][j].Contains(ScreenManager.dummies[a].setSpheres[b]) != ContainmentType.Disjoint)
                            //            open[i][j] = false;
                            }
                            //if (moveSpheres[i][j].Contains(ScreenManager.dummies[a].setSpheres[1]) != ContainmentType.Disjoint)
                           // open[i][j] = false;



                            
                        }
                    //    for (int k = 0; k < unculledDummies.Count; k++)
                    //    {
                    //        if (moveSpheres[i][j].Contains(ScreenManager.dummies[unculledDummies[k]].collisionS[1].BS) != ContainmentType.Disjoint)
                    //        {
                    //            open[i][j] = false;
                    //            // break;
                    //        }
                    //        //for (int m = 0; m < ScreenManager.dummies[k].setSpheres.Count && m < 1; m++)
                    //        //{
                    //        //    if (moveSpheres[i][j].Contains(ScreenManager.dummies[k].setSpheres[m]) != ContainmentType.Disjoint)
                    //        //    {
                    //        //        open[i][j] = false;
                    //        //        //break;
                    //        //    }
                    //        //}
                    //    }
                    }

                open[2][2] = true;
                for (int i = 0; i < ScreenManager.runners.Count; i++)
                {




                }

                dToT = Vector3.Distance(position, ScreenManager.Theseus.Position);
                float lowDist = 11000.0f;
                float rDist = 10000;
                //bool chaseRunner = false;
                for (int i = 0; i < ScreenManager.runners.Count; i++)
                {
                    rDist = Vector3.Distance(position, ScreenManager.runners[i].Position);

                    if (rDist < lowDist)
                    {
                        targetIndex = i;
                        lowDist = rDist;
                        //chaseRunner = true;

                    }

                }

                if (dToT < lowDist)
                {
                    targetIndex = 99;
                    lowDist = dToT;
                }


   
                if (lowDist < 55)
                {
                    if(targetIndex == 99)
                    rotationAmount = TurnToFace(position, ScreenManager.Theseus.Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    else
                        rotationAmount = TurnToFace(position, ScreenManager.runners[targetIndex].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    if (!isAtk1)
                    {
                        hits.Clear();
                        //chaseDown = true;
                        isAtk1 = true;
                        justBones.CopyTo(previousAnimation, 0);
                    }

                    //if (chaseDown)
                    //{
                    //    isRun = true;
                    //    thrustAmount = 3.0f;
                    //    if (lowDist < 51.2)
                    //    {
                    //        chaseDown = false;
                    //        isRun = false;
                    //        thrustAmount = 0.0f;
                    //    }
                    //}



                }
                else if (lowDist < 400)
                {
                    if (targetIndex == 99)
                        plannedPosition = ScreenManager.Theseus.Position;
                    else
                        plannedPosition = ScreenManager.runners[targetIndex].Position;
                    havePlannedPosition = true;


                }
                else if (!havePlannedPosition)
                {
                    int i = 0;
                    int j = 0;
                    int randomNumber = ScreenManager.rand.Next(25);

                    int counter = 0;
                    for (int i2 = 0; i2 < 5; i2++)
                    {
                        for (int j2 = 0; j2 < 5; j2++)
                        {
                            if (counter == randomNumber)
                            {
                                // i = i2;
                                //  j = j2;
                                break;
                            }

                            if (open[i2][j2])
                            {
                                i = i2;
                                j = j2;
                                counter++;
                            }

                        }
                        if (counter == randomNumber)
                            break;
                    }
                    plannedPosition = moveSpheres[i][j].Center - new Vector3(0.0f, 70.0f, 0.0f);
                    havePlannedPosition = true;
                }
                if (isAtk1)
                {
                    if (lowDist > 50)
                        thrustAmount = 1.0f;
                    else
                        thrustAmount = 0.0f;
                }

                if (moveState == 0 & !isAtk1)
                {
                    dToT = Vector3.Distance(position, ScreenManager.Theseus.Position);
                    dToP = Vector3.Distance(position, plannedPosition);
                    rotationAmount = TurnToFace(position, plannedPosition, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    //if (dToT < 60)
                    //{
                    //    rotationAmount = TurnToFace(position, ScreenManager.Theseus.Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    //    if (!isAtk1)
                    //    {
                    //        isAtk1 = true;
                    //        justBones.CopyTo(previousAnimation, 0);
                    //    }
                    //    thrustAmount = 0.0f;
                    //    isRun = false;



                    //}

                    if (dToP < 10)
                    {
                        havePlannedPosition = false;
                        setSpheres.Clear();
                    }
                    else
                    {
                        thrustAmount = 1.0f;
                        if (!isRun)
                        {
                            isRun = true;
                            justBones.CopyTo(previousAnimation, 0);
                        }

                    }
                }
                else if (moveState == 1 & !isAtk1)
                {
                   // dToT = Vector3.Distance(position, ScreenManager.Theseus.Position);
                    dToP = Vector3.Distance(position, plannedPosition);
                    if (dToT < 60)
                    {
                        moveState = 0;
                    }
                    else
                    {
                        if (dToP < 10)
                        {
                            havePlannedPosition = false;
                            setSpheres.Clear();
                            moveState = 0;
                        }

                        if (setSpheres.Count > 0)
                        {
                            dToS = Vector3.Distance(position + new Vector3(0.0f, 70.0f, 0.0f), setSpheres[0].Center);
                            if (dToS > 5)
                            {
                                thrustAmount = 1.0f;
                                if (!isRun)
                                {
                                    isRun = true;
                                    justBones.CopyTo(previousAnimation, 0);
                                }
                            }
                            else
                            {
                                setSpheres.RemoveAt(0);
                                if (setSpheres.Count == 0)
                                {
                                    havePlannedPosition = false;
                                    moveState = 0;
                                }
                            }
                        }
                        else
                        {
                            isRun = false;
                            thrustAmount = 0.0f;
                        }

                        if (havePlannedPosition)
                        {

                            if (setSpheres.Count == 0)
                            {
                                miniPathSet = false;

                                int thisI = 0;
                                int thisJ = 0;
                                //were being used so that the first setshpere was valid
                                //int startI = 0;
                                //int startJ = 0;
                                float lowest = 99999999;
                                float check = 0;
                                for (int i = 0; i < 5; i++)
                                    for (int j = 0; j < 5; j++)
                                    {
                                        if (open[i][j])
                                        {
                                            check = Vector3.Distance(moveSpheres[i][j].Center, plannedPosition);
                                            if (check < lowest)
                                            {
                                                thisI = i;
                                                thisJ = j;
                                                lowest = check;
                                            }
                                        }
                                    }
                                if (open[2][2] == false)
                                {
                                    for (int i = 1; i < 3; i++)
                                    {
                                        for (int j = 1; j < 3; j++)
                                        {
                                            if (open[i][j])
                                            {

                                            }
                                        }
                                    }

                                }

                                

                                Reset(new Point(2, 2), new Point(thisI, thisJ));
                                JsearchStatus = JSearchStatus.Searching;

                                while (JsearchStatus == JSearchStatus.Searching)
                                {

                                    DoSearchStep();
                                }

                                if (myJSearchStatus == JSearchStatus.PathFound)
                                {
                                    //just to get to first point
                                    moveState = 1;
                                    foreach (Point point in FinalPath())
                                    {
                                        setSpheres.Add(moveSpheres[point.X][point.Y]);
                                    }
                                    if (setSpheres.Count == 1)
                                    {
                                        setSpheres.Clear();
                                        moveState = 0;
                                    }
                                }
                                if (myJSearchStatus == JSearchStatus.NoPath)
                                {
                                    moveState = 0;
                                    havePlannedPosition = false;
                                    setSpheres.Clear();

                                }

                                if (!miniPathSet)
                                {
                                    miniPathSet = true;
                                }

                            }

                        }
                        else if (!havePlannedPosition)
                        {
                            aiDecisionTimer += gameTime.ElapsedGameTime;
                            isRun = false;
                            thrustAmount = 0.0f;
                            runTime = TimeSpan.Zero;
                            double split = rand.NextDouble();
                            cutOffTime = cutOffTime = TimeSpan.FromMilliseconds(maxDecisionTimer.TotalMilliseconds * split);
                            if (cutOffTime < minDecisionTimer)
                                cutOffTime = minDecisionTimer;

                            if (aiDecisionTimer > cutOffTime)
                            {
                                havePlannedPosition = false;
                                aiDecisionTimer = TimeSpan.Zero;
                            }



                        }

                        if (setSpheres.Count > 0)
                            rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    }



                }
                if (moveState == 3 & !isAtk1)
                {
                    waitTime -= gameTime.ElapsedGameTime;

                    if (waitTime < TimeSpan.Zero)
                    {
                        moveState = 0;
                        waitTime = TimeSpan.Zero;
                    }

                    isRun = false;
                    thrustAmount = 0.0f;


                }
            }
            else
            {
                if (!isDead)
                {
                    isDead = true;
                    justBones.CopyTo(previousAnimation, 0);
                    isRun = false;
                    thrustAmount = 0.0f;
                    currentAnimationTime = TimeSpan.Zero;




                }




            }
            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);
            if (thrustAmount>0.0f)
                Position += Direction * thrustAmount * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;

            if (isRun)
                updateRun(gameTime);
            if (isAtk1)
                UpdateBasic1(gameTime);
            else if (isAtk2)
                UpdateBasic2(gameTime);
            else if (isAtk3)
                UpdateBasic3(gameTime);
            else if (isHammerFlight)
                UpdateHammerFlight(gameTime);
            else if (isDead)
                UpdateDead(gameTime);
            else if (isKnockBack)
                UpdateKnockBack(gameTime);
            else if (isKnockDown)
                updateKnockDown(gameTime);

            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1 || isAtk2 || isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockDown)
                upperBones.CopyTo(justBones, 0);
            else if (isHammerFlight)
                upperBones.CopyTo(justBones, 0);
            else if (isDead)
                upperBones.CopyTo(justBones, 0);
            else
                standing.CopyTo(justBones, 0);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;

            for (int i = 0; i < 2; i++)
            {
                futureMovement.Add(new BoundingSphere((Position + new Vector3(0.0f, 70.0f, 0.0f)) + Direction * 51.2f *
                                   (i + 1), collisionS[1].BS.Radius));


            }
            collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
            collisionBox = new BoundingBox(Position - new Vector3(12.8f, 0.0f, 12.8f), Position + new Vector3(12.8f, 70.0f, 12.8f));
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            checkMove3(gameTime);

            //open[2][2] = true;
            //for (int a = 0; a < ScreenManager.dummies.Count; a++)
            //{
            //    if (fighterIndex != ScreenManager.dummies[a].fighterIndex)
            //        if (moveSpheres[2][2].Contains(ScreenManager.dummies[a].collisionS[1].BS) != ContainmentType.Disjoint)
            //            open[2][2] = false;

            //}
            if (open[2][2] = false)
            {
                separate(gameTime);


            }

        }
        public void separate(GameTime gameTime)
        {
            getCollisions();
            int index1 = -1;
            int index2 = 0;
            if (open[2][2] == false)
            {
                for (int i = 0; i < 3; i++)
                    for (int j = 0; j < 3; j++)
                    {
                        IncOpen[i][j] = false;
                        for (int a = 0; a < ScreenManager.dummies.Count; a++)
                        {
                            if (IncrementalSpheres[i][j].Contains(ScreenManager.dummies[a].collisionS[1].BS) == ContainmentType.Disjoint)
                            {
                                IncOpen[i][j] = true;
                                index1 = i;
                                index2 = j;
                                break;
                            }
                        }


                    }

                int rand = ScreenManager.rand.Next(8);
                int counter = 0;
                int c = -1;
                int d = 0; 
                for(int i = 0 ; i< 3; i++)
                    for (int j = 0; j < 3; j++)
                    {

                        if (counter == rand)
                            break;

                        if (IncOpen[i][j])
                        {
                            c = i;
                            d = j;

                            counter++;
                        }

                    }

                if (c != -1)
                {
                    float rotationAmount = 0.0f;
                    rotationAmount = TurnToFace(Position,IncrementalSpheres[c][d].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    float x = (float)Math.Sin(rotationAmount);
                    float y = (float)Math.Cos(rotationAmount);
                    sepDirection = new Vector3(x, 0.0f, y);

 
                            //ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].Position += sepDirection * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;
                            //ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].collisionS[1].BS = new BoundingSphere(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
                            position -= sepDirection * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;
                            collisionS[1].BS = new BoundingSphere(position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
                            position = IncrementalSpheres[c][d].Center;
                            collisionS[1].BS = new BoundingSphere(position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
        



                }
           


            }




        }
        public void UpdateAI3(GameTime gameTime)
        {
            if (fighterIndex == 13)
                Console.WriteLine("#");
            futureMovement.Clear();
            float rotationAmount = 0.0f;
            float dToP = 0.0f;
            float dToS = 0.0f;
            float dToT = 0.0f;
            oldPosition = position;
            cullSphere = new BoundingSphere(position + new Vector3(0.0f, 70.0f, 0.0f), 204.8f);
            List<int> unculledDummies = new List<int>();
            if (health > 0)
            {
                for (int i2 = 0; i2 < 5; i2++)
                    for (int j2 = 0; j2 < 5; j2++)
                    {
                        moveSpheres[i2][j2] = new BoundingSphere(position - new Vector3(102.4f - 51.2f * (float)(i2), -70.0f, 102.4f - 51.2f * (float)(j2)), 25.6f);
                        // moveSpheres[i2][j2] = new BoundingSphere(position - new Vector3(51.2f - 25.6f * (float)(i2), -70.0f, 51.2f - 25.6f * (float)(j2)), 12.8f);
                    }
                for (int i = 0; i < ScreenManager.dummies.Count; i++)
                {
                    if (i != fighterIndex)
                    {

                        if (cullSphere.Contains(ScreenManager.dummies[i].collisionS[1].BS) != ContainmentType.Disjoint)
                        {
                            unculledDummies.Add(i);

                        }
                    }
                }
                for (int i = 0; i < unculledDummies.Count; i++)
                    if (setSpheres.Count == 1)
                    {
                        if (setSpheres[0].Contains(ScreenManager.dummies[unculledDummies[i]].collisionS[1].BS) != ContainmentType.Disjoint)
                        {
                            setSpheres.Clear();
                            havePlannedPosition = false;
                        }

                    }
                if (setSpheres.Count == 1)
                    if (setSpheres[0].Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                    {
                        setSpheres.Clear();
                        havePlannedPosition = false;
                    }
                for (int i = 0; i < 5; i++)
                    for (int j = 0; j < 5; j++)
                    {
                        open[i][j] = true;
                        for(int a =0; a<ScreenManager.runners.Count; a++)
                        if (moveSpheres[i][j].Contains(ScreenManager.runners[a].collisionS[1].BS) != ContainmentType.Disjoint)
                            open[i][j] = false;
                        if (moveSpheres[i][j].Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                            open[i][j] = false;
                        if (moveSpheres[i][j].Center.X < 0 || moveSpheres[i][j].Center.X > 1200 ||
          moveSpheres[i][j].Center.Z < 0 || moveSpheres[i][j].Center.Z > 1200)
                        {
                            open[i][j] = false;
                            //break
                        }
                        for (int k = 0; k < unculledDummies.Count; k++)
                        {
                            if (moveSpheres[i][j].Contains(ScreenManager.dummies[unculledDummies[k]].collisionS[1].BS) != ContainmentType.Disjoint)
                            {
                                open[i][j] = false;
                                // break;
                            }
                            for (int m = 0; m < ScreenManager.dummies[k].setSpheres.Count && m < 1; m++)
                            {
                                if (moveSpheres[i][j].Contains(ScreenManager.dummies[k].setSpheres[m]) != ContainmentType.Disjoint)
                                {
                                    open[i][j] = false;
                                    //break;
                                }
                            }
                        }
                    }

                dToT = Vector3.Distance(position, ScreenManager.Theseus.Position);
                if (dToT < 55)
                {
                    rotationAmount = TurnToFace(position, ScreenManager.Theseus.Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    if (!isAtk1)
                    {
                        isAtk1 = true;
                        justBones.CopyTo(previousAnimation, 0);
                    }
                    thrustAmount = 0.0f;
                    isRun = false;



                }
                else if (dToT < 200)
                {
                    plannedPosition = ScreenManager.Theseus.Position;
                    havePlannedPosition = true;


                }
                else if (!havePlannedPosition)
                {
                    int i = 0;
                    int j = 0;
                    int randomNumber = ScreenManager.rand.Next(25);

                    int counter = 0;
                    for (int i2 = 0; i2 < 5; i2++)
                    {
                        for (int j2 = 0; j2 < 5; j2++)
                        {
                            if (counter == randomNumber)
                            {
                                // i = i2;
                                //  j = j2;
                                break;
                            }

                            if (open[i2][j2])
                            {
                                i = i2;
                                j = j2;
                                counter++;
                            }

                        }
                        if (counter == randomNumber)
                            break;
                    }
                    plannedPosition = moveSpheres[i][j].Center - new Vector3(0.0f, 70.0f, 0.0f);
                    havePlannedPosition = true;
                }

                if (moveState == 0 & !isAtk1)
                {
                    dToT = Vector3.Distance(position, ScreenManager.Theseus.Position);
                    dToP = Vector3.Distance(position, plannedPosition);
                    rotationAmount = TurnToFace(position, plannedPosition, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    //if (dToT < 60)
                    //{
                    //    rotationAmount = TurnToFace(position, ScreenManager.Theseus.Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    //    if (!isAtk1)
                    //    {
                    //        isAtk1 = true;
                    //        justBones.CopyTo(previousAnimation, 0);
                    //    }
                    //    thrustAmount = 0.0f;
                    //    isRun = false;



                    //}

                    if (dToP < 10)
                    {
                        havePlannedPosition = false;
                        setSpheres.Clear();
                    }
                    else
                    {
                        thrustAmount = 1.0f;
                        if (!isRun)
                        {
                            isRun = true;
                            justBones.CopyTo(previousAnimation, 0);
                        }

                    }
                }
                else if (moveState == 1 & !isAtk1)
                {
                    dToT = Vector3.Distance(position, ScreenManager.Theseus.Position);
                    dToP = Vector3.Distance(position, plannedPosition);
                    if (dToT < 60)
                    {
                        moveState = 0;
                    }
                    else
                    {
                        if (dToP < 10)
                        {
                            havePlannedPosition = false;
                            setSpheres.Clear();
                            moveState = 0;
                        }

                        if (setSpheres.Count > 0)
                        {
                            dToS = Vector3.Distance(position + new Vector3(0.0f, 70.0f, 0.0f), setSpheres[0].Center);
                            if (dToS > 10)
                            {
                                thrustAmount = 1.0f;
                                if (!isRun)
                                {
                                    isRun = true;
                                    justBones.CopyTo(previousAnimation, 0);
                                }
                            }
                            else
                            {
                                setSpheres.RemoveAt(0);
                                if (setSpheres.Count == 0)
                                {
                                    havePlannedPosition = false;
                                    moveState = 0;
                                }
                            }
                        }
                        else
                        {
                            isRun = false;
                            thrustAmount = 0.0f;
                        }

                        if (havePlannedPosition)
                        {

                            if (setSpheres.Count == 0)
                            {
                                miniPathSet = false;

                                int thisI = 0;
                                int thisJ = 0;
                                //were being used so that the first setshpere was valid
                                //int startI = 0;
                                //int startJ = 0;
                                float lowest = 99999999;
                                float check = 0;
                                for (int i = 0; i < 5; i++)
                                    for (int j = 0; j < 5; j++)
                                    {
                                        if (open[i][j])
                                        {
                                            check = Vector3.Distance(moveSpheres[i][j].Center, plannedPosition);
                                            if (check < lowest)
                                            {
                                                thisI = i;
                                                thisJ = j;
                                                lowest = check;
                                            }
                                        }
                                    }
                                if (open[2][2] == false)
                                {
                                    for (int i = 1; i < 3; i++)
                                    {
                                        for (int j = 1; j < 3; j++)
                                        {
                                            if (open[i][j])
                                            {

                                            }
                                        }
                                    }

                                }


                                Reset(new Point(2, 2), new Point(thisI, thisJ));
                                JsearchStatus = JSearchStatus.Searching;

                                while (JsearchStatus == JSearchStatus.Searching)
                                {

                                    DoSearchStep();
                                }

                                if (myJSearchStatus == JSearchStatus.PathFound)
                                {
                                    //just to get to first point
                                    moveState = 1;
                                    foreach (Point point in FinalPath())
                                    {
                                        setSpheres.Add(moveSpheres[point.X][point.Y]);
                                    }
                                    if (setSpheres.Count == 1)
                                    {
                                        setSpheres.Clear();
                                        moveState = 0;
                                    }
                                }
                                if (myJSearchStatus == JSearchStatus.NoPath)
                                {
                                    moveState = 0;
                                    havePlannedPosition = false;
                                    setSpheres.Clear();

                                }

                                if (!miniPathSet)
                                {
                                    miniPathSet = true;
                                }

                            }

                        }
                        else if (!havePlannedPosition)
                        {
                            aiDecisionTimer += gameTime.ElapsedGameTime;
                            isRun = false;
                            thrustAmount = 0.0f;
                            runTime = TimeSpan.Zero;
                            double split = rand.NextDouble();
                            cutOffTime = cutOffTime = TimeSpan.FromMilliseconds(maxDecisionTimer.TotalMilliseconds * split);
                            if (cutOffTime < minDecisionTimer)
                                cutOffTime = minDecisionTimer;

                            if (aiDecisionTimer > cutOffTime)
                            {
                                havePlannedPosition = false;
                                aiDecisionTimer = TimeSpan.Zero;
                            }



                        }

                        if (setSpheres.Count > 0)
                            rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    }



                }
                if (moveState == 3 & !isAtk1)
                {
                    waitTime -= gameTime.ElapsedGameTime;

                    if (waitTime < TimeSpan.Zero)
                    {
                        moveState = 0;
                        waitTime = TimeSpan.Zero;
                    }

                    isRun = false;
                    thrustAmount = 0.0f;


                }
            }
            else
            {
                if (!isDead)
                {
                    isDead = true;
                    justBones.CopyTo(previousAnimation, 0);
                    isRun = false;
                    thrustAmount = 0.0f;
                    currentAnimationTime = TimeSpan.Zero;




                }




            }
            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);
            if (isRun)
                Position += Direction * thrustAmount * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;

            if (isRun)
                updateRun(gameTime);
            if (isAtk1)
                UpdateBasic1(gameTime);
            else if (isAtk2)
                UpdateBasic2(gameTime);
            else if (isAtk3)
                UpdateBasic3(gameTime);
            else if (isHammerFlight)
                UpdateHammerFlight(gameTime);
            else if (isDead)
                UpdateDead(gameTime);
            else if (isKnockBack)
                UpdateKnockBack(gameTime);
            else if (isKnockDown)
                updateKnockDown(gameTime);

            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1 || isAtk2 || isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockDown)
                upperBones.CopyTo(justBones, 0);
            else if (isHammerFlight)
                upperBones.CopyTo(justBones, 0);
            else if (isDead)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;

            for (int i = 0; i < 2; i++)
            {
                futureMovement.Add(new BoundingSphere((Position + new Vector3(0.0f, 70.0f, 0.0f)) + Direction * 51.2f *
                                   (i + 1), collisionS[1].BS.Radius));


            }
            collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            checkMove3(gameTime);


        }

        public void UpdateAI2(GameTime gameTime)
        
        {
           // setSpheres.Clear();
            futureMovement.Clear();
            float rotationAmount = 0.0f;
            float dToP = 0.0f;
            float dToS = 0.0f;
            float dToT = 0.0f;
            oldPosition = position;
            cullSphere = new BoundingSphere(position + new Vector3(0.0f, 70.0f, 0.0f), 204.8f);
            List<int> unculledDummies = new List<int>();


            for (int i2 = 0; i2 < 5; i2++)
                for (int j2 = 0; j2 < 5; j2++)
                {
                    moveSpheres[i2][j2] = new BoundingSphere(position - new Vector3(102.4f - 51.2f * (float)(i2), -70.0f, 102.4f - 51.2f * (float)(j2)), 25.6f);
                   // moveSpheres[i2][j2] = new BoundingSphere(position - new Vector3(51.2f - 25.6f * (float)(i2), -70.0f, 51.2f - 25.6f * (float)(j2)), 12.8f);
                }
            for (int i = 0; i < ScreenManager.dummies.Count; i++)
            {
                if (i != fighterIndex)
                {
              
                    if (cullSphere.Contains(ScreenManager.dummies[i].collisionS[1].BS) != ContainmentType.Disjoint)
                    {
                        unculledDummies.Add(i);

                    }
                }
             }
            for (int i = 0; i < unculledDummies.Count; i++)
                if (setSpheres.Count == 1)
                {
                    if (setSpheres[0].Contains(ScreenManager.dummies[unculledDummies[i]].collisionS[1].BS) != ContainmentType.Disjoint)
                    {
                        setSpheres.Clear();
                        havePlannedPosition = false;
                    }

                }
            if (setSpheres.Count == 1)
                if (setSpheres[0].Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                {
                    setSpheres.Clear();
                    havePlannedPosition = false;
                }
            for (int i = 0; i < 5; i++)
                for (int j = 0; j < 5; j++)
                {
                    open[i][j] = true;
                    if (moveSpheres[i][j].Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                        open[i][j] = false;
                    if (moveSpheres[i][j].Center.X < 0 || moveSpheres[i][j].Center.X > 1200 ||
      moveSpheres[i][j].Center.Z < 0 || moveSpheres[i][j].Center.Z > 1200)
                    {
                        open[i][j] = false;
                        //break
                    }
                    //if(open[i][j])
                    //for (int l = 0; l < outOfWayFor.Count; l++)
                    //{
                    //    for (int m = 0; m < ScreenManager.dummies[outOfWayFor[l]].setSpheres.Count; m++)
                    //    {
                    //        if (moveSpheres[i][j].Contains(ScreenManager.dummies[outOfWayFor[l]].setSpheres[m]) != ContainmentType.Disjoint)
                    //        {
                    //            open[i][j] = false;
                    //            // break;
                    //        }

                    //    }


                    //}
                    for (int k = 0; k < unculledDummies.Count; k++)
                    {
  

                        //for (int m = 2; m < 2; m++)
                        //{
                        //    if(moveSpheres[i][j].Contains(ScreenManager.dummies[k].futureMovement[m]) != ContainmentType.Disjoint)
                        //    open[i][j] = false;
                        //    break;
                        //}

                        if (moveSpheres[i][j].Contains(ScreenManager.dummies[unculledDummies[k]].collisionS[1].BS) != ContainmentType.Disjoint)
                        {
                            open[i][j] = false;
                           // break;
                        }
                        
                        for (int m = 0; m < ScreenManager.dummies[k].setSpheres.Count && m < 1; m++)
                        {
                            if (moveSpheres[i][j].Contains(ScreenManager.dummies[k].setSpheres[m]) != ContainmentType.Disjoint)
                            {
                                open[i][j] = false;
                                //break;
                            }
                        }
                    }
                }
            //open[2][2] = true;
            #region aistate2
            if (aiState == 0)
            
            {
                dToT = Vector3.Distance(Position, ScreenManager.Theseus.Position);
                if (dToT < 200)
                {
                    plannedPosition = ScreenManager.Theseus.Position;
                    havePlannedPosition = true;


                    //int thisI = 0;
                    //int thisJ = 0;
                    //float lowest = 99999999;
                    //float check = 0;
                    //for (int i = 1; i < 4; i++)
                    //    for (int j = 1; j < 4; j++)
                    //    {
                    //        if (i != 2 || j != 2)
                    //        {
                    //            if (ScreenManager.Theseus.open[i][j])
                    //            {
                    //                check = Vector3.Distance(ScreenManager.Theseus.moveSpheres[i][j].Center, Position);
                    //                if (check < lowest)
                    //                {
                    //                    thisI = i;
                    //                    thisJ = j;
                    //                    lowest = check;
                    //                }
                    //            }



                    //        }
                    //    }







                }
                if (!havePlannedPosition)
                {
                    int i = 0;
                    int j = 0;
                    int randomNumber = ScreenManager.rand.Next(25);

                    int counter = 0;
                    for (int i2 = 0; i2 < 5; i2++)
                    {
                        for (int j2 = 0; j2 < 5; j2++)
                        {
                            if (counter == randomNumber)
                            {
                               // i = i2;
                              //  j = j2;
                                break;
                            }

                            if (open[i2][j2])
                            {
                                i = i2;
                                j = j2;
                                counter++;
                            }

                        }
                        if (counter == randomNumber)
                            break;
                    }
                    plannedPosition = moveSpheres[i][j].Center - new Vector3(0.0f, 70.0f, 0.0f);
                    havePlannedPosition = true;
                }
                //    if (moveState == 0)
                //    {
                //        dToP = Vector3.Distance(position, plannedPosition);
                //        rotationAmount = TurnToFace(position, plannedPosition, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                //        if (dToP > 10.0f)
                //        {
                //            thrustAmount = 1.0f;
                //            if (!isRun)
                //            {
                //                isRun = true;
                //                justBones.CopyTo(previousAnimation, 0);
                //            }
                //        }
                //        else
                //        {
                //            aiDecisionTimer += gameTime.ElapsedGameTime;
                //            isRun = false;
                //            thrustAmount = 0.0f;
                //            runTime = TimeSpan.Zero;
                //            double split = rand.NextDouble();
                //            cutOffTime = cutOffTime = TimeSpan.FromMilliseconds(maxDecisionTimer.TotalMilliseconds * split);
                //            if (cutOffTime < minDecisionTimer)
                //                cutOffTime = minDecisionTimer;

                //            if (aiDecisionTimer > cutOffTime)
                //            {
                //                havePlannedPosition = false;
                //                aiDecisionTimer = TimeSpan.Zero;
                //            }

                //        }


                //    }
                //}
                // if (moveState == 1)
                {
                    dToP = Vector3.Distance(position, plannedPosition);
                    if (dToP < 10)
                    {
                        havePlannedPosition = false;
                        setSpheres.Clear();
                    }
                        
                    
                    if (setSpheres.Count > 0)
                    {
                        dToS = Vector3.Distance(position + new Vector3(0.0f, 70.0f, 0.0f), setSpheres[0].Center);
                        if (dToS > 10)
                        {
                            thrustAmount = 1.0f;
                            if (!isRun)
                            {
                                isRun = true;
                                justBones.CopyTo(previousAnimation, 0);
                            }
                        }
                        else
                        {
                            setSpheres.RemoveAt(0);
                            if (setSpheres.Count == 0)
                                havePlannedPosition = false;
                        }

                    }

                    else
                    {
                        isRun = false;
                        thrustAmount = 0.0f;
                    }

                    if (havePlannedPosition)
                    {

                        if (setSpheres.Count == 0)
                        {
                            miniPathSet = false;

                            int thisI = 0;
                            int thisJ = 0;
                            //were being used so that the first setshpere was valid
                            //int startI = 0;
                            //int startJ = 0;
                            float lowest = 99999999;
                            float check = 0;
                            for (int i = 0; i < 5; i++)
                                for (int j = 0; j < 5; j++)
                                {
                                    if (open[i][j])
                                    {
                                        check = Vector3.Distance(moveSpheres[i][j].Center, plannedPosition);
                                        if (check < lowest)
                                        {
                                            thisI = i;
                                            thisJ = j;
                                            lowest = check;
                                        }
                                    }
                                }
                            if (open[2][2] == false)
                            {
                                for (int i = 1; i < 3; i++)
                                {
                                    for (int j = 1; j < 3; j++)
                                    {
                                        if (open[i][j])
                                        {

                                        }
                                    }
                                }

                            }


                            Reset(new Point(2, 2), new Point(thisI, thisJ));
                            JsearchStatus = JSearchStatus.Searching;

                            while (JsearchStatus == JSearchStatus.Searching)
                            {

                                DoSearchStep();
                            }

                            if (myJSearchStatus == JSearchStatus.PathFound)
                            {
                                //just to get to first point
                                moveState = 0;
                                foreach (Point point in FinalPath())
                                {
                                    setSpheres.Add(moveSpheres[point.X][point.Y]);
                                }
                            }
                            if (myJSearchStatus == JSearchStatus.NoPath)
                            {
                                moveState = 0;
                                havePlannedPosition = false;
                                setSpheres.Clear();

                            }

                            if (!miniPathSet)
                            {
                                miniPathSet = true;
                            }

                        }

                    }
                    else if (!havePlannedPosition)
                    {
                        aiDecisionTimer += gameTime.ElapsedGameTime;
                        isRun = false;
                        thrustAmount = 0.0f;
                        runTime = TimeSpan.Zero;
                        double split = rand.NextDouble();
                        cutOffTime = cutOffTime = TimeSpan.FromMilliseconds(maxDecisionTimer.TotalMilliseconds * split);
                        if (cutOffTime < minDecisionTimer)
                            cutOffTime = minDecisionTimer;

                        if (aiDecisionTimer > cutOffTime)
                        {
                            havePlannedPosition = false;
                            aiDecisionTimer = TimeSpan.Zero;
                        }



                    }

                    if (setSpheres.Count > 0)
                        rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                }
            }
            #endregion
            #region aistate1
            if (aiState ==2 )
            {
                plannedPosition = ScreenManager.Theseus.Position;
                dToP = Vector3.Distance(position, plannedPosition);
                if (dToP < 60)
                {
                    isAtk1 = true;
                    //setSpheres.Clear();
                    rotationAmount = TurnToFace(position, plannedPosition, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                }

                if (moveState == 1)
                {
                    if (setSpheres.Count > 0)
                    {

                        dToS = Vector3.Distance(position + new Vector3(0.0f, 70.0f, 0.0f), setSpheres[0].Center);
                        rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                        if (dToS > 10)
                        {
                            thrustAmount = 1.0f;
                            if (!isRun)
                            {
                                isRun = true;
                                justBones.CopyTo(previousAnimation, 0);
                            }
                        }

                        else
                        {
                            setSpheres.RemoveAt(0);
                            //if (setSpheres.Count == 0)
                            // havePlannedPosition = false;
                        }
                    }
                    else
                    {
                        isRun = false;
                        thrustAmount = 0.0f;
                    }


                    if (dToP > 60 & !isAtk1)
                    {
                        if (setSpheres.Count == 0)
                        {

                            miniPathSet = false;
                            bool mustMove = false;
                            bool safeMove = false;
                            if (open[2][2] == false)
                            {
                                mustMove = true;
                                for (int i = 1; i < 4; i++)
                                {
                                    for (int j = 1; j < 4; j++)
                                    {
                                        if (open[i][j])
                                        {
                                            targetI = i;
                                            targetJ = j;
                                            safeMove = true;
                                            break;
                                        }

                                    }
                                    if (safeMove)
                                        break;
                                }
                            }
                            float rot2 = 0.0f;
                            Vector3 dir2 = Vector3.Zero;
                            //if (mustMove && safeMove)
                            //{

                            //    rot2 = TurnToFace(position, moveSpheres[targetI][targetJ].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                            //    float x2 = (float)Math.Sin(rot2);
                            //    float y2 = (float)Math.Cos(rot2);
                            //    dir2 = new Vector3(x2, 0.0f, y2);
                            //    Position += dir2 * (float)gameTime.ElapsedGameTime.TotalSeconds * 1.0f;
                            //    collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);

                            //    for (int j = 0; j < unculledDummies.Count; j++)
                            //    {
                            //        while (collisionS[1].BS.Contains(ScreenManager.dummies[unculledDummies[j]].collisionS[1].BS) != ContainmentType.Disjoint)
                            //        {
                            //            Position += dir2 * (float)gameTime.ElapsedGameTime.TotalSeconds * 1.0f;
                            //            collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);

                            //        }


                            //    }

                            //}
                            if (mustMove & !safeMove)
                            {

                            }
                            int thisI = 0;
                            int thisJ = 0;
                            float lowest = 99999999;
                            float check = 0;
                            for (int i = 0; i < 5; i++)
                                for (int j = 0; j < 5; j++)
                                {
                                    if (open[i][j])
                                    {
                                        check = Vector3.Distance(moveSpheres[i][j].Center, plannedPosition);
                                        if (check < lowest)
                                        {
                                            thisI = i;
                                            thisJ = j;
                                            lowest = check;
                                        }
                                    }
                                }


                            Reset(new Point(2, 2), new Point(thisI, thisJ));
                            JsearchStatus = JSearchStatus.Searching;

                            while (JsearchStatus == JSearchStatus.Searching)
                            {

                                DoSearchStep();
                            }

                            if (myJSearchStatus == JSearchStatus.PathFound)
                            {
                                //just to get to first point
                                moveState = 0;
                                foreach (Point point in FinalPath())
                                {
                                    setSpheres.Add(moveSpheres[point.X][point.Y]);
                                }
                            }
                            if (myJSearchStatus == JSearchStatus.NoPath)
                            {
                                moveState = 0;
                                havePlannedPosition = false;
                                setSpheres.Clear();

                            }

                            if (!miniPathSet)
                            {
                                miniPathSet = true;
                            }


                        }


                    }
                    else if (dToP > 60 && isAtk1)
                    {




                    }
                    else if (dToP <= 60 && isAtk1)
                    {





                    }
                }
                else if (moveState == 0)
                {
                    plannedPosition = ScreenManager.Theseus.Position;

                    dToP = Vector3.Distance(position + new Vector3(0.0f, 70.0f, 0.0f), plannedPosition);
                    rotationAmount = TurnToFace(position, plannedPosition, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                    if (dToP > 60)
                    {
                        thrustAmount = 1.0f;
                        if (!isRun)
                        {
                            isRun = true;
                            justBones.CopyTo(previousAnimation, 0);
                        }
                    }
                    else
                    {
                       
                            isAtk1 = true;
                            //setSpheres.Clear();
                            rotationAmount = TurnToFace(position, plannedPosition, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                        


                    }







                }


            }
            #endregion
            if (aiState == 1)
            {
                if (moveState != 3)
                {
                    plannedPosition = ScreenManager.Theseus.Position;
                    dToP = Vector3.Distance(position, plannedPosition);
                    if (dToP < 60)
                    {
                        isAtk1 = true;
                        //setSpheres.Clear();
                        rotationAmount = TurnToFace(position, plannedPosition, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                        thrustAmount = 0.0f;
                        isRun = false;
                        //setSpheres.Clear();
                    }
                    //else
                    //{
                    //    rotationAmount = TurnToFace(position, plannedPosition, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    //    thrustAmount = 1.0f;
                    //    if (!isRun)
                    //    {
                    //        isRun = true;
                    //        justBones.CopyTo(previousAnimation, 0);
                    //    }

                    //}
                    //}
                    else
                        if (setSpheres.Count > 0)
                        {

                            dToS = Vector3.Distance(position + new Vector3(0.0f, 70.0f, 0.0f), setSpheres[0].Center);
                            rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                            if (dToS > 10)
                            {
                                thrustAmount = 1.0f;
                                if (!isRun)
                                {
                                    isRun = true;
                                    justBones.CopyTo(previousAnimation, 0);
                                }
                            }

                            else
                            {
                                setSpheres.RemoveAt(0);
                                //if (setSpheres.Count == 0)
                                // havePlannedPosition = false;
                            }
                        }
                        else
                        {
                            isRun = false;
                            thrustAmount = 0.0f;
                        }


                    if (dToP > 60 & !isAtk1)
                    {
                        if (setSpheres.Count == 0)
                        {

                            miniPathSet = false;
                            bool mustMove = false;
                            bool safeMove = false;
                            if (open[2][2] == false)
                            {
                                mustMove = true;
                                for (int i = 1; i < 4; i++)
                                {
                                    for (int j = 1; j < 4; j++)
                                    {
                                        if (open[i][j])
                                        {
                                            targetI = i;
                                            targetJ = j;
                                            safeMove = true;
                                            break;
                                        }

                                    }
                                    if (safeMove)
                                        break;
                                }
                            }
                            float rot2 = 0.0f;
                            Vector3 dir2 = Vector3.Zero;
                            //if (mustMove && safeMove)
                            //{

                            //    rot2 = TurnToFace(position, moveSpheres[targetI][targetJ].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                            //    float x2 = (float)Math.Sin(rot2);
                            //    float y2 = (float)Math.Cos(rot2);
                            //    dir2 = new Vector3(x2, 0.0f, y2);
                            //    Position += dir2 * (float)gameTime.ElapsedGameTime.TotalSeconds * 1.0f;
                            //    collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);

                            //    for (int j = 0; j < unculledIndices.Count; j++)
                            //    {
                            //        while (collisionS[1].BS.Contains(ScreenManager.dummies[unculledIndices[j]].collisionS[1].BS) != ContainmentType.Disjoint)
                            //        {
                            //            Position += dir2 * (float)gameTime.ElapsedGameTime.TotalSeconds * 1.0f;
                            //            collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);

                            //        }


                            //    }

                            //}
                            //if (mustMove & !safeMove)
                            //{

                            //}
                            int thisI = 0;
                            int thisJ = 0;
                            float lowest = 99999999;
                            float check = 0;
                            for (int i = 0; i < 5; i++)
                                for (int j = 0; j < 5; j++)
                                {
                                    if (open[i][j])
                                    {
                                        check = Vector3.Distance(moveSpheres[i][j].Center, plannedPosition);
                                        if (check < lowest)
                                        {
                                            thisI = i;
                                            thisJ = j;
                                            lowest = check;
                                        }
                                    }
                                }


                            Reset(new Point(2, 2), new Point(thisI, thisJ));
                            JsearchStatus = JSearchStatus.Searching;

                            while (JsearchStatus == JSearchStatus.Searching)
                            {

                                DoSearchStep();
                            }

                            if (myJSearchStatus == JSearchStatus.PathFound)
                            {
                                //just to get to first point
                                moveState = 1;
                                foreach (Point point in FinalPath())
                                {
                                    setSpheres.Add(moveSpheres[point.X][point.Y]);
                                }
                                if (setSpheres.Count == 1)
                                    setSpheres.Clear();
                            }
                            if (myJSearchStatus == JSearchStatus.NoPath)
                            {
                                moveState = 2;
                                havePlannedPosition = false;
                                setSpheres.Clear();

                            }

                            if (!miniPathSet)
                            {
                                miniPathSet = true;
                            }


                        }


                    }
                    else if (dToP > 60 && isAtk1)
                    {




                    }
                    else if (dToP <= 60 && isAtk1)
                    {





                    }


                }
                if(moveState == 3)
                {
                    waitTime -= gameTime.ElapsedGameTime;

                    if (waitTime < TimeSpan.Zero)
                    {
                        moveState = 0;
                        waitTime = TimeSpan.Zero;
                    }

                    isRun = false;
                    thrustAmount = 0.0f;


                }
            }
            //moveState = 0;
            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);
            if (isRun)
                Position += Direction * thrustAmount * (float)gameTime.ElapsedGameTime.TotalSeconds * 100.0f;

            if (isRun)
                updateRun(gameTime);
            if (isAtk1)
                UpdateBasic1(gameTime);
            else if (isAtk2)
                UpdateBasic2(gameTime);
            else if (isAtk3)
                UpdateBasic3(gameTime);
            else if (isHammerFlight)
                UpdateHammerFlight(gameTime);
            if (isKnockBack)
                UpdateKnockBack(gameTime);
            if (isKnockDown)
                updateKnockDown(gameTime);

            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1 || isAtk2 || isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockDown)
                upperBones.CopyTo(justBones, 0);
            else if (isHammerFlight)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);

            //if (isRun)
            //{
            //    newPosition = Position + new Vector3(Direction.X, Direction.Y, Direction.Z) * (float)gameTime.ElapsedGameTime.TotalSeconds * 100 * thrustAmount;
            //    //Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * (float)gameTime.ElapsedGameTime.TotalSeconds * 100 * thrustAmount;
            //    collisionS[1].BS = new BoundingSphere(newPosition + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
            //    collisionS[1].BS = new BoundingSphere(newPosition + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
            //    float cTop = 0.0f;
            //    float cTL = 0.0f;
            //    float cTR = 0.0f;
            //    float cRight = 0.0f;
            //    float cLeft = 0.0f;
            //    float cBot = 0.0f;
            //    float cBL = 0.0f;
            //    float cBR = 0.0f;
            //    float rot2 = 0.0f;
            //    BoundingSphere newSetSphere = new BoundingSphere();
            //    Vector3 Dir2 = Vector3.Zero;
            //    Vector3 sepDirection = Vector3.Zero;
            //    Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * (float)gameTime.ElapsedGameTime.TotalSeconds * 100 * thrustAmount;
            //    collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
            //    collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
            //    getCollisions();
            //    if (collisionCount == 1)
            //        for (int i = 0; i < ScreenManager.dummies.Count; i++)
            //        {
            //            if (i != fighterIndex)
            //            {
            //                if (collisionS[1].BS.Contains(ScreenManager.dummies[i].collisionS[1].BS) != ContainmentType.Disjoint)
            //                {

            //                    rot2 = TurnToFace(position, ScreenManager.dummies[i].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
            //                    x = (float)Math.Sin(rotationAmount);
            //                    y = (float)Math.Cos(rotationAmount);
            //                    sepDirection = new Vector3(x, 0.0f, y);

            //                    cLeft = Vector3.Distance(sepDirection, world.Left);
            //                    cRight = Vector3.Distance(sepDirection, world.Right);

            //                    //if (cLeft < cRight)
            //                    //{

            //                    newSetSphere = new BoundingSphere(oldPosition + new Vector3(0.0f, 70.0f, 0.0f) - sepDirection * 25.6f, 25.6f);

            //                    //}
            //                    //else
            //                    //    newSetSphere = new BoundingSphere(oldPosition + new Vector3(0.0f, 70.0f, 0.0f) - world.Left * -25.6f, 25.6f);
            //                    bool collision = false;
            //                    for (int j = 0; j < ScreenManager.dummies.Count; j++)
            //                        if (newSetSphere.Contains(ScreenManager.dummies[j].collisionS[1].BS) != ContainmentType.Disjoint)
            //                        {
            //                            Position = oldPosition;
            //                            collision = true;
            //                        }
            //                    //else
            //                    if (!collision)
            //                    {
            //                        setSpheres.Insert(0, newSetSphere);
            //                        rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
            //                        x = (float)Math.Sin(rotationAmount);
            //                        y = (float)Math.Cos(rotationAmount);
            //                        Direction = new Vector3(x, 0.0f, y);
            //                        Position = oldPosition + new Vector3(Direction.X, Direction.Y, Direction.Z) * (float)gameTime.ElapsedGameTime.TotalSeconds * 100 * thrustAmount;
            //                    }



            //                }
            //            }


            //        }
            //    else if (collisionCount == 0)
            //    {



            //    }
            //}


            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;

            for(int i = 0; i<2; i++)
            {
                futureMovement.Add(new BoundingSphere((Position + new Vector3(0.0f, 70.0f, 0.0f)) + Direction * 51.2f * 
                                   ( i + 1), collisionS[1].BS.Radius));


            }
            collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            checkMove3(gameTime);
            //checkMoveEnemySingle(gameTime);

        }
        public void checkMoveEnemySingle(GameTime gameTime)
        {
            bool bothInvalid = false;
            bool goLeft = false;
            bool goRight = false;
            bool goForward = false;
            bool goBackward = false;
            //bool 
            bool leftInvalid = false;
            bool rightInvalid = false;
            bool doubleCollision = false;
            Vector3 deltaPosition = Position;
            float rotationAmount = 0.0f;
            Vector3 sepDirection = Vector3.Zero;
            Vector3 delta = Vector3.Zero;
            moveWait = false;

            getCollisions();
            if (collisionCount > 0)
                moveState = 1;

            //if (collisionCount == 1)
            if(collisionCount > 0)
            {
                if (moveState == 3 || moveState == 0 || moveState == 1 || moveState == 2)
                {
                   // if (thrustAmount > 0.0f)
                    {
                        for (int j = 0; j < ScreenManager.collisionGroups[assignedColGroup].Count; j++)
                        {
                      
                            if (fighterIndex != ScreenManager.collisionGroups[assignedColGroup][j]
                                && ScreenManager.collisionGroups[assignedColGroup][j] != 99)
                            {
                                //if (collisionS[1].BS.Contains(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].collisionS[1].BS) != ContainmentType.Disjoint)
                                {
                                    // delta = ScreenManager.dummies[j].Position - Position;
                                    // Position -= Vector3.Clamp(delta, new Vector3(-1, 0, -1), new Vector3(1, 0, 1)) * (float)gameTime.ElapsedGameTime.TotalSeconds * 100;// new Vector3(Math.Abs(Position.X), 0.0f, Math.Abs(Position.Z));

                                    rotationAmount = TurnToFace(Position, ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].Position, new Vector3(0.0f, (float)Math.Atan((double)(ScreenManager.dummies[j].Direction.Z / ScreenManager.dummies[j].Direction.X)), 0.0f));

                                    float x = (float)Math.Sin(rotationAmount);
                                    float y = (float)Math.Cos(rotationAmount);
                                    sepDirection = new Vector3(x, 0.0f, y);
                                    float difference = Vector3.Distance(Position, ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].Position);
                                    Vector3 adjustedPosition1 = Position + sepDirection * 25.6f;
                                    Vector3 adjustedPosition2 = ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].Position + -sepDirection * 25.6f;
                                    
                                    difference = Vector3.Distance(adjustedPosition1 , adjustedPosition2);

                                    if (difference < 0)
                                        difference -= .001f;
                                    if (difference >= 0)
                                        difference += .001f;
                                    Vector3 difVector = Position - ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].Position;
                                    difVector.Normalize();
                                    //difference = Math.Sqrt((double)Vector3.DistanceSquared(Vector3.Position * Position, ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].Position) * ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].Position));
                                    float checkLeft = Vector3.Distance(sepDirection, world.Left);
                                    float checkRight = Vector3.Distance(sepDirection, world.Right);
                                    float checkForward = Vector3.Distance(sepDirection, world.Forward);
                                    float checkBackward = Vector3.Distance(sepDirection, world.Backward);
                                    //if (checkLeft < checkRight)
                                    //{
                                    //    sepDirection = world.Left;
                                    //    goLeft = true;
                                    //}
                                    //else
                                    //{
                                    //    sepDirection = world.Right;
                                    //    goRight = true;
                                    //}
                                    //if(checkLeft < checkRight  && checkLeft < checkBackward)
                                    //{     sepDirection = world.Left;
                                    //    goLeft = true;
                                    //}
                                    //else if (checkRight < checkLeft &&   checkRight < checkBackward)
                                    //{
                                    //    sepDirection = world.Right;
                                    //    goRight = true;
                                    //}
                                    //else if (checkForward < checkLeft && checkForward < checkRight && checkForward < checkBackward)
                                    //{
                                    //    sepDirection = world.Forward;
                                    //    goForward = true;
                                    //}
                                    //else if (checkBackward < checkLeft &&  checkBackward < checkRight)
                                    //{
                                    //    sepDirection = world.Backward;
                                    //    goBackward = true;
                                    //}
                                    while (collisionS[1].BS.Contains(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].collisionS[1].BS) != ContainmentType.Disjoint)
                                    {
                                        // rotationAmount = TurnToFace(Position, ScreenManager.dummies[j].Position, new Vector3(0.0f, (float)Math.Atan((double)(ScreenManager.Theseus.Direction.Z / ScreenManager.Theseus.Direction.X)), 0.0f));
                                        //moveState = 1;
                                        if (doubleCollision)
                                            break;
                                        //see if you can make the forward movement diagonal with the first sepdirection
                                        //Position -= sepDirection * difference *2;
                                        Position -= sepDirection * (float)gameTime.ElapsedGameTime.TotalSeconds * 101 * thrustAmount;
                                        
                                        //Position += sepDirection;
                                        collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);

                                        for (int m = 0; m < ScreenManager.collisionGroups[assignedColGroup].Count; m++)
                                        {
                                            if ( ScreenManager.collisionGroups[assignedColGroup][m] != fighterIndex
                                                && ScreenManager.collisionGroups[assignedColGroup][j] != 99)
                                            {
                                                if (ScreenManager.collisionGroups[assignedColGroup][m] != 99)
                                                    if (collisionS[1].BS.Contains(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][m]].collisionS[1].BS) != ContainmentType.Disjoint)
                                                    {
                                                        Position = oldPosition;
                                                        doubleCollision = true;
                                                        break;

                                                    }
                                            }
                                        }

                                        ////check again
                                        //if (collisionS[1].BS.Contains(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].collisionS[1].BS) != ContainmentType.Disjoint)
                                        //{
                                        //    //cant go one direction go back to original position this function and try theother direction
                                        //    Position = deltaPosition;
                                        //    if (goLeft )
                                        //    {
                                        //        sepDirection = world.Right;
                                        //        leftInvalid = true;
                                        //        goRight = true;
                                        //        goLeft = false;
                                        //    }
                                        //    else if (goRight )
                                        //    {
                                        //        sepDirection = world.Left;
                                        //        rightInvalid = true;
                                        //        goLeft = true;
                                        //        goRight = false;
                                        //    }
                                        //    else if (rightInvalid && leftInvalid)
                                        //    {
                                        //        Position = oldPosition;
                                        //        collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
                                        //        break;

                                        //    }
                                        //   // Position -= difVector;
                                        //    Position -= sepDirection * difference;
                                        //    //Position -= sepDirection * (float)gameTime.ElapsedGameTime.TotalSeconds * 101 * thrustAmount;
                                        //    collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
                                            
                                        //    if (collisionS[1].BS.Contains(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].collisionS[1].BS) != ContainmentType.Disjoint)
                                        //    {
                                        //        bothInvalid = true;
                                        //        Position = oldPosition;
                                        //    }

                                        //}

                                       


                                        //for (int m = 0; m < ScreenManager.collisionGroups[assignedColGroup].Count; m++)
                                        //{
                                        //    if (m != j && ScreenManager.collisionGroups[assignedColGroup][m]!=fighterIndex
                                        //        && ScreenManager.collisionGroups[assignedColGroup][j] != 99 )
                                        //   {
                                        //        if(ScreenManager.collisionGroups[assignedColGroup][m] != 99)
                                        //        if (collisionS[1].BS.Contains(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][m]].collisionS[1].BS) != ContainmentType.Disjoint)
                                        //        {
                                        //    //        Position = oldPosition;
                                        //            collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
                                        //    //        doubleCollision = true;
                                        //          if (goLeft &! rightInvalid)
                                        //            {
                                        //                sepDirection = world.Right;
                                        //                Position = deltaPosition;
                                                        
                                        //               leftInvalid = true;
                                        //                goLeft = false;
                                        //                goRight = true;

                                        //            }
                                        //            else if (goRight & !leftInvalid)
                                        //            {
                                        //                sepDirection = world.Left;
                                        //                Position = deltaPosition;
                                                      
                                        //                rightInvalid = true;
                                        //                goLeft = true;
                                        //                goRight = false;
                                        //            }
                                        //            if (leftInvalid && rightInvalid)
                                        //            {
                                        //                Position = oldPosition;
                                        //                bothInvalid = true;
                                        //                break;
                                        //            }
                                        //             if (bothInvalid)
                                        //            {
                                        //                Position = oldPosition;
                                        //                collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
                                        //                break;
                                        //            }
                                                
                                        //        }
                                            //    else
                                            //        if (collisionS[1].BS.Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                                            //        {
                                            //            Position = oldPosition;
                                            //            collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
                                            //            doubleCollision = true;

                                            //            break;
                                            //        }

                                        //    }
                                        //}
                                        //if (!bothInvalid)
                                        //{
                                        //    if (goLeft)
                                        //        goRight = true;

                                        //    if (goRight)
                                        //        goLeft = true; 



                                        //}
                                        //if (doubleCollision)
                                        //{
                                        //    //try the other direction
                                        //    if (goLeft & !goRight)
                                        //    {
                                        //        sepDirection = world.Right;
                                        //        goRight = true;
                                        //    }
                                        //    else if (goRight & !goLeft)
                                        //    {
                                        //        sepDirection = world.Left;
                                        //        goLeft = true;
                                        //    }
                                        //    else if (goLeft && goRight)
                                        //    {
                                        //        bothInvalid = true;
                                        //        Position = oldPosition;
                                        //        break;
                                        //    }
                                            //break;

                                       // }
                                       // if(
                                        //sepDirection = new Vector3(x, 0.0f, y);

                                        //Direction = oldDirection;
                                         moveWait = true;
                                    }
                                   // moveState = 1;
                                   // setSpheres.Clear();
                                    if (ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].thrustAmount > 0.0f)
                                        ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].moveWait = true;

                                }
                            }
                                if(ScreenManager.collisionGroups[assignedColGroup][j] == 99)
                                {
                                    //if (ScreenManager.Theseus.collisionS[1].BS.Contains(collisionS[1].BS) != ContainmentType.Disjoint)
                                    {
                                        // delta = ScreenManager.Theseus.Position - Position;
                                        //Position -= Vector3.Clamp(delta, new Vector3(-1, 0, -1), new Vector3(1, 0, 1)) * (float)gameTime.ElapsedGameTime.TotalSeconds * 100;// new Vector3(Math.Abs(Position.X), 0.0f, Math.Abs(Position.Z));
                                        rotationAmount = TurnToFace(Position, ScreenManager.Theseus.Position, new Vector3(0.0f, (float)Math.Atan((double)(ScreenManager.Theseus.Direction.Z / ScreenManager.Theseus.Direction.X)), 0.0f));

                                        float x = (float)Math.Sin(rotationAmount);
                                        float y = (float)Math.Cos(rotationAmount);


                                        sepDirection = new Vector3(x, 0.0f, y);

                                        float checkLeft = Vector3.Distance(sepDirection, world.Left);
                                        float checkRight = Vector3.Distance(sepDirection, world.Right);
                                        float checkForward = Vector3.Distance(sepDirection, world.Forward);
                                        float checkBackward = Vector3.Distance(sepDirection, world.Backward);
                                        if (checkLeft < checkRight)
                                            sepDirection = world.Left;
                                        else
                                            sepDirection = world.Right;

                                        while (collisionS[1].BS.Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                                        {
                                            // rotationAmount = TurnToFace(Position, ScreenManager.dummies[j].Position, new Vector3(0.0f, (float)Math.Atan((double)(ScreenManager.Theseus.Direction.Z / ScreenManager.Theseus.Direction.X)), 0.0f));
                                            //moveState = 1;
                                            Position -= sepDirection * 10 * (float)gameTime.ElapsedGameTime.TotalSeconds * 100;
                                            collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);

                                            //sepDirection = new Vector3(x, 0.0f, y);

                                            //Direction = oldDirection;
                                             moveWait = true;
                                        }
                                     //   moveState = 1;
                                     //   setSpheres.Clear();
                                    }
                                
                            }


                        }
                    }

                }
                else if (moveState == 2)
                {
                    for (int j = 0; j < ScreenManager.collisionGroups[assignedColGroup].Count; j++)
                    {
                        if (ScreenManager.collisionGroups[assignedColGroup][j] == 99)
                        {
                            if (setSpheres.Count > 0)
                            {
                                if (setSphereCount == 1)
                                {

                                    if (setSpheres[0].Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                                    {
                                        moveState = 0;
                                        Position = oldPosition;
                                        Direction = oldDirection;
                                        setSpheres.Clear();
                                        havePlannedPosition = false;
                                        //if (setSpheres.Count == 1)
                                        //    moveState = 0;
                                        //else
                                        //    moveState = 1;
                                        //       moveState = 0;
                                        //    setSpheres.Clear();
                                        //      havePlannedPosition = false;
                                        //  delta = ScreenManager.Theseus.Position - Position;
                                        // Position -= Vector3.Clamp(delta, new Vector3(-1, 0, -1), new Vector3(1, 0, 1)) * (float)gameTime.ElapsedGameTime.TotalSeconds * 100;// new Vector3(Math.Abs(Position.X), 0.0f, Math.Abs(Position.Z));
                                    }
                                }
                                else
                                {
                                     if (collisionS[1].BS.Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                                        {
                                            Position = oldPosition;
                                            Direction = oldDirection;
                                            moveWait = true;
                                            moveState = 1;
                                            setSpheres.Clear();

                                        }
                                    //was just giong back to movestate 1 now gonna check smaller radius
                                    //if (setSpheres[0].Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                                    //{
                                    //    //go back and get a new path
                                    //    moveState = 1;
                                    //    setSpheres.Clear();

                                    //}
                                }

                            }
                        }

                        else
                        {
                           // for (int k = 0; k < ScreenManager.dummies.Count; k++)
                            {
                                if (ScreenManager.collisionGroups[assignedColGroup][j] != fighterIndex)
                                {
                                    if(setSpheres.Count>0)
                                    {
                                        if (setSpheres.Count == 1)
                                        {
                                            //if (ScreenManager.collisionGroups[assignedColGroup][j] != -1)
                                            {
                                                if (setSpheres[0].Contains(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].collisionS[1].BS) != ContainmentType.Disjoint)
                                                // if (setSpheres[0].Contains(ScreenManager.dummies[k].collisionS[1].BS) != ContainmentType.Disjoint)
                                                {

                                                    //    if (list[i].moveState != 2)
                                                    {

                                                        //          delta = ScreenManager.dummies[k].Position - Position;
                                                        //         Position -= Vector3.Clamp(delta, new Vector3(-1, 0, -1), new Vector3(1, 0, 1)) * (float)gameTime.ElapsedGameTime.TotalSeconds * 100;// new Vector3(Math.Abs(Position.X), 0.0f, Math.Abs(Position.Z));
                                                        // Position = oldPosition;
                                                        //  Direction = oldDirection;
                                                          moveWait = true;
                                                        moveState = 0;
                                                        Position = oldPosition;
                                                        Direction = oldDirection;
                                                        setSpheres.Clear();
                                                        havePlannedPosition = false;

                                                    }
                                                }
                                            }
                                        }
                                        else
                                        {

                                            if (collisionS[1].BS.Contains(ScreenManager.dummies[ScreenManager.collisionGroups[assignedColGroup][j]].collisionS[1].BS) != ContainmentType.Disjoint)
                                            {
                                                //go back and get a new path
                                                //  Position = oldPosition;
                                                //  Direction = oldDirection;
                                                //   moveWait = true;
                                                //  moveState = 1;
                                                Position = oldPosition;
                                                Direction = oldDirection;
                                                moveWait = true;
                                                moveState = 1;
                                                setSpheres.Clear();

                                            }
                                        }
                                    }


                                }
                            }
                        }

                    }


                }
            }
            if (collisionCount > 1)
            {

                


            }
            //checkMoveValidity(1200);
        }
        
        public void UpdateAI(GameTime gameTime)
        {
            List<int> theIs = new List<int>();
            List<int> theJs = new List<int>();
           // Console.WriteLine("Updating " + fighterIndex + " " + moveState);
            oldPosition = position;
            float dToT = 0.0f;
            float dToNewP = 0.0f;
            float rotationAmount = 0.0f;
            float dToS = 0;
            calculateFutureMovement(gameTime);
            //case where you are wandering
            if (aiState == 0)
            {
                if (!havePlannedPosition)
                {
                    int i = rand.Next(5);
                    int j = rand.Next(5);
                    //i = 0;
                    //j = 0;
                    for(int a = 0; a < 5; a++)
                        for (int b = 0; b < 5; b++)
                        {
                            pValidMSpheres[a][b] = moveSpheres[a][b];
                        }
                    moveSpheres[0][0] = new BoundingSphere(position - new Vector3(102.4f, -70.0f, -102.4f), 25.6f);
                    moveSpheres[0][1] = new BoundingSphere(position - new Vector3(102.4f, -70.0f, -51.2f), 25.6f);
                    moveSpheres[0][2] = new BoundingSphere(position - new Vector3(102.4f, -70.0f, 0.0f), 25.6f);
                    moveSpheres[0][3] = new BoundingSphere(position - new Vector3(102.4f, -70.0f, 51.2f), 25.6f);
                    moveSpheres[0][4] = new BoundingSphere(position - new Vector3(102.4f, -70.0f, 102.4f), 25.6f);
                    moveSpheres[1][0] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, -102.4f), 25.6f);
                    moveSpheres[1][1] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, -51.2f), 25.6f);
                    moveSpheres[1][2] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, 0.0f), 25.6f);
                    moveSpheres[1][3] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, 51.2f), 25.6f);
                    moveSpheres[1][4] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, 102.4f), 25.6f);
                    moveSpheres[2][0] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, -102.4f), 25.6f);
                    moveSpheres[2][1] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, -51.2f), 25.6f);
                    moveSpheres[2][2] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, 0.0f), 25.6f);
                    moveSpheres[2][3] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, 51.2f), 25.6f);
                    moveSpheres[2][4] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, 102.4f), 25.6f);
                    moveSpheres[3][0] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, -102.4f), 25.6f);
                    moveSpheres[3][1] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, -51.2f), 25.6f);
                    moveSpheres[3][2] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, 0.0f), 25.6f);
                    moveSpheres[3][3] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, 51.2f), 25.6f);
                    moveSpheres[3][4] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, 102.4f), 25.6f);
                    moveSpheres[4][0] = new BoundingSphere(position - new Vector3(-102.4f, -70.0f, -102.4f), 25.6f);
                    moveSpheres[4][1] = new BoundingSphere(position - new Vector3(-102.4f, -70.0f, -51.2f), 25.6f);
                    moveSpheres[4][2] = new BoundingSphere(position - new Vector3(-102.4f, -70.0f, 0.0f), 25.6f);
                    moveSpheres[4][3] = new BoundingSphere(position - new Vector3(-102.4f, -70.0f, 51.2f), 25.6f);
                    moveSpheres[4][4] = new BoundingSphere(position - new Vector3(-102.4f, -70.0f, 102.4f), 25.6f);

                    plannedPosition = moveSpheres[i][j].Center - new Vector3(0, 70.0f, 0.0f);
                    int counter = 0;
                    int maxValid = 0;
                    while(!onTheBoardFunction(mFromVec(plannedPosition), 20))
                    {
                        i = rand.Next(5);
                        j = rand.Next(5);
                        plannedPosition = moveSpheres[i][j].Center - new Vector3(0, 70.0f, 0.0f);
                        counter++;
                        if (counter > 10)
                        {
                           // Console.WriteLine("WHile loop tripped");

                            for(int a = 0; a< 5; a++)
                                for (int b = 0; b < 5; b++)
                                {
                                    if (onTheBoardFunction(mFromVec(moveSpheres[a][b].Center), 20))
                                    {
                                        theIs.Add(a);
                                        theJs.Add(b);

                                        
                                    }
                                     


                                }
                            i = rand.Next(theIs.Count);
                            if (theIs.Count > 0)
                                plannedPosition = moveSpheres[theIs[i]][theJs[i]].Center - new Vector3(0, 70.0f, 0.0f);

                            else
                            {
             



                            }
                        }

                    }
                    havePlannedPosition = true;
                }

                if (moveState == 0)
                { 
                    dToNewP = Vector3.Distance(position, plannedPosition);
                    rotationAmount = TurnToFace(position, plannedPosition, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    
                    if (dToNewP > 10.0)
                    {

                        thrustAmount = 1.0f;
                        if (!isRun)
                        {
                            isRun = true;
                            justBones.CopyTo(previousAnimation, 0);
                        }
                    }
                    else
                    {
                        aiDecisionTimer += gameTime.ElapsedGameTime;
                        isRun = false;
                        thrustAmount = 0.0f;
                        runTime = TimeSpan.Zero;
                        double split = rand.NextDouble();
                        cutOffTime = TimeSpan.FromMilliseconds(maxDecisionTimer.TotalMilliseconds * split);
                        if(cutOffTime < minDecisionTimer)
                            cutOffTime =minDecisionTimer;

                        if (aiDecisionTimer > cutOffTime)
                        {
                            havePlannedPosition = false;
                            aiDecisionTimer = TimeSpan.Zero;
                        }
                    }

                }
                else if (moveState == 1)
                {
                    if (setSpheres.Count > 0 & !moveWait)
                    {
                        dToNewP = Vector3.Distance(position, plannedPosition);
                        dToS = Vector3.Distance(position + new Vector3(0.0f, 70.0f, 0.0f), setSpheres[0].Center);
                        rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                        if (dToNewP < 75)
                        {

                            setSpheres.Clear();
                            rotationAmount = TurnToFace(position, plannedPosition, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                            havePlannedPosition = false;
                            moveState = 0;
                            isRun = false;
                            thrustAmount = 0.0f;
                        }
                        else
                        {
                            if (dToS > 10)
                            {
                                thrustAmount = 1.0f;
                                if (!isRun)
                                {
                                    isRun = true;
                                    justBones.CopyTo(previousAnimation, 0);
                                }
                            }
                            else
                            {
                                setSpheres.RemoveAt(0);

                            }
                        }

                    }
                    else 
                    {
                        isRun = false;
                        thrustAmount = 0.0f;


                    }
                   // if (!moveWait && havePlannedPosition)
                    if(havePlannedPosition)
                    {
                        //dToNewP = Vector3.Distance(position, plannedPosition);
                        //rotationAmount = TurnToFace(position, plannedPosition, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));


                        if (setSpheres.Count == 0)
                        {
                            miniPathSet = false;


                            //West to East South to North each sphere has radius of 40
                            moveSpheres[0][0] = new BoundingSphere(position - new Vector3(102.4f, -70.0f, -102.4f), 25.6f);
                            moveSpheres[0][1] = new BoundingSphere(position - new Vector3(102.4f, -70.0f, -51.2f), 25.6f);
                            moveSpheres[0][2] = new BoundingSphere(position - new Vector3(102.4f, -70.0f, 0.0f), 25.6f);
                            moveSpheres[0][3] = new BoundingSphere(position - new Vector3(102.4f, -70.0f, 51.2f), 25.6f);
                            moveSpheres[0][4] = new BoundingSphere(position - new Vector3(102.4f, -70.0f, 102.4f), 25.6f);
                            moveSpheres[1][0] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, -102.4f), 25.6f);
                            moveSpheres[1][1] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, -51.2f), 25.6f);
                            moveSpheres[1][2] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, 0.0f), 25.6f);
                            moveSpheres[1][3] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, 51.2f), 25.6f);
                            moveSpheres[1][4] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, 102.4f), 25.6f);
                            moveSpheres[2][0] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, -102.4f), 25.6f);
                            moveSpheres[2][1] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, -51.2f), 25.6f);
                            moveSpheres[2][2] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, 0.0f), 25.6f);
                            moveSpheres[2][3] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, 51.2f), 25.6f);
                            moveSpheres[2][4] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, 102.4f), 25.6f);
                            moveSpheres[3][0] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, -102.4f), 25.6f);
                            moveSpheres[3][1] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, -51.2f), 25.6f);
                            moveSpheres[3][2] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, 0.0f), 25.6f);
                            moveSpheres[3][3] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, 51.2f), 25.6f);
                            moveSpheres[3][4] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, 102.4f), 25.6f);
                            moveSpheres[4][0] = new BoundingSphere(position - new Vector3(-102.4f, -70.0f, -102.4f), 25.6f);
                            moveSpheres[4][1] = new BoundingSphere(position - new Vector3(-102.4f, -70.0f, -51.2f), 25.6f);
                            moveSpheres[4][2] = new BoundingSphere(position - new Vector3(-102.4f, -70.0f, 0.0f), 25.6f);
                            moveSpheres[4][3] = new BoundingSphere(position - new Vector3(-102.4f, -70.0f, 51.2f), 25.6f);
                            moveSpheres[4][4] = new BoundingSphere(position - new Vector3(-102.4f, -70.0f, 102.4f), 25.6f);


                            //West to East South to North each sphere has radius of 40
                            //moveSpheres[0][0] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, -51.2f), 25.6f);
                            //moveSpheres[0][1] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, -25.6f), 25.6f);
                            //moveSpheres[0][2] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, 0.0f), 25.6f);
                            //moveSpheres[0][3] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, 25.6f), 25.6f);
                            //moveSpheres[0][4] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, 51.2f), 25.6f);
                            //moveSpheres[1][0] = new BoundingSphere(position - new Vector3(25.6f, -70.0f, -51.2f), 25.6f);
                            //moveSpheres[1][1] = new BoundingSphere(position - new Vector3(25.6f, -70.0f, -25.6f), 25.6f);
                            //moveSpheres[1][2] = new BoundingSphere(position - new Vector3(25.6f, -70.0f, 0.0f), 25.6f);
                            //moveSpheres[1][3] = new BoundingSphere(position - new Vector3(25.6f, -70.0f, 25.6f), 25.6f);
                            //moveSpheres[1][4] = new BoundingSphere(position - new Vector3(25.6f, -70.0f, 51.2f), 25.6f);
                            //moveSpheres[2][0] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, -51.2f), 25.6f);
                            //moveSpheres[2][1] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, -25.6f), 25.6f);
                            //moveSpheres[2][2] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, 0.0f), 25.6f);
                            //moveSpheres[2][3] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, 25.6f), 25.6f);
                            //moveSpheres[2][4] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, 51.2f), 25.6f);
                            //moveSpheres[3][0] = new BoundingSphere(position - new Vector3(-25.6f, -70.0f, -51.2f), 25.6f);
                            //moveSpheres[3][1] = new BoundingSphere(position - new Vector3(-25.6f, -70.0f, -25.6f), 25.6f);
                            //moveSpheres[3][2] = new BoundingSphere(position - new Vector3(-25.6f, -70.0f, 0.0f), 25.6f);
                            //moveSpheres[3][3] = new BoundingSphere(position - new Vector3(-25.6f, -70.0f, 25.6f), 25.6f);
                            //moveSpheres[3][4] = new BoundingSphere(position - new Vector3(-25.6f, -70.0f, 51.2f), 25.6f);
                            //moveSpheres[4][0] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, -51.2f), 25.6f);
                            //moveSpheres[4][1] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, -25.6f), 25.6f);
                            //moveSpheres[4][2] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, 0.0f), 25.6f);
                            //moveSpheres[4][3] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, 25.6f), 25.6f);
                            //moveSpheres[4][4] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, 51.2f), 25.6f);
                            //see if offboard
                            //pm is to keep them on the board
                            Point pM = Point.Zero;
                            for (int i = 0; i < 5; i++)
                                for (int j = 0; j < 5; j++)
                                    open[i][j] = true;
                            for (int i = 0; i < 5; i++)
                                for (int j = 0; j < 5; j++)
                                {
                                    pM = mFromVec(moveSpheres[i][j].Center);
                                    //if (pM.X >= 0 && pM.Y >= 0 && pM.X < 50 && pM.Y < 50)
                                    if (onTheBoardFunction(pM, 20))
                                    {
                                        if (moveSpheres[i][j].Contains(ScreenManager.Theseus.collisionS[1].BS) != ContainmentType.Disjoint)
                                            open[i][j] = false;
                                        for (int k = 0; k < ScreenManager.dummies.Count; k++)
                                        {
                                            if (ScreenManager.dummies[k] != this)
                                            {
                                                if (moveSpheres[i][j].Contains(ScreenManager.dummies[k].collisionS[1].BS) != ContainmentType.Disjoint ||
                                                    moveSpheres[i][j].Contains(ScreenManager.dummies[k].bodySphere) != ContainmentType.Disjoint
                                                    || !ScreenManager.mainOpen[pM.X][pM.Y])
                                                {
                                                    open[i][j] = false;
                                                    //    Console.WriteLine(fighterIndex + " " + k);
                                                }
                                                //only check first five updates later
                                                for (int l = 0; l < ScreenManager.dummies[k].futureMovement.Count && l < 10; l++)
                                                {
                                                    if (moveSpheres[i][j].Contains(ScreenManager.dummies[k].futureMovement[l]) != ContainmentType.Disjoint)
                                                        open[i][j] = false;



                                                }
                                            }
                                        }
                                        }
                                    else
                                        open[i][j] = false;
                                }
                            //find the closest open tile
                            int thisI = 0;
                            int thisJ = 0;
                            float lowest = 99999999;
                            float check = 0;
                            for (int i = 0; i < 5; i++)
                                for (int j = 0; j < 5; j++)
                                {
                                    if (open[i][j])
                                    {
                                        check = Vector3.Distance(moveSpheres[i][j].Center, plannedPosition);
                                        if (check < lowest)
                                        {
                                            thisI = i;
                                            thisJ = j;
                                            lowest = check;
                                        }
                                    }
                                }
                            check =0;
                            int startI = 0;
                            int startJ = 0;
                            for(int i =0; i<5; i++)
                                for (int j = 0; j < 5; j++)
                                {
                                    if(open[i][j])
                                    {
                                        check = Vector3.Distance(moveSpheres[i][j].Center, Position);
                                        if(check  < lowest)
                                        {
                                            startI = i;
                                                startJ = j;
                                        }


                                    }

                                }
                            //  if (thisI == 2 && thisJ == 2)
                            //  fstate = 2;

                            Reset(new Point(startI, startJ), new Point(thisI, thisJ));
                            JsearchStatus = JSearchStatus.Searching;

                            while (JsearchStatus == JSearchStatus.Searching)
                            {

                                DoSearchStep();
                            }

                            if (myJSearchStatus == JSearchStatus.PathFound)
                            {
                                //just to get to first point
                                moveState = 2;
                                foreach (Point point in FinalPath())
                                {
                                    setSpheres.Add(moveSpheres[point.X][point.Y]);
                                }
                            }
                            if (myJSearchStatus == JSearchStatus.NoPath)
                            {
                                moveState = 0;
                                havePlannedPosition = false;
                                setSpheres.Clear();

                            }

                            if (!miniPathSet)
                            {
                                miniPathSet = true;
                            }


                        }
                        if (setSpheres.Count > 0)
                        {
                            dToS = Vector3.Distance(position, setSpheres[0].Center);
                            if (dToS > 10)
                            {
                                //if (setSpheres[0].Contains(position + new Vector3(0.0f, 70.0f, 0.0f)) == ContainmentType.Contains)
                                setSpheres.RemoveAt(0);

                                thrustAmount = 1.0f;
                                if (!isRun)
                                {
                                    isRun = true;
                                    justBones.CopyTo(previousAnimation, 0);
                                }
                            }
                        }
                        else //if no path should be  taken care of by the jsearchstatusnopath combo but just inc ase
                        {
                            havePlannedPosition = false;
                            isRun = false;
                            thrustAmount = 0.0f;
                        }


                

                    }

                }
                else if (moveState == 2)//movestate 2 moves to first setsphere open then goes to movestate 3
                {
                    if (setSpheres.Count > 0)
                    {
                        dToS = Vector3.Distance(position, setSpheres[0].Center);
                        rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                        //if (dToNewP < 75)
                        //{

                        //    setSpheres.Clear();
                        //    rotationAmount = TurnToFace(position, plannedPosition, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                        //    //havePlannedPosition = false;
                        //    moveState = 0;
                        //}
                        //this is 80 because setspheres center is at 70
                        if (dToS > 80)
                        {
                            thrustAmount = 1.0f;
                            if (!isRun)
                            {
                                isRun = true;
                                justBones.CopyTo(previousAnimation, 0);
                            }
                        }
                        else
                        {
                            setSpheres.RemoveAt(0);
                            moveState = 3;
                            //moveState = 1;
                        }


                    }
                    else
                    {
                        moveState = 0;
                        isRun = false;
                        thrustAmount = 0.0f;
                    }



                }
                else if (moveState == 3)
                {
                    if (setSpheres.Count > 0)
                    {
                        dToS = Vector3.Distance(position, setSpheres[0].Center);
                        rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
              
                        //this is 80 because setspheres center is at 70
                        if (dToS > 80)
                        {
                            thrustAmount = 1.0f;
                            if (!isRun)
                            {
                                isRun = true;
                                justBones.CopyTo(previousAnimation, 0);
                            }
                        }
                        else
                        {
                            setSpheres.RemoveAt(0);
                            //moveState = 3;
                            //moveState = 1;
                        }


                    }
                    else
                    {
                        moveState = 0;
                        havePlannedPosition = false;
                        isRun = false;
                        thrustAmount = 0.0f;
                    }


                }
                
                
            }
            //case where you are melee atk theseus
            if (aiState == 1)
            {
                dToT = Vector3.Distance(position, ScreenManager.Theseus.position);
                rotationAmount = TurnToFace(position, ScreenManager.Theseus.Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                if (dToT > 75)
                {
                    thrustAmount = 1.0f;
                    if (!isRun)
                    {
                        isRun = true;
                        justBones.CopyTo(previousAnimation, 0);
                    }
                }
                else
                {

                    thrustAmount = 0.0f;
                    runTime = TimeSpan.Zero;
                    isRun = false;

                    if (!isAtk1)
                    {
                        justBones.CopyTo(previousAnimation, 0);
                        isAtk1 = true;
                        active = true;
                    }
                 
                
                
                
                }




            }
            //case where you are range atk theseus
            if (aiState == 2)
            {
                dToT = Vector3.Distance(position, ScreenManager.Towers[towerIndex].Position);
                rotationAmount = TurnToFace(position, ScreenManager.Towers[towerIndex].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                TargetTrans = ScreenManager.Towers[towerIndex].Position;
            }
            //case where you encircle
            if (aiState == 3)
            {
                dToT = Vector3.Distance(position, ScreenManager.Towers[towerIndex].Position);
                rotationAmount = TurnToFace(position, ScreenManager.Towers[towerIndex].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                TargetTrans = ScreenManager.Towers[towerIndex].Position;
            }
            //case where you retreat 
            if (aiState == 4)
            {
                dToT = Vector3.Distance(position, ScreenManager.Towers[towerIndex].Position);
                rotationAmount = TurnToFace(position, ScreenManager.Towers[towerIndex].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                TargetTrans = ScreenManager.Towers[towerIndex].Position;
            }

            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);


            if (isRun)
                updateRun(gameTime);

            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);

            if (isRun)
                Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * (float)gameTime.ElapsedGameTime.TotalSeconds * 100* thrustAmount;
            if(!onTheBoardFunction(mFromVec(Position), 20))
                Position = oldPosition;
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;

            collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();
            checkMoveEnemySingle(gameTime);
            checkMoveValidity(1200);
        }
        public void UpdateFighter(GameTime gameTime)
        {

            oldPosition = position;
                        float dToA = Vector3.Distance(position, ScreenManager.RinnaAl.Position);
            float rotationAmount = 0.0f;
            rotationAmount = TurnToFace(position, ScreenManager.RinnaAl.Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
            float dToS = 0;

            if(isHammerFlight)
                if (currentAnimationTime.TotalSeconds > 1.0)
                {
                    if (!isAPSet)
                    {
                        isAPSet = true;
                        adjustedPosition = Position + Direction * 100.0f;
                        state = 2;
                    }
                    
                }
           // if (fighterState == 3)
                fighterNextTarget();
            float dToT = 0.0f;
            //Run To Ares

            if (mState == 0)
            {




            }
            if (fighterState == 0)
            {
                dToT = Vector3.Distance(position, Vector3.Zero);
                 rotationAmount = TurnToFace(position, Vector3.Zero, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                 TargetTrans = Vector3.Zero;
            }
            if (fighterState == 1)
            {
                dToT = Vector3.Distance(position, ScreenManager.Theseus.position);
                 rotationAmount = TurnToFace(position, ScreenManager.Theseus.Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                 TargetTrans = ScreenManager.Theseus.Position;
            }
            if (fighterState == 2)
            {
                dToT = Vector3.Distance(position, ScreenManager.Towers[towerIndex].Position);
                 rotationAmount = TurnToFace(position, ScreenManager.Towers[towerIndex].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                 TargetTrans = ScreenManager.Towers[towerIndex].Position;
            }



            bodySphere = new BoundingSphere(position + new Vector3(0.0f, 70.0f, 0.0f), 25.6f);
            //have to do something to keep them only getting valid movement positions
            //if (dToT < 280)
            //{
              //  fstate = 0;
            //    setSpheres.Clear();
            //}

            
            if (setSpheres.Count > 0 && fstate!=2)
            {
                dToS = Vector3.Distance(position, setSpheres[0].Center);
                rotationAmount = TurnToFace(position, setSpheres[0].Center, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                fstate = 1;
                if (dToT < 75)//in a set sphere and can atk so you can stop
                {
                    fstate = 0;
                    setSpheres.Clear();
                    rotationAmount = TurnToFace(position, TargetTrans, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                }

            }
            if (mState == 0)
            {
                mState = 1;
                MReset( mFromVec(position), mFromVec(ScreenManager.Theseus.Position));
                MsearchStatus = JSearchStatus.Searching;

                while (MsearchStatus == JSearchStatus.Searching)
                {
                    MainDoSearchStep();

                }
                if (MsearchStatus == JSearchStatus.PathFound)
                {

                    foreach(Point point in MainFinalPath())
                        mWayPoints.Add(new Vector3(point.X * 60 + 30.0f, 0.0f, point.Y * 60 + 30.0f));


                }
            }
           // else
           //     fstate = 0; 





            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);

            if (health <= 0)
            {
                if (!dead)
                {
                    currentAnimationTime = TimeSpan.Zero;
                    justBones.CopyTo(previousAnimation, 0);
                    isKnockDown = true;
                    dead = true;

                }
                updateKnockDown(gameTime);
            }
            else
            {



                x = (float)Math.Sin(rotationAmount);
                y = (float)Math.Cos(rotationAmount);
                Direction = new Vector3(x, 0.0f, y);

                Up = Vector3.Up;
                Right = Vector3.Cross(Direction, Up);



                if (!active && state == 0)
                    restTimer += gameTime.ElapsedGameTime;

                if (restTimer > TimeSpan.FromSeconds(3.0))
                {
                    restTimer = TimeSpan.FromSeconds(3.0);
                    active = true;
                }
                if (isKnockedBack)
                {
                    isKnockedBack = false;
                    isAtk1 = false;
                    isAtk2 = false;
                    isAtk3 = false;
                    isRun = false;
                    isKnockBack = true;
                    justBones.CopyTo(previousAnimation, 0);
                    currentAnimationTime = TimeSpan.Zero;

                }




                //if (dToT < 300.0f)//if it can be seen
                if (fstate == 0)
                {
                    if (dToT > 75)
                    {
                        //  resetFormation = true;
                        thrustAmount = 1.0f;
                        if (!isRun)
                        {
                            isRun = true;
                            justBones.CopyTo(previousAnimation, 0);
                        }

                    }
                    else
                    {
                        //   resetFormation = false;
                        thrustAmount = 0.0f;
                        runTime = TimeSpan.Zero;
                        isRun = false;

                        if (dToT > 75)
                        {
                            thrustAmount = 1.3f;

                        }
                        else
                        {
                            thrustAmount = 0.0f;

                            if (restTimer > TimeSpan.FromSeconds(.5) & !isAtk1 & !isAtk2 & !isAtk3 &!isHammerFlight)
                            {

                                int random = ScreenManager.rand.Next();
                                {
                                    //if (random % 4 == 1)
                                    //{

                                    //    active = true;
                                    //    isAtk1 = true;

                                    //    justBones.CopyTo(previousAnimation, 0);

                                    //    openStrike = true;
                                    //    restTimer = TimeSpan.Zero;
                                    //}
                                    //if (random % 4 == 2)
                                    //{
                                    //    justBones.CopyTo(previousAnimation, 0);
                                    //    isAtk2 = true;
                                    //    isAtk1 = true;
                                    //    active = true;
                                    //}
                                    //if (random % 4 == 0)
                                    //{
                                    //    justBones.CopyTo(previousAnimation, 0);
                                    //    isAtk3 = true;
                                    //    isAtk2 = true;
                                    //    isAtk1 = true;
                                    //    active = true;
                                    //}
                                  //  if (random % 4 == 3)
                                    {
                                        justBones.CopyTo(previousAnimation, 0);
                                        isHammerFlight = true;
                                        active = true;

                                    }

                                }

                                //Commented out June 7
                                //if (!isAtk1)
                                //{
                                //    isAtk1 = true;
                                //    active = true;

                                //}
                            }

                        }

                    }
                    // Console.WriteLine(restTimer);
                }
                if (fstate == 1)
                {
                    if (dToS > 10)
                    {
                        //  resetFormation = true;
                        thrustAmount = 1.0f;
                        if (!isRun)
                        {
                            isRun = true;
                            justBones.CopyTo(previousAnimation, 0);
                        }

                    }
                    
                    // Console.WriteLine(restTimer);
                }
                if (fstate == 2)
                {



                }
            }
            if (setSpheres.Count > 0)
                if (setSpheres[0].Contains(position + new Vector3(0.0f, 70.0f, 0.0f)) == ContainmentType.Contains)
                    setSpheres.RemoveAt(0);

            if (setSpheres.Count == 0)
            {   miniPathSet = false;


                //West to East South to North each sphere has radius of 40
            moveSpheres[0][0] = new BoundingSphere(position - new Vector3(102.4f, -70.0f, -102.4f), 25.6f);
            moveSpheres[0][1] = new BoundingSphere(position - new Vector3(102.4f, -70.0f, -51.2f), 25.6f);
            moveSpheres[0][2] = new BoundingSphere(position - new Vector3(102.4f, -70.0f, 0.0f), 25.6f);
            moveSpheres[0][3] = new BoundingSphere(position - new Vector3(102.4f, -70.0f, 51.2f), 25.6f);
            moveSpheres[0][4] = new BoundingSphere(position - new Vector3(102.4f, -70.0f, 102.4f), 25.6f);
            moveSpheres[1][0] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, -102.4f), 25.6f);
            moveSpheres[1][1] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, -51.2f), 25.6f);
            moveSpheres[1][2] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, 0.0f), 25.6f);
            moveSpheres[1][3] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, 51.2f), 25.6f);
            moveSpheres[1][4] = new BoundingSphere(position - new Vector3(51.2f, -70.0f, 102.4f), 25.6f);
            moveSpheres[2][0] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, -102.4f), 25.6f);
            moveSpheres[2][1] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, -51.2f), 25.6f);
            moveSpheres[2][2] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, 0.0f), 25.6f);
            moveSpheres[2][3] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, 51.2f), 25.6f);
            moveSpheres[2][4] = new BoundingSphere(position - new Vector3(0.0f, -70.0f, 102.4f), 25.6f);
            moveSpheres[3][0] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, -102.4f), 25.6f);
                moveSpheres[3][1] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, -51.2f), 25.6f);
                moveSpheres[3][2] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, 0.0f), 25.6f);
                moveSpheres[3][3] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, 51.2f), 25.6f);
                moveSpheres[3][4] = new BoundingSphere(position - new Vector3(-51.2f, -70.0f, 102.4f), 25.6f);
                moveSpheres[4][0] = new BoundingSphere(position - new Vector3(-102.4f, -70.0f, -102.4f), 25.6f);
                moveSpheres[4][1] = new BoundingSphere(position - new Vector3(-102.4f, -70.0f, -51.2f), 25.6f);
                moveSpheres[4][2] = new BoundingSphere(position - new Vector3(-102.4f, -70.0f, 0.0f), 25.6f);
                moveSpheres[4][3] = new BoundingSphere(position - new Vector3(-102.4f, -70.0f, 51.2f), 25.6f);
                moveSpheres[4][4] = new BoundingSphere(position - new Vector3(-102.4f, -70.0f, 102.4f), 25.6f);

                
                Point pM = Point.Zero;
                for (int i = 0; i < 5; i++)
                    for (int j = 0; j < 5; j++)
                        open[i][j] = true;
                for(int i =0; i< 5; i++)
                    for(int j =0; j<5; j++)
                    {
                        pM = mFromVec(moveSpheres[i][j].Center);
                        if (pM.X >= 0 && pM.Y >= 0)
                            for (int k = 0; k < ScreenManager.fighters.Count; k++)
                            {
                                if (ScreenManager.fighters[k].health > 0 && ScreenManager.fighters[k].activated)
                                    if (k != fighterIndex)
                                    {
                                        if (moveSpheres[i][j].Contains(ScreenManager.fighters[k].collisionS[1].BS) != ContainmentType.Disjoint ||
                                            moveSpheres[i][j].Contains(ScreenManager.fighters[k].bodySphere) != ContainmentType.Disjoint
                                            || !ScreenManager.mainOpen[pM.X][pM.Y])
                                        {
                                            open[i][j] = false;
                                            //    Console.WriteLine(fighterIndex + " " + k);
                                        }
                                    }
                            }
                        else
                            open[i][j] = false;
                    }
                //find the closest open tile
                int thisI = 0;
                int thisJ = 0;
                float lowest = 99999999;
                float check = 0;
                for(int i = 0; i<5; i++)
                    for (int j = 0; j < 5; j++)
                    {
                        if (open[i][j])
                        {
                            check = Vector3.Distance(moveSpheres[i][j].Center,TargetTrans);
                            if (check < lowest)
                            {
                                thisI = i;
                                thisJ = j;
                                lowest = check;
                            }
                        }
                   }

              //  if (thisI == 2 && thisJ == 2)
                  //  fstate = 2;

                Reset(new Point(2, 2), new Point(thisI, thisJ));
                JsearchStatus = JSearchStatus.Searching;

                while (JsearchStatus == JSearchStatus.Searching)
                {

                    DoSearchStep();
                }

                if (myJSearchStatus == JSearchStatus.PathFound)
                {
                    foreach (Point point in FinalPath())
                    {
                        setSpheres.Add(moveSpheres[point.X][point.Y]);
                    }
                }
                //else
                //    fstate = 2;
                

            }

            if (!miniPathSet)
            {
                //find the next two spheres that player will use //looks ahead two steps
                //Vector3 pos1 = position + new Vector3(0.0f, 70.0f, 0.0f) + Direction * 40;
                //Vector3 pos2 = position + new Vector3(0.0f, 70.0f, 0.0f) + Direction * 60;

                //for (int i = 0; i < 5; i++)
                //    for (int j = 0; j < 5; j++)
                //    {
                //        //if (moveSpheres[i][j].Contains(position) == ContainmentType.Contains)
                //        //    setSpheres.Add(moveSpheres[i][j]);
                //        if (moveSpheres[i][j].Contains(pos1) == ContainmentType.Contains)
                //            setSpheres.Add(moveSpheres[i][j]);
                //        if (moveSpheres[i][j].Contains(pos2) == ContainmentType.Contains)
                //            setSpheres.Add(moveSpheres[i][j]);

                //    }

                //for(int i = 0; i<fighterIndex; i++)
                //{
                //    if (i != fighterIndex)
                //    {



                //    }

                //}

                
                miniPathSet = true;
            }
            








            if (isRun)
                updateRun(gameTime);

            if (isAtk1)
                UpdateBasic1(gameTime);
            else if (isAtk2)
                UpdateBasic2(gameTime);
            else if (isAtk3)
                UpdateBasic3(gameTime);
            else if (isHammerFlight)
                UpdateHammerFlight(gameTime);
            if (isKnockBack)
                UpdateKnockBack(gameTime);
            if (isKnockDown)
                updateKnockDown(gameTime);

            if (!dead)
            {

                if (state == 1)
                    Position += new Vector3(DirToFormation.X, DirToFormation.Y, DirToFormation.Z) * 2.0f;
                else if (state == 2)
                    Position = Vector3.Lerp(Position, adjustedPosition, ((float)currentAnimationTime.TotalSeconds - 1.0f));
                else if (isRun)
                    Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 1.0f;
            }
            //if(isKnockBack)
            //    Position -= new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 2.0f;

            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1 || isAtk2 || isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockDown)
                upperBones.CopyTo(justBones, 0);
            else if (isHammerFlight)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);



            int pX = (int)position.X / 100;
            int pZ = (int)position.Z / 100;

            if (Position.X < 0)
                pX = 0;
            if (Position.Z < 0)
                pZ = 0;
            if (position.X > 12799)
                pX = 127;
            if (position.Z > 12799)
                pZ = 127;
            //Console.WriteLine(
            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;




            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            //if(resetFormation)
            formation = world;

            Vector3 scale, trans;
            Quaternion rota;
            Matrix targetMat = new Matrix();
            Matrix[] transforms = new Matrix[ScreenManager.spearSphere.Bones.Count];
            ScreenManager.spearSphere.CopyAbsoluteBoneTransformsTo(transforms);
            int  ii = 0;
            int  jj = 0;
            foreach (ModelMesh mesh in ScreenManager.spearSphere.Meshes)
            {
                // draw = false;
                
                
                    if (mesh.Name == "rSpearS1" || mesh.Name == "rSpearS2" || mesh.Name == "rSpearS3")
                    {
                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.rHand];
                        targetMat.Decompose(out scale, out rota, out trans);
                        rSpear[jj++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * scale.X));
                        if (mesh.Name == "rSpearS1")
                            transRayStart = trans;
                    }
                    if (mesh.Name == "chestS")
                    {
                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.spine1];
                        targetMat.Decompose(out scale, out rota, out trans);
                        spheres[ii++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * scale.X));
                        transRayEnd = trans;
                    }
                    if (mesh.Name == "chestS")
                    {
                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.spine1];
                        targetMat.Decompose(out scale, out rota, out trans);
                        collisionS[1] = new boundingSphere("collisionS", new BoundingSphere(trans, mesh.BoundingSphere.Radius * scale.X * 2.0f));


                    }
                    if (mesh.Name == "KnockBackCheck")
                    {


                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.spine1];
                        targetMat.Decompose(out scale, out rota, out trans);
                        knockBackSphere[0] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * scale.X));

                    }

                    if (mesh.Name == "forwardSpell")
                    {
                        World.Decompose(out scale, out rota, out trans);

                        forwardSpell = Matrix.Transform(transforms[mesh.ParentBone.Index], rota) * Matrix.CreateTranslation(trans);

                    }
                    if (mesh.Name == "headS1")
                    {
                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.head];
                        targetMat.Decompose(out scale, out rota, out trans);
                        spheres[ii++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * scale.X));


                    }

                    if (mesh.Name == "hipS")
                    {
                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.hips];
                        targetMat.Decompose(out scale, out rota, out trans);
                        spheres[ii++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * scale.X));
                    }
                    if (mesh.Name == "lULegS")
                    {
                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.lULeg];
                        targetMat.Decompose(out scale, out rota, out trans);
                        spheres[ii++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * scale.X));
                    }
                    if (mesh.Name == "lLLegS")
                    {
                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.lLLeg];
                        targetMat.Decompose(out scale, out rota, out trans);
                        spheres[ii++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * scale.X));

                    }
                    if (mesh.Name == "rULegS")
                    {
                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.rULeg];
                        targetMat.Decompose(out scale, out rota, out trans);
                        spheres[ii++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * scale.X));
                    }
                    if (mesh.Name == "rLLegS")
                    {
                        targetMat = transforms[mesh.ParentBone.Index] * SkinTrans[ScreenManager.rLLeg];
                        targetMat.Decompose(out scale, out rota, out trans);
                        spheres[ii++] = new boundingSphere(mesh.Name, new BoundingSphere(trans, mesh.BoundingSphere.Radius * scale.X));
                    }


                

            }

            ScreenManager.FinalProjectiles.CopyAbsoluteBoneTransformsTo(transforms);
            foreach (ModelMesh mesh in ScreenManager.FinalProjectiles.Meshes)
            {
                if (mesh.Name == "LSpear2")
                {
                    World.Decompose(out scale, out rota, out trans);

                    //ScreenManager.ThorTVH.arrowWorld =Matrix.CreateScale(scale) *  Matrix.CreateTranslation(transforms[mesh.ParentBone.Index].Translation) * ScreenManager.ThorTVH.SkinTrans[ScreenManager.rHand];// *ScreenManager.ThorTVH.World;
                    // ScreenManager.ThorTVH.arrowWorld = Matrix.Transform(transforms[mesh.ParentBone.Index] * Matrix.CreateTranslation(ScreenManager.ThorTVH.World.Translation), rota);
                    spearWorld = Matrix.Transform(transforms[mesh.ParentBone.Index], rota) * Matrix.CreateTranslation(trans);// *ScreenManager.ThorTVH.SkinTrans[ScreenManager.rHand];
                }



            }




        }

     
        public void UpdateAchillesRage1(GameTime gameTime)
        {


            float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds;
            oldGamePadState = currentGamePadState;
            oldkeyBoardState = currentKeyBoardState;
            World.Decompose(out scale, out rota, out trans);
            oldPosition = Position;
            oldDirection = Direction;
            currentGamePadState = GamePad.GetState(PlayerIndex.One);

            foreach (Projectile2 pro in projectiles)
                pro.update2(gameTime);

            float rotAmt = 0.0f;

            Vector2 rotationAmount = currentGamePadState.ThumbSticks.Left;

            Vector2 inputAmount = currentGamePadState.ThumbSticks.Right;

            //rotAmt = TurnToFace(ScreenManager.asterion.Position, ScreenManager.medusa.Position, Vector3.Zero);
            // Direction = new Vector3((float)Math.Sin(rotAmt), 0.0f, (float)Math.Cos(rotAmt));

            

            if (gameTime.TotalGameTime - playerMoveTime > MoveTimeOut)
            {
                playerMove = null;
            }
            //inputManager.Update(gameTime);
            Move newMove = ScreenManager.moveList.DetectMove(ScreenManager.inputManager);

            if (newMove != null)
            {
                playerMove = newMove;

                playerMoveTime = gameTime.TotalGameTime;

                if (playerMove.Name == "RS")
                {
                    projectiles.Add(new Projectile2("Fire", forwardSpell, Direction));

                }
                if (playerMove.Name == "LT")
                {
                    testingIndex++;
                    if (testingIndex > 2)
                        testingIndex = 0;

                }
                if (playerMove.Name == "RT")
                {
                    //ScreenManager.Theseus.Position = new Vector3(1349.0f, 0.0f, 2770.0f);//13.49 -27.692

                    EternalStruggle.TheseusStandRun2 = true;
                }
                if (playerMove.Name == "LS")
                {
                    if (EternalStruggle.LSs.Count >= 1)
                    {
                        if (EternalStruggle.LSs[0].time.TotalMilliseconds < EternalStruggle.LSs[0].maxTime.TotalMilliseconds / 2)
                        {
                            // EternalStruggle.rageBlocks++;
                            // ScreenManager.UndeadLeader.isKnockBack = true;
                            
                            
                        }
                        EternalStruggle.LSs.RemoveAt(0);
                    }
                    if (!isAtk1)
                    {

                        isAtk1 = true;
                        currentAnimationTime = TimeSpan.Zero;
                        justBones.CopyTo(previousAnimation, 0);
                    }
                    

                }



                if (playerMove.Name == "A")
                {

                    if (EternalStruggle.As.Count >= 1)
                    {
                        if (EternalStruggle.As[0].time.TotalMilliseconds < EternalStruggle.As[0].maxTime.TotalMilliseconds / 2)
                        {
                            EternalStruggle.rageBlocks++;
                           // ScreenManager.UndeadLeader.isKnockBack = true;
                        }
                        EternalStruggle.As.RemoveAt(0);

                        rotAmt = TurnToFace(position, ScreenManager.UndeadLeader.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                        Direction = new Vector3((float)Math.Sin(rotAmt), 0.0f, (float)Math.Cos(rotAmt));
                        Direction = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
                    }
                    if (!isShieldBash)
                    {
                        isShieldBash = true;
                        currentAnimationTime = TimeSpan.Zero;
                        justBones.CopyTo(previousAnimation, 0);

                        //ScreenManager.spears[0].state = 1;
                        //need to set attack
                    }

                }
                if (playerMove.Name == "AA")
                {
                    //if (!isAtk1 && !isAtk2)

                    if (!isShieldUpper)
                    {

                        isShieldUpper = true;
                        //currentAnimationTime = TimeSpan.Zero;
                        //justBones.CopyTo(previousAnimation, 0);

                        if (!isShieldBash)
                            currentAnimationTime = TimeSpan.Zero;


                    }


                }

                if (playerMove.Name == "X")
                {
                    if (!isShieldSpin)
                    {
                        isShieldSpin = true;
                        currentAnimationTime = TimeSpan.Zero;
                    }
                    justBones.CopyTo(previousAnimation, 0);




                }
                Console.WriteLine(playerMove.Name);

            }



            if (isKnockedBack)
            {
                if (!isKnockBack)
                {
                    isKnockBack = true;
                    currentAnimationTime = TimeSpan.Zero;
                    justBones.CopyTo(previousAnimation, 0);

                    isShieldBash = false;
                    isShieldUpper = false;
                    isShieldToss = false;
                }

            }


            //if (Math.Abs(rotationAmount.X) > .3f || Math.Abs(rotationAmount.Y) > .3f)
            {
                //Direction = new Vector3(rotationAmount.X, 0.0f, rotationAmount.Y);


                if ((rotationAmount.X) > .3f)
                {

                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, -.03f));
                }
                if ((rotationAmount.X) < -.3f)
                {
                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, .03f));

                }
                thrustAmount = -currentGamePadState.ThumbSticks.Left.Y;

                if (thrustAmount > 1)
                    thrustAmount = 1.0f;
                if (thrustAmount < -1)
                    thrustAmount = -1.0f;



                if (Math.Abs(thrustAmount) > 0.0f)
                {
                    isRun = true;
                    justBones.CopyTo(previousAnimation, 0);
                }
                else
                {
                    isRun = false;
                    runTime = TimeSpan.Zero;
                }
                //  else
                //  thrustAmount = rotationAmount.Y;
            }
            //else
            //    thrustAmount = 0.0f;

            Up.Normalize();
            Direction.Normalize();




            Right = Vector3.Cross(Direction, Up);
            if (isRun)
            {
                runTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)3.0);
                if (runTime.TotalSeconds < 9.0f)
                {

                    //        if (runTime.TotalSeconds < 1.0f)
                    //        {

                    //            for (int i = 0; i < brace.Length; i++)
                    //            {
                    //                previousAnimation[i].Decompose(out scale, out rota, out trans);
                    //                run1a[i].Decompose(out scale2, out rota2, out trans2);
                    //                upperBones[i] = Matrix.CreateScale(scale2) *
                    //Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
                    //Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                    //            }

                    //        }
                    //        else 
                    if (runTime.TotalSeconds < 1.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun1[i].Decompose(out scale, out rota, out trans);
                            lRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun2[i].Decompose(out scale, out rota, out trans);
                            lRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun3[i].Decompose(out scale, out rota, out trans);
                            lRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun4[i].Decompose(out scale, out rota, out trans);
                            rRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun1[i].Decompose(out scale, out rota, out trans);
                            rRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 5.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 7.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun2[i].Decompose(out scale, out rota, out trans);
                            rRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 6.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 6.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 8.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun3[i].Decompose(out scale, out rota, out trans);
                            rRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 7.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 7.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun4[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 8.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 8.0) / 1.0f));

                        }


                    }

                }
                else
                {

                    runTime = TimeSpan.Zero;
                    lRun1.CopyTo(previousAnimation, 0);



                }

            }
            currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)8);

                if(isAtk1)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            brace[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }                   
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            brace[i].Decompose(out scale, out rota, out trans);
                            AchiSpin1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds -1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            AchiSpin1[i].Decompose(out scale, out rota, out trans);
                            AchiSpin2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            AchiSpin2[i].Decompose(out scale, out rota, out trans);
                            AchiSpin3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 5.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            AchiSpin3[i].Decompose(out scale, out rota, out trans);
                            AchiSpin4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            AchiSpin4[i].Decompose(out scale, out rota, out trans);
                            AchiSpin5[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                        }

                    }
                    else
                    {

                        currentAnimationTime = TimeSpan.Zero;
                        isAtk1 = false;
                        EternalStruggle.RageAgainstTheMachine = false;
                        EternalStruggle.PreAosDialog = true;
                        

                    }


                }

            if (isKnockBack)
            {

                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            kb1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb1[i].Decompose(out scale, out rota, out trans);
                            kb2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb2[i].Decompose(out scale, out rota, out trans);
                            kb3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb3[i].Decompose(out scale, out rota, out trans);
                            knockDown[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }

                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isKnockBack = false;
                    isKnockedBack = false;
                }












            }

            if (isShieldSpin)
            {


                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            shieldSpin1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            shieldSpin1[i].Decompose(out scale, out rota, out trans);
                            shieldSpin2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            shieldSpin2[i].Decompose(out scale, out rota, out trans);
                            shieldSpin3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            shieldSpin3[i].Decompose(out scale, out rota, out trans);
                            shieldSpin4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }




                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isShieldSpin = false;
                }

            }
            if (isShieldBash)
            {
                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 2.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            shieldBash1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 2.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            shieldBash1[i].Decompose(out scale, out rota, out trans);
                            shieldBash2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 4.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 4.0f));

                        }


                    }

                }
                else if (!isShieldUpper)
                {

                    isShieldBash = false;
                    currentAnimationTime = TimeSpan.Zero;



                }

                else if (currentAnimationTime.TotalSeconds < 5.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldBash2[i].Decompose(out scale, out rota, out trans);
                        shieldUpper1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 6.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldUpper1[i].Decompose(out scale, out rota, out trans);
                        shieldUpper2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 7.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldUpper2[i].Decompose(out scale, out rota, out trans);
                        shieldUpper3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 6.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 6.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 9.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldUpper3[i].Decompose(out scale, out rota, out trans);
                        shieldUpper4[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 7.0) / 2.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 7.0) / 2.0f));

                    }


                }

                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isShieldBash = false;
                    isShieldUpper = false;

                }


            }




            //world = Matrix.Identity;
            //world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            //world.Up = Up;
            //world.Right = Right;
            //world.Translation = Position + new Vector3(0.0f, 0.0f, 0.0f);


            //if (isAtk1)
            // upperBones.CopyTo(justBones, 0);
            //else

            // world = Matrix.Identity;

            Position += Direction * thrustAmount * 5.0f;
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldBash)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);

            world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);



            if (isKnockBack)
                Position = oldPosition + knockBackVec * 5.0f;

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();



            //  if (resetFormations)
            {
                //    resetFormations = false;

                formation = world;
            }
            // position = new Vector3(-100.0f, 0.0f, 0.0f);



        }
        public void UpdateHercFinishThor(GameTime gameTime)
        {



            float dToT = Vector3.Distance(position, ScreenManager.ThorTVH.World.Translation);
            float rotationAmount = 0.0f;

            rotationAmount = TurnToFace(position, ScreenManager.ThorTVH.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

            if (dToT > 200.0f)
            {
                thrustAmount = 1.0f;
                if (!isRun)
                {
                    isRun = true;
                    justBones.CopyTo(previousAnimation, 0);
                }
            }
            else
            {
                thrustAmount = 0.0f;
                runTime = TimeSpan.Zero;
                isRun = false;
                if (dToT > 50)
                    thrustAmount = .3f;


                else
                {
                    EternalStruggle.rageBlocks = 0; 
                    thrustAmount = 0.0f;
                    if (!isRockStomp)
                    {
                        isRockStomp = true;
                        justBones.CopyTo(previousAnimation, 0);
                        currentAnimationTime = TimeSpan.Zero;

                    }
                }
            }

            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            Direction = new Vector3(x, 0.0f, y);

            Up = Vector3.Up;
            Right = Vector3.Cross(Direction, Up);

            if (isRun)
            {
                runTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)3.0);
                if (runTime.TotalSeconds < 9.0f)
                {
                    if (runTime.TotalSeconds < 1.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun1[i].Decompose(out scale, out rota, out trans);
                            lRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun2[i].Decompose(out scale, out rota, out trans);
                            lRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun3[i].Decompose(out scale, out rota, out trans);
                            lRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun4[i].Decompose(out scale, out rota, out trans);
                            rRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun1[i].Decompose(out scale, out rota, out trans);
                            rRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 5.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 7.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun2[i].Decompose(out scale, out rota, out trans);
                            rRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 6.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 6.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 8.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun3[i].Decompose(out scale, out rota, out trans);
                            rRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 7.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 7.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun4[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 8.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 8.0) / 1.0f));

                        }


                    }

                }
                else
                {

                    runTime = TimeSpan.Zero;
                    lRun1.CopyTo(previousAnimation, 0);



                }

            } 
            currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)8);
            if (isRockStomp)
            {


                if (currentAnimationTime.TotalSeconds < 2.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            rockStomp1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rockStomp1[i].Decompose(out scale, out rota, out trans);
                            rockStomp2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else
                    {

                        currentAnimationTime = TimeSpan.Zero;
                        isRockStomp = false;


                        EternalStruggle.HerculesVsThorRun = false;
                        EternalStruggle.EternalStruggleRun = true;
                        EternalStruggle.HercFinishThor = false;
                        EternalStruggle.currentIndex++;


                    }
                }
                else
                {

                    currentAnimationTime = TimeSpan.Zero;

                    isRockStomp = false;

                    EternalStruggle.HerculesVsThorRun = false;
                    EternalStruggle.EternalStruggleRun = true;
                    EternalStruggle.HercFinishThor = false;
                    EternalStruggle.currentIndex++;


                }
                
            }

            Position += new Vector3(Direction.X, Direction.Y, Direction.Z) * thrustAmount * 2.0f;
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if(isRockStomp)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);
            world.Forward = new Vector3(-Direction.X, Direction.Y,- Direction.Z);



         

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();



        }
        public void UpdateHercules(GameTime gameTime)
        {

            if (lightninged)
                lightningTimer += gameTime.ElapsedGameTime;

            if (lightningTimer.TotalSeconds > 3.0)
                lightninged = false;

            float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds;
            oldGamePadState = currentGamePadState;
            oldkeyBoardState = currentKeyBoardState;
            World.Decompose(out scale, out rota, out trans);
            oldPosition = Position;
            oldDirection = Direction;
            currentGamePadState = GamePad.GetState(PlayerIndex.One);


            foreach (Projectile2 pro in projectiles)
                pro.update2E(gameTime);

      

            Vector2 rotationAmount = currentGamePadState.ThumbSticks.Left;

            Vector2 inputAmount = currentGamePadState.ThumbSticks.Right;

            //rotAmt = TurnToFace(ScreenManager.asterion.Position, ScreenManager.medusa.Position, Vector3.Zero);
            // Direction = new Vector3((float)Math.Sin(rotAmt), 0.0f, (float)Math.Cos(rotAmt));

            if (gameTime.TotalGameTime - playerMoveTime > MoveTimeOut)
            {
                playerMove = null;
            }
            //inputManager.Update(gameTime);
            Move newMove = ScreenManager.moveList.DetectMove(ScreenManager.inputManager);

            if (newMove != null)
            {
                playerMove = newMove;

                playerMoveTime = gameTime.TotalGameTime;


                if (playerMove.Name == "Y")
                {
                    if (!isRockStomp)
                    {
                        justBones.CopyTo(previousAnimation, 0);
                        currentAnimationTime = TimeSpan.Zero;
                        isRockStomp = true;


                    }



                }
                if (playerMove.Name == "RS")
                {
                    projectiles.Add(new Projectile2("Fire", forwardSpell, Direction));

                }
                if (playerMove.Name == "LT")
                {
                    testingIndex++;
                    if (testingIndex > 2)
                        testingIndex = 0;

                }
                if (playerMove.Name == "RT")
                {

                      



                }
                if (playerMove.Name == "LS")
                {


                    if (EternalStruggle.LSs.Count >= 1)
                    {
                        if (EternalStruggle.LSs[0].time.TotalMilliseconds < EternalStruggle.LSs[0].maxTime.TotalMilliseconds / 2)
                        {
                            EternalStruggle.rageBlocks++;
                            ScreenManager.ThorTVH.isKnockedBack = true;
                            ScreenManager.ThorTVH.blocked = true;
                            // ScreenManager.UndeadLeader.isKnockBack = true;


                        }
                        EternalStruggle.LSs.RemoveAt(0);

                    }




                }


                
                if (playerMove.Name == "A")
                {

                    if (!isPunch)
                    {
                        isPunch = true;
                        currentAnimationTime = TimeSpan.Zero;
                        justBones.CopyTo(previousAnimation, 0);

                        //ScreenManager.spears[0].state = 1;
                        //need to set attack
                    }

                }
                if (playerMove.Name == "AA")
                {
                    //if (!isAtk1 && !isAtk2)

                    if (!isPunchUpper)
                    {

                        isPunchUpper = true;
                        //currentAnimationTime = TimeSpan.Zero;
                        //justBones.CopyTo(previousAnimation, 0);

                        if (!isPunch)
                            currentAnimationTime = TimeSpan.Zero;


                    }


                }
                if (playerMove.Name == "AAA")
                {

                    if (!isPunchGround)
                    {
                        isPunchGround = true;

                        if (!isPunchUpper)
                            currentAnimationTime = TimeSpan.Zero;

                    }
                }

                if (playerMove.Name == "X")
                {
                    if (!isHighKick)
                    {
                        isHighKick = true;
                        currentAnimationTime = TimeSpan.Zero;
                        justBones.CopyTo(previousAnimation, 0);
                    }





                }
                Console.WriteLine(playerMove.Name);

            }

            if (isKnockedBack)
            {
                if (!isKnockBack)
                {
                    isKnockBack = true;
                    currentAnimationTime = TimeSpan.Zero;
                    justBones.CopyTo(previousAnimation, 0);

                    isShieldBash = false;
                    isShieldUpper = false;
                    isShieldToss = false;
                }

            }


            //if (Math.Abs(rotationAmount.X) > .3f || Math.Abs(rotationAmount.Y) > .3f)
            {
                //Direction = new Vector3(rotationAmount.X, 0.0f, rotationAmount.Y);



                if ((rotationAmount.X) > .3f)
                {

                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, -.03f));
                }
                if ((rotationAmount.X) < -.3f)
                {
                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, .03f));

                }
                thrustAmount = -currentGamePadState.ThumbSticks.Left.Y;

                if (thrustAmount > 1)
                    thrustAmount = 1.0f;
                if (thrustAmount < -1)
                    thrustAmount = -1.0f;



                if (Math.Abs(thrustAmount) > 0.0f)
                {
                    isRun = true;
                    justBones.CopyTo(previousAnimation, 0);
                }
                else
                {
                    isRun = false;
                    runTime = TimeSpan.Zero;
                }
                //  else
                //  thrustAmount = rotationAmount.Y;
            }
            //else
            //    thrustAmount = 0.0f;

            Up.Normalize();
            Direction.Normalize();




            Right = Vector3.Cross(Direction, Up);
            if (isRun)
            {
                runTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)3.0);
                if (runTime.TotalSeconds < 9.0f)
                {

                    //        if (runTime.TotalSeconds < 1.0f)
                    //        {

                    //            for (int i = 0; i < brace.Length; i++)
                    //            {
                    //                previousAnimation[i].Decompose(out scale, out rota, out trans);
                    //                run1a[i].Decompose(out scale2, out rota2, out trans2);
                    //                upperBones[i] = Matrix.CreateScale(scale2) *
                    //Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
                    //Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                    //            }

                    //        }
                    //        else 
                    if (runTime.TotalSeconds < 1.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun1[i].Decompose(out scale, out rota, out trans);
                            lRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun2[i].Decompose(out scale, out rota, out trans);
                            lRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun3[i].Decompose(out scale, out rota, out trans);
                            lRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun4[i].Decompose(out scale, out rota, out trans);
                            rRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun1[i].Decompose(out scale, out rota, out trans);
                            rRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 5.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 7.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun2[i].Decompose(out scale, out rota, out trans);
                            rRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 6.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 6.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 8.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun3[i].Decompose(out scale, out rota, out trans);
                            rRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 7.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 7.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun4[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 8.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 8.0) / 1.0f));

                        }


                    }

                }
                else
                {

                    runTime = TimeSpan.Zero;
                    lRun1.CopyTo(previousAnimation, 0);



                }

            }
            currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)8);


            if (isKnockBack)
            {

                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            kb1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb1[i].Decompose(out scale, out rota, out trans);
                            kb2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb2[i].Decompose(out scale, out rota, out trans);
                            kb3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb3[i].Decompose(out scale, out rota, out trans);
                            knockDown[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }

                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isKnockBack = false;
                    isKnockedBack = false;
                }












            }

            if (isRockStomp)
            {





                 if (currentAnimationTime.TotalSeconds < 5.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            rockStomp1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            rockStomp1[i].Decompose(out scale, out rota, out trans);
                            rockStomp2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds-1.0f) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds -1.0f) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rockStomp2[i].Decompose(out scale, out rota, out trans);
                            punch1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            punch1[i].Decompose(out scale, out rota, out trans);
                            punch2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds <5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            punch2[i].Decompose(out scale, out rota, out trans);
                            punch3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }

                }
                else
                {
                    projectiles.Add(new Projectile2("Rock", arrowWorld, Direction));
                    currentAnimationTime = TimeSpan.Zero;
                    isRockStomp = false;
                }

            




















            }

            if (isHighKick)
            {


                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            highKick2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            highKick2[i].Decompose(out scale, out rota, out trans);
                            highKick1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds-1.0f) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds -1.0f) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            highKick1[i].Decompose(out scale, out rota, out trans);
                            highKick2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 2.0f));

                        }


                    }

                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isHighKick = false;
                }

            }
            if (isPunch)
            {
                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 2.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            punch1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 2.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            punch1[i].Decompose(out scale, out rota, out trans);
                            punch2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 4.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 4.0f));

                        }


                    }

                }
                else if (!isPunchUpper)
                {

                    isPunch = false;
                    currentAnimationTime = TimeSpan.Zero;



                }

                else if (currentAnimationTime.TotalSeconds < 5.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        punch2[i].Decompose(out scale, out rota, out trans);
                        punchUpper1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 6.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        punchUpper1[i].Decompose(out scale, out rota, out trans);
                        punchUpper2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 7.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        punchUpper2[i].Decompose(out scale, out rota, out trans);
                        punchUpper3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 6.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 6.0) / 1.0f));

                    }


                }
                else if (!isPunchGround)
                {
                    isPunch = false;
                    isPunchUpper = false;
                    currentAnimationTime = TimeSpan.Zero;

                }
                else if (currentAnimationTime.TotalSeconds < 8.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                       punchUpper3[i].Decompose(out scale, out rota, out trans);
                        punchGround1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 7.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 7.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 9.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        punchGround1[i].Decompose(out scale, out rota, out trans);
                        punchGround2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 8.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 8.0) / 1.0f));

                    }


                }

                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isPunch = false;
                    isPunchGround = false;
                    isPunchUpper = false;

                }


            }




            //world = Matrix.Identity;
            //world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            //world.Up = Up;
            //world.Right = Right;
            //world.Translation = Position + new Vector3(0.0f, 0.0f, 0.0f);


            //if (isAtk1)
            // upperBones.CopyTo(justBones, 0);
            //else

            // world = Matrix.Identity;

            Position += Direction * thrustAmount * 5.0f;
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if(isRockStomp)
                upperBones.CopyTo(justBones, 0);
            else if (isHighKick)
                upperBones.CopyTo(justBones, 0);
            else if (isPunch)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (lightninged)
                knockDown.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);

            world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);



            if (isKnockBack)
                Position = oldPosition + knockBackVec * 5.0f;

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();



            //  if (resetFormations)
            {
                //    resetFormations = false;

                formation = world;
            }
            // position = new Vector3(-100.0f, 0.0f, 0.0f);



        }
        public void UpdateMichael(GameTime gameTime)
        {


            float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds;
            oldGamePadState = currentGamePadState;
            oldkeyBoardState = currentKeyBoardState;
            World.Decompose(out scale, out rota, out trans);
            oldPosition = Position;
            oldDirection = Direction;
            currentGamePadState = GamePad.GetState(PlayerIndex.One);

            foreach (Projectile2 pro in projectiles)
                pro.update2(gameTime);


            Vector2 rotationAmount = currentGamePadState.ThumbSticks.Left;

            Vector2 inputAmount = currentGamePadState.ThumbSticks.Right;

            //rotAmt = TurnToFace(ScreenManager.asterion.Position, ScreenManager.medusa.Position, Vector3.Zero);
            // Direction = new Vector3((float)Math.Sin(rotAmt), 0.0f, (float)Math.Cos(rotAmt));

            if (gameTime.TotalGameTime - playerMoveTime > MoveTimeOut)
            {
                playerMove = null;
            }
            //inputManager.Update(gameTime);
            Move newMove = ScreenManager.moveList.DetectMove(ScreenManager.inputManager);

            if (newMove != null)
            {
                playerMove = newMove;

                playerMoveTime = gameTime.TotalGameTime;

                if (playerMove.Name == "RS")
                {
                    projectiles.Add(new Projectile2("Fire", forwardSpell, Direction));

                }
                if (playerMove.Name == "LT")
                {
                    testingIndex++;
                    if (testingIndex > 2)
                        testingIndex = 0;

                }
                if (playerMove.Name == "RT")
                {

                }
                if (playerMove.Name == "LS")
                {


                }



                if (playerMove.Name == "A")
                {

                    if (!isAngelAtka)
                    {
                        isAngelAtka = true;
                        currentAnimationTime = TimeSpan.Zero;
                        justBones.CopyTo(previousAnimation, 0);

                        //ScreenManager.spears[0].state = 1;
                        //need to set attack
                    }

                }
                if (playerMove.Name == "AA")
                {
                    //if (!isAtk1 && !isAtk2)

                    if (!isAngelAtkb)
                    {

                        isAngelAtkb = true;
                        //currentAnimationTime = TimeSpan.Zero;
                        //justBones.CopyTo(previousAnimation, 0);

                        if (!isAngelAtka)
                            currentAnimationTime = TimeSpan.Zero;


                    }


                }

                if (playerMove.Name == "X")
                {
                    if (!isAngelSwoosh)
                    {
                        isAngelSwoosh = true;
                        currentAnimationTime = TimeSpan.Zero;
                    }
                    justBones.CopyTo(previousAnimation, 0);




                }
                Console.WriteLine(playerMove.Name);

            }

            if (isKnockedBack)
            {
                if (!isKnockBack)
                {
                    isKnockBack = true;
                    currentAnimationTime = TimeSpan.Zero;
                    justBones.CopyTo(previousAnimation, 0);

                    isShieldBash = false;
                    isShieldUpper = false;
                    isShieldToss = false;
                }

            }


            //if (Math.Abs(rotationAmount.X) > .3f || Math.Abs(rotationAmount.Y) > .3f)
            {
                //Direction = new Vector3(rotationAmount.X, 0.0f, rotationAmount.Y);



                if ((rotationAmount.X) > .3f)
                {

                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, -.03f));
                }
                if ((rotationAmount.X) < -.3f)
                {
                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, .03f));

                }
                thrustAmount = -currentGamePadState.ThumbSticks.Left.Y;

                if (thrustAmount > 1)
                    thrustAmount = 1.0f;
                if (thrustAmount < -1)
                    thrustAmount = -1.0f;



                if (Math.Abs(thrustAmount) > 0.0f)
                {
                    isRun = true;
                    justBones.CopyTo(previousAnimation, 0);
                }
                else
                {
                    isRun = false;
                    runTime = TimeSpan.Zero;
                }
                //  else
                //  thrustAmount = rotationAmount.Y;
            }
            //else
            //    thrustAmount = 0.0f;

            Up.Normalize();
            Direction.Normalize();




            Right = Vector3.Cross(Direction, Up);
            if (isRun)
            {
                runTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)3.0);
                if (runTime.TotalSeconds < 4.0f)
                {

                    //        if (runTime.TotalSeconds < 1.0f)
                    //        {

                    //            for (int i = 0; i < brace.Length; i++)
                    //            {
                    //                previousAnimation[i].Decompose(out scale, out rota, out trans);
                    //                run1a[i].Decompose(out scale2, out rota2, out trans2);
                    //                upperBones[i] = Matrix.CreateScale(scale2) *
                    //Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
                    //Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                    //            }

                    //        }
                    //        else 
                    if (runTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            wing1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 2.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            wing1[i].Decompose(out scale, out rota, out trans);
                            wing2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 2.0) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 2.0) / 2.0f));

                        }


                    }
                    else
                    {

                        wing2.CopyTo(previousAnimation, 0);
                        runTime = TimeSpan.Zero;

                    }
                }
                   

            }
            currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)8);

            if (isKnockBack)
            {

                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            kb1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb1[i].Decompose(out scale, out rota, out trans);
                            kb2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb2[i].Decompose(out scale, out rota, out trans);
                            kb3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb3[i].Decompose(out scale, out rota, out trans);
                            knockDown[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }

                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isKnockBack = false;
                    isKnockedBack = false;
                }












            }

            if (isAngelSwoosh)
            {


               

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            angelSwoosh1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            angelSwoosh1[i].Decompose(out scale, out rota, out trans);
                            angelSwoosh2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            angelSwoosh2[i].Decompose(out scale, out rota, out trans);
                            angelSwoosh3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            angelSwoosh3[i].Decompose(out scale, out rota, out trans);
                            angelSwoosh4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            angelSwoosh4[i].Decompose(out scale, out rota, out trans);
                            angelSwoosh5[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }

                    else
                    {
                        currentAnimationTime = TimeSpan.Zero;
                        isAngelSwoosh = false;
                    }

                }

      
            
                if (isAngelAtka)
                {
                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            angelAtka1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            angelAtka1[i].Decompose(out scale, out rota, out trans);
                            angelAtka2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            angelAtka2[i].Decompose(out scale, out rota, out trans);
                            angelAtka3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (!isAngelAtkb)
                    {

                        isAngelAtka = false;
                        currentAnimationTime = TimeSpan.Zero;



                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            angelAtka3[i].Decompose(out scale, out rota, out trans);
                            angelAtkb1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            angelAtkb1[i].Decompose(out scale, out rota, out trans);
                            angelAtkb2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            angelAtkb2[i].Decompose(out scale, out rota, out trans);
                            angelAtkb3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                        }


                    }

                    else
                    {
                        currentAnimationTime = TimeSpan.Zero;
                        isAngelAtka = false;
                        isAngelAtkb = false;

                    }


                
            }




            //world = Matrix.Identity;
            //world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            //world.Up = Up;
            //world.Right = Right;
            //world.Translation = Position + new Vector3(0.0f, 0.0f, 0.0f);


            //if (isAtk1)
            // upperBones.CopyTo(justBones, 0);
            //else

            // world = Matrix.Identity;

            Position += Direction * thrustAmount * 5.0f;
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isAngelAtka)
                upperBones.CopyTo(justBones, 0);
            else if (isAngelSwoosh)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);

            world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);



            if (isKnockBack)
                Position = oldPosition + knockBackVec * 5.0f;

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();



            //  if (resetFormations)
            {
                //    resetFormations = false;

                formation = world;
            }
            // position = new Vector3(-100.0f, 0.0f, 0.0f);



        }
        public void UpdateTheseusTS(GameTime gameTime)
        {


            float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds;
            oldGamePadState = currentGamePadState;
            oldkeyBoardState = currentKeyBoardState;
            World.Decompose(out scale, out rota, out trans);
            oldPosition = Position;
            oldDirection = Direction;
            currentGamePadState = GamePad.GetState(PlayerIndex.One);


            foreach (Projectile2 pro in projectiles)
                pro.update2(gameTime);


            Vector2 rotationAmount = currentGamePadState.ThumbSticks.Left;

            Vector2 inputAmount = currentGamePadState.ThumbSticks.Right;

            //rotAmt = TurnToFace(ScreenManager.asterion.Position, ScreenManager.medusa.Position, Vector3.Zero);
            // Direction = new Vector3((float)Math.Sin(rotAmt), 0.0f, (float)Math.Cos(rotAmt));

            if (gameTime.TotalGameTime - playerMoveTime > MoveTimeOut)
            {
                playerMove = null;
            }
            //inputManager.Update(gameTime);
            Move newMove = ScreenManager.moveList.DetectMove(ScreenManager.inputManager);

            if (newMove != null)
            {
                playerMove = newMove;

                playerMoveTime = gameTime.TotalGameTime;

                if (playerMove.Name == "RS")
                {
                    projectiles.Add(new Projectile2("Fire", forwardSpell, Direction));

                }
                if (playerMove.Name == "LT")
                {
                    testingIndex++;
                    if (testingIndex > 2)
                        testingIndex = 0;

                }
                if (playerMove.Name == "RT")
                {
                    //ScreenManager.Theseus.Position = new Vector3(1349.0f, 0.0f, 2770.0f);//13.49 -27.692

                    EternalStruggle.TheseusStandRun2 = true;
                }
                if (playerMove.Name == "Y")
                {

                    if (!isShieldToss)
                    {
                        isShieldToss = true;
                        currentAnimationTime = TimeSpan.Zero;
                        justBones.CopyTo(previousAnimation, 0);

                        //ScreenManager.spears[0].state = 1;
                        //need to set attack


                    }



                }
                if (playerMove.Name == "LS")
                {

                    //if (EternalStruggle.LSs.Count >= 1)
                    //{
                    //    if (EternalStruggle.LSs[0].time.TotalMilliseconds < EternalStruggle.LSs[0].maxTime.TotalMilliseconds / 2)
                    //    {
                    //        EternalStruggle.rageBlocks++;
                    //        // ScreenManager..isKnockedBack = true;
                    //        //  ScreenManager.ThorTVH.blocked = true;
                    //        // ScreenManager.UndeadLeader.isKnockBack = true;


                    //    }
                    //    EternalStruggle.LSs.RemoveAt(0);
                    //}
                }



                if (playerMove.Name == "A")
                {

                    if (!isShieldBash)
                    {
                        isShieldBash = true;
                        currentAnimationTime = TimeSpan.Zero;
                        justBones.CopyTo(previousAnimation, 0);

                        //ScreenManager.spears[0].state = 1;
                        //need to set attack

 
                    }


                }
                if (playerMove.Name == "AA")
                {
                    //if (!isAtk1 && !isAtk2)

                    if (!isShieldUpper)
                    {

                        isShieldUpper = true;
                        //currentAnimationTime = TimeSpan.Zero;
                        //justBones.CopyTo(previousAnimation, 0);

                        if (!isShieldBash)
                            currentAnimationTime = TimeSpan.Zero;


                    }


                }

                if (playerMove.Name == "X")
                {
                    if (!isShieldSpin)
                    {
                        isShieldSpin = true;
                        currentAnimationTime = TimeSpan.Zero;
                    }
                    justBones.CopyTo(previousAnimation, 0);




                }
                Console.WriteLine(playerMove.Name);

            }

            if (isKnockedBack)
            {
                if (!isKnockBack)
                {
                    isKnockBack = true;
                    currentAnimationTime = TimeSpan.Zero;
                    justBones.CopyTo(previousAnimation, 0);

                    isShieldBash = false;
                    isShieldUpper = false;
                    isShieldToss = false;
                }

            }


            //if (Math.Abs(rotationAmount.X) > .3f || Math.Abs(rotationAmount.Y) > .3f)
            {
                //Direction = new Vector3(rotationAmount.X, 0.0f, rotationAmount.Y);



                if ((rotationAmount.X) > .3f)
                {

                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, -.03f));
                }
                if ((rotationAmount.X) < -.3f)
                {
                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, .03f));

                }
                thrustAmount = -currentGamePadState.ThumbSticks.Left.Y;

                if (thrustAmount > 1)
                    thrustAmount = 1.0f;
                if (thrustAmount < -1)
                    thrustAmount = -1.0f;



                if (Math.Abs(thrustAmount) > 0.0f)
                {
                    isRun = true;
                    justBones.CopyTo(previousAnimation, 0);
                }
                else
                {
                    isRun = false;
                    runTime = TimeSpan.Zero;
                }
                //  else
                //  thrustAmount = rotationAmount.Y;
            }
            //else
            //    thrustAmount = 0.0f;

            Up.Normalize();
            Direction.Normalize();




            Right = Vector3.Cross(Direction, Up);
            if (isRun)
            {
                runTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)3.0);
                if (runTime.TotalSeconds < 9.0f)
                {

                    //        if (runTime.TotalSeconds < 1.0f)
                    //        {

                    //            for (int i = 0; i < brace.Length; i++)
                    //            {
                    //                previousAnimation[i].Decompose(out scale, out rota, out trans);
                    //                run1a[i].Decompose(out scale2, out rota2, out trans2);
                    //                upperBones[i] = Matrix.CreateScale(scale2) *
                    //Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
                    //Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                    //            }

                    //        }
                    //        else 
                    if (runTime.TotalSeconds < 1.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun1[i].Decompose(out scale, out rota, out trans);
                            lRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun2[i].Decompose(out scale, out rota, out trans);
                            lRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun3[i].Decompose(out scale, out rota, out trans);
                            lRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun4[i].Decompose(out scale, out rota, out trans);
                            rRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun1[i].Decompose(out scale, out rota, out trans);
                            rRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 5.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 7.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun2[i].Decompose(out scale, out rota, out trans);
                            rRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 6.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 6.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 8.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun3[i].Decompose(out scale, out rota, out trans);
                            rRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 7.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 7.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun4[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 8.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 8.0) / 1.0f));

                        }


                    }

                }
                else
                {

                    runTime = TimeSpan.Zero;
                    lRun1.CopyTo(previousAnimation, 0);



                }

            }
            currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)8);

            if (isShieldToss)
            {

       
                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            shieldToss1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            shieldToss1[i].Decompose(out scale, out rota, out trans);
                            shieldToss2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            shieldToss2[i].Decompose(out scale, out rota, out trans);
                            shieldToss3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else
                    {


                        isShieldToss = false;
                        currentAnimationTime = TimeSpan.Zero;
                        projectiles.Add(new Projectile2("Shield", arrowWorld, Direction));

                    }
              
            }
            if (isKnockBack)
            {

                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            kb1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb1[i].Decompose(out scale, out rota, out trans);
                            kb2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb2[i].Decompose(out scale, out rota, out trans);
                            kb3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            kb3[i].Decompose(out scale, out rota, out trans);
                            knockDown[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }

                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isKnockBack = false;
                    isKnockedBack = false;
                }












            }

            if (isShieldSpin)
            {


                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            shieldSpin1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            shieldSpin1[i].Decompose(out scale, out rota, out trans);
                            shieldSpin2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            shieldSpin2[i].Decompose(out scale, out rota, out trans);
                            shieldSpin3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            shieldSpin3[i].Decompose(out scale, out rota, out trans);
                            shieldSpin4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }




                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isShieldSpin = false;
                }

            }
            if (isShieldBash)
            {
                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 2.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            shieldBash1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 2.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            shieldBash1[i].Decompose(out scale, out rota, out trans);
                            shieldBash2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 4.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 4.0f));

                        }


                    }

                }
                else if (!isShieldUpper)
                {

                    isShieldBash = false;
                    currentAnimationTime = TimeSpan.Zero;



                }

                else if (currentAnimationTime.TotalSeconds < 5.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldBash2[i].Decompose(out scale, out rota, out trans);
                        shieldUpper1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 6.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldUpper1[i].Decompose(out scale, out rota, out trans);
                        shieldUpper2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 7.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldUpper2[i].Decompose(out scale, out rota, out trans);
                        shieldUpper3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 6.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 6.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 9.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldUpper3[i].Decompose(out scale, out rota, out trans);
                        shieldUpper4[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 7.0) / 2.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 7.0) / 2.0f));

                    }


                }

                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isShieldBash = false;
                    isShieldUpper = false;

                }


            }




            //world = Matrix.Identity;
            //world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            //world.Up = Up;
            //world.Right = Right;
            //world.Translation = Position + new Vector3(0.0f, 0.0f, 0.0f);


            //if (isAtk1)
            // upperBones.CopyTo(justBones, 0);
            //else

            // world = Matrix.Identity;

            Position += Direction * thrustAmount * 5.0f;
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldSpin)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldBash)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldToss)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);

            world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);



            if (isKnockBack)
                Position = oldPosition + knockBackVec * 5.0f;

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();



            //  if (resetFormations)
            {
                //    resetFormations = false;

                formation = world;
            }
            // position = new Vector3(-100.0f, 0.0f, 0.0f);



        }
        public void UpdateCupid(GameTime gameTime)
        {


            float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds;
            oldGamePadState = currentGamePadState;
            oldkeyBoardState = currentKeyBoardState;
            World.Decompose(out scale, out rota, out trans);
            oldPosition = Position;
            oldDirection = Direction;
            currentGamePadState = GamePad.GetState(PlayerIndex.One);

            //foreach (Projectile2 pro in projectiles)
            //{
            //    pro.update2(gameTime);
            //    projectiles.Remove(pro);                  
            //}

            for (int i = 0; i < projectiles.Count; i++)
            {
                projectiles[i].update2(gameTime);
                if (!projectiles[i].alive)
                    projectiles.RemoveAt(i);

            }




            //float rororo = TurnToFace(position, ScreenManager.Perseus.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
            //Console.WriteLine(rororo);
            Vector2 rotationAmount = currentGamePadState.ThumbSticks.Left;

            Vector2 inputAmount = currentGamePadState.ThumbSticks.Right;

            //rotAmt = TurnToFace(ScreenManager.asterion.Position, ScreenManager.medusa.Position, Vector3.Zero);
            // Direction = new Vector3((float)Math.Sin(rotAmt), 0.0f, (float)Math.Cos(rotAmt));

            if (gameTime.TotalGameTime - playerMoveTime > MoveTimeOut)
            {
                playerMove = null;
            }
            //inputManager.Update(gameTime);
            Move newMove = ScreenManager.moveList.DetectMove(ScreenManager.inputManager);


            if (newMove != null)
            {
                playerMove = newMove;

                playerMoveTime = gameTime.TotalGameTime;
                if (playerMove.Name == "Y")
                {
                    if (fightClass == 0)
                        if (!isShieldToss)
                        {
                            isShieldToss = true;

                            currentAnimationTime = TimeSpan.Zero;
                            justBones.CopyTo(previousAnimation, 0);


                        }
                    if (fightClass == 1)
                    {
                        if (!isBow)
                        {
                            isBow = true;

                            currentAnimationTime = TimeSpan.Zero;
                            justBones.CopyTo(previousAnimation, 0);


                        }




                    }

                }
                if (playerMove.Name == "RS")
                {
                    projectiles.Add(new Projectile2("Fire", forwardSpell, Direction));

                }
                if (playerMove.Name == "LT")
                {
                    testingIndex++;
                    if (testingIndex > 2)
                        testingIndex = 0;

                }
                if (playerMove.Name == "RT")
                {
                    //ScreenManager.Theseus.Position = new Vector3(1349.0f, 0.0f, 2770.0f);//13.49 -27.692

                    fightClass++;
                    if (fightClass == 2)
                        fightClass = 0;
                }
                if (playerMove.Name == "LS")
                {


                }



                if (playerMove.Name == "A")
                {
                    if (fightClass == 1)
                    {
                        if (!isShieldBash)
                        {
                            isShieldBash = true;
                            currentAnimationTime = TimeSpan.Zero;
                            justBones.CopyTo(previousAnimation, 0);

                            //ScreenManager.spears[0].state = 1;
                            //need to set attack
                        }
                    }
                    else if (fightClass == 0)
                    {
                        if (!isAtk1)
                        {


                            isAtk1 = true;
                            currentAnimationTime = TimeSpan.Zero;
                            justBones.CopyTo(previousAnimation, 0);
                        }

                    }



                }
                if (playerMove.Name == "AA")
                {
                    //if (!isAtk1 && !isAtk2)

                    if (!isShieldUpper)
                    {

                        isShieldUpper = true;
                        //currentAnimationTime = TimeSpan.Zero;
                        //justBones.CopyTo(previousAnimation, 0);

                        if (!isShieldBash)
                            currentAnimationTime = TimeSpan.Zero;


                    }


                }

                if (playerMove.Name == "X")
                {
                    if (!isShieldSpin)
                    {
                        isShieldSpin = true;
                        currentAnimationTime = TimeSpan.Zero;
                    }
                    justBones.CopyTo(previousAnimation, 0);




                }
                Console.WriteLine(playerMove.Name);

            }
            if (currentGamePadState.IsButtonDown(Buttons.B))
                isShield = true;
            else
                isShield = false;

            if (isKnockedBack)
            {
                if (!isKnockBack)
                {
                    isKnockBack = true;
                    currentAnimationTime = TimeSpan.Zero;
                    justBones.CopyTo(previousAnimation, 0);

                    isShieldBash = false;
                    isShieldUpper = false;
                    isShieldToss = false;
                }

            }


            //if (Math.Abs(rotationAmount.X) > .3f || Math.Abs(rotationAmount.Y) > .3f)
            {
                //Direction = new Vector3(rotationAmount.X, 0.0f, rotationAmount.Y);



                if ((rotationAmount.X) > .3f)
                {

                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, -.01f));
                }
                if ((rotationAmount.X) < -.3f)
                {
                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, .01f));

                }
                thrustAmount = -currentGamePadState.ThumbSticks.Left.Y;

                if (thrustAmount > 1)
                    thrustAmount = 1.0f;
                if (thrustAmount < -1)
                    thrustAmount = -1.0f;



                if (Math.Abs(thrustAmount) > 0.0f)
                {
                    isRun = true;
                    justBones.CopyTo(previousAnimation, 0);
                }
                else
                {
                    isRun = false;
                    runTime = TimeSpan.Zero;
                }
                //  else
                //  thrustAmount = rotationAmount.Y;
            }
            //else
            //    thrustAmount = 0.0f;

            Up.Normalize();
            Direction.Normalize();




            Right = Vector3.Cross(Direction, Up);
            if (isRun)
                updateRun(gameTime);
            //currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)8);
            if (isShield)
                UpdateShield(gameTime);
            if (isKnockBack)
                UpdateKnockBack(gameTime);
            if (isShieldToss)
                UpdateShieldToss(gameTime);
            if (isBow)
                UpdateBow(gameTime);
            if (isAtk1)
            {
                UpdateBasic1(gameTime);
             //   Position += Direction * 3.0f * (float)currentAnimationTime.TotalSeconds/4.0f;
            }

            if (isShieldSpin)
            {
                UpdateShieldSpin(gameTime);

            }
            if (isShieldBash)
            {
                UpdateShieldBash(gameTime);
            }
            if (isShieldUpper)
            {
                UpdateShieldUpper(gameTime);
            }
            if (isHurt)
            {
                hurtUpdate(gameTime);
            }
            Position += Direction * thrustAmount * 5.0f;
            if (isHurt)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldToss)
                upperBones.CopyTo(justBones, 0);
            else if (isBow)
                upperBones.CopyTo(justBones, 0);
            else if (isShield)
                upperBones.CopyTo(justBones, 0);
            else if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldSpin)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldBash)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);

            world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);



            if (isKnockBack)
                Position = oldPosition + knockBackVec * 5.0f;

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            ray = new Ray(new Vector3(Position.X, 90.0f, Position.Z), Direction);


            //  if (resetFormations)
            {
                //    resetFormations = false;

                formation = Matrix.Identity;
                formation.Translation = Position;
                formation.Forward = Vector3.Forward;
                formation.Up = Vector3.Up;
                formation.Right = Vector3.Right;
            }
            // position = new Vector3(-100.0f, 0.0f, 0.0f);



        }
        public void UpdateFWiz(GameTime gameTime)
        {
            for (int i = 0; i < hRs.Count; i++)
            {
                hRs[i].update(gameTime);
            }
            for (int i = 0; i < hCs.Count; i++)
            {
                hCs[i].update(gameTime);

            }
            for (int i = 0; i < hFs.Count; i++)
            {
                hFs[i].update(gameTime);

            }
            
            for (int i = 0; i < projectiles.Count; i++)
            {
                projectiles[i].update2E(gameTime);
                if (!projectiles[i].alive)
                    projectiles.RemoveAt(i);

            }
            for (int i = 0; i < eruptions.Count; i++)
            {
                eruptions[i].updateEruption(gameTime);
                if (!eruptions[i].alive)
                    eruptions.RemoveAt(i);

            }

          //  if (!channeling)
            //    AreaEffectDirection = Direction;

          //  channeling = true;
            updateRays();
            float dToF = Vector3.Distance(position, ScreenManager.Theseus.Position);


             cylinderDistance = Vector3.Distance(forwardSpell.Translation, ScreenManager.Theseus.Position) - 25.6f;

             //AreaEffectDirection = DirFromFloat(TurnToFaceSlow(AreaEffectCenter, ScreenManager.Theseus.Position, AreaEffectDirection));
            AreaEffectDirection = DirFromFloat(TurnToFaceSpeed(AreaEffectCenter, ScreenManager.Theseus.Position, AreaEffectDirection, 1.0f));
             AreaEffectCenter += AreaEffectDirection * 5.0f;
             areaSphere.BS = new BoundingSphere(AreaEffectCenter, 50.0f);

             cTime += gameTime.ElapsedGameTime.Milliseconds;
            cInterval += gameTime.ElapsedGameTime.Milliseconds;
            if (cInterval > 1000)
            {
                hRs.Add(new horizontalRing(5, world));

                cInterval -= 1000;
            }
            #region eruptions
            //ERUPTIONS
            //if(cInterval > 500)
            //{
            //    double ran1 = ScreenManager.rand.NextDouble();
            //    double ran2 = ScreenManager.rand.NextDouble();
            //    double ran3 = ScreenManager.rand.NextDouble();
            //    double ran4 = ScreenManager.rand.NextDouble();
            //    int rise1 = 50 + ScreenManager.rand.Next(80);
            //    int rise2 = 50 + ScreenManager.rand.Next(80);
            //    int rise3 = 50 + ScreenManager.rand.Next(80);
            //    int rise4 = 50 + ScreenManager.rand.Next(80);
            //    Matrix erupWorld = World;
            //    erupWorld.Translation = AreaEffectCenter;
            //    eruptions.Add(new Projectile2("Eruption", erupWorld, DirFromDouble(ran1), DirFromDouble(ran2), DirFromDouble(ran3),
            //            DirFromDouble(ran4), rise1, rise2, rise3, rise4));
            //    cInterval -= 500;

            //}
            //if (cTime > 10000)
            //{
            //    AreaEffectCenter = Position;
            //    cTime = 0; 
            // }

            #endregion


            float rotationAmount = 0.0f;
            rotationAmount = TurnToFaceSlow(position, ScreenManager.Theseus.Position, Direction);
            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);

            Direction = new Vector3(x, 0.0f, y);



            if (dToF < 10 && state == 1)
                state = 0;
            else
                thrustAmount = 1.0f;

            if (state == 1)
                Position += Direction * thrustAmount;


            brace.CopyTo(justBones, 0);

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;

            forwardRay.Position = Position;
            forwardRay.Position.Y = 70;
            forwardRay.Direction = Direction;



            makeCylinder();
            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();


        }
        public void UpdateSmartMove(GameTime gameTime)
        {
            updateRays();
            float dToF = Vector3.Distance(position, moveVec);
            float rotationAmount = 0.0f;
            rotationAmount = TurnToFace(position, moveVec, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
            float x = (float)Math.Sin(rotationAmount);
            float y = (float)Math.Cos(rotationAmount);
            
            Direction = new Vector3(x, 0.0f, y);
            
            if (dToF < 10 && state == 1)
                state = 0;
            else
                thrustAmount = 1.0f;

            if (state == 1)
                Position += Direction * thrustAmount;


            brace.CopyTo(justBones, 0);

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;

            forwardRay.Position = Position;
            forwardRay.Position.Y = 70;
            forwardRay.Direction = Direction;




            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();


        }

        public void UpdateTheseusRTS(GameTime gameTime)
        {
            oldGamePadState = currentGamePadState;
            oldkeyBoardState = currentKeyBoardState;

            currentKeyBoardState = Keyboard.GetState();

            for (int i = 0; i < projectiles.Count; i++)
            {
                projectiles[i].update2RTS(gameTime);
                if (!projectiles[i].alive)
                    projectiles.RemoveAt(i);

            }

            if (currentKeyBoardState.IsKeyDown(Keys.Escape)&& oldkeyBoardState.IsKeyUp(Keys.Escape))
                ScreenManager.aGame.Exit();
            if (currentKeyBoardState.IsKeyDown(Keys.D1) && oldkeyBoardState.IsKeyUp(Keys.D1))
            {
                if (fightClass == 1)
                    fightClass = 0;
                if (fightClass == 0)
                    fightClass = 1;
            }
            if (currentKeyBoardState.IsKeyDown(Keys.D2) && oldkeyBoardState.IsKeyUp(Keys.D2))
            {
                castId = 1;
                //castState = 1; 

            }

            if (castState == 1)
            {
                castState = 0;
                if (castId == 1)
                {

                    projectiles.Add(new Projectile2("Fire", forwardSpell, Direction));
                }


            }

            Vector3 faceVec = Vector3.Zero;
            if (aiState == 0)
                faceVec = moveVec;
            if (aiState == 1)
                faceVec = atkVec;
            
                float dTof = Vector3.Distance(position, faceVec);
                float rotationAmount = 0.0f;
                rotationAmount = TurnToFace(position, faceVec, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                //if (aiState == 1)
                //{
                //    rotationAmount = TurnToFace(position, ScreenManager.Jailer.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                //    dTof = Vector3.Distance(position, ScreenManager.Jailer.World.Translation);
                //}
                float x = (float)Math.Sin(rotationAmount);
                float y = (float)Math.Cos(rotationAmount);
                Direction = new Vector3(x, 0.0f, y);
            if(aiState == 0)
                if (dTof > 20.0f)
                {
                    thrustAmount = 1.0f;
                    if (!isRun)
                    {
                        isRun = true;
                        justBones.CopyTo(previousAnimation, 0);
                    }
                }
                else
                {
                    thrustAmount = 0.0f;
                    runTime = TimeSpan.Zero;
                    isRun = false;
                }
            if (aiState == 1)
                thrustAmount = 0.0f;
            //else





            Up = Vector3.Up;
            Up.Normalize();
            Direction.Normalize();
            Right = Vector3.Cross(Direction, Up);
            Position += Direction * thrustAmount * 2.0f;


            // Right = Vector3.Cross(Direction, Up);
            if (isRun)
                updateRun(gameTime);
            //currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)8);
            if (isJump)
                UpdateJump(gameTime);
            if (isShield)
                UpdateShield(gameTime);
            if (isKnockBack)
                UpdateKnockBack(gameTime);
            if (isShieldToss)
                UpdateShieldToss(gameTime);
            if (isBow)
                UpdateBow(gameTime);
            if (isAtk1)
                UpdateBasic1(gameTime);
            else if (isAtk2)
                UpdateBasic2(gameTime);
            else if (isAtk3)
                UpdateBasic3(gameTime);
            if (isShieldSpin)
            {
                UpdateShieldSpin(gameTime);

            }
            if (isShieldBash)
            {
                UpdateShieldBash(gameTime);
            }
            if (isShieldUpper)
            {
                UpdateShieldUpper(gameTime);
            }
            if (isHurt)
            {
                hurtUpdate(gameTime);
            }

            //if ((runTime.Seconds > 1.0 && runTime.Seconds < 4.0) || (runTime.Seconds > 4.0 && runTime.Seconds < 8.0))
            //    thrustAmount = 1;
            //else
            //    thrustAmount = 0;
            //if (isAtk1 || isAtk2)
            //    thrustAmount = .5f;
           // Position -= Direction * thrustAmount * 5.0f;



            if (isJump)
            {
                upperBones.CopyTo(justBones, 0);

            }
            if (strafeLeft)
                Position += world.Left * 2.0f;
            if (strafeRight)
                Position += world.Right * 2.0f;
            if (isHurt)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldToss)
                upperBones.CopyTo(justBones, 0);
            else if (isBow)
                upperBones.CopyTo(justBones, 0);
            else if (isShield)
                upperBones.CopyTo(justBones, 0);
            else if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldSpin)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldBash)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1 || isAtk2 || isAtk3)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);

            //world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);



            if (isKnockBack)
                Position = oldPosition + knockBackVec * 5.0f;

            world = Matrix.Identity;
            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Up;
            world.Right = Right;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            // world.Right.Normalize();
            world.Translation = Position;
            world.Translation += new Vector3(0.0f, jumpHt, 0.0f);

            //world.Left.Normalize();
            // world.Down.Normalize();
            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            ray = new Ray(new Vector3(Position.X, 90.0f, Position.Z), new Vector3(-Direction.X, 0.0f, -Direction.Z));//Direction);
            lRay = new Ray(new Vector3(Position.X, 90.0f, Position.Z), Vector3.Transform(new Vector3(-Direction.X, 0.0f, -Direction.Z), Matrix.CreateFromAxisAngle(Vector3.Up, -0.1f)));
            rRay = new Ray(new Vector3(Position.X, 90.0f, Position.Z), Vector3.Transform(new Vector3(-Direction.X, 0.0f, -Direction.Z), Matrix.CreateFromAxisAngle(Vector3.Up, 0.1f)));

            //  if (resetFormations)
            {
                //    resetFormations = false;

                formation = world;
            }
            // position = new Vector3(-100.0f, 0.0f, 0.0f);


            if (currentKeyBoardState.IsKeyDown(Keys.A))// && oldkeyBoardState.IsKeyUp(Keys.A))
                ScreenManager.camera.dY -= 10;
            if (currentKeyBoardState.IsKeyDown(Keys.Q))// && oldkeyBoardState.IsKeyUp(Keys.Q))
                ScreenManager.camera.dY += 10;
            if (currentKeyBoardState.IsKeyDown(Keys.W))// && oldkeyBoardState.IsKeyUp(Keys.W))
                ScreenManager.camera.dZ += 10;
            if (currentKeyBoardState.IsKeyDown(Keys.S))// && oldkeyBoardState.IsKeyUp(Keys.S))
                ScreenManager.camera.dZ -= 10;
            if (currentKeyBoardState.IsKeyDown(Keys.E))// && oldkeyBoardState.IsKeyUp(Keys.E))
                ScreenManager.camera.lY += 10;
            if (currentKeyBoardState.IsKeyDown(Keys.D))// && oldkeyBoardState.IsKeyUp(Keys.D))
                ScreenManager.camera.lY -= 10;
            if (currentKeyBoardState.IsKeyDown(Keys.R))// && oldkeyBoardState.IsKeyUp(Keys.R))
                ScreenManager.camera.lZ += 10;
            if (currentKeyBoardState.IsKeyDown(Keys.F))// && oldkeyBoardState.IsKeyUp(Keys.F))
                ScreenManager.camera.lZ -= 10;
            if (currentKeyBoardState.IsKeyDown(Keys.T))
                ScreenManager.camera.fovDiv += 1;
            if (currentKeyBoardState.IsKeyDown(Keys.G))
                ScreenManager.camera.fovDiv -= 1f;


            //if(currentKeyBoardState.IsKeyDown(Keys.U))


        }
        public Vector3 DirFromFloat(float flo)
        {
          float x =  (float)Math.Sin(flo);
          float y = (float)Math.Cos(flo);

          return new Vector3(x, 0, y);

        }
        public Vector3 DirFromDouble(double doub)
        {
            const float radius = 30;
            const float height = 40;

            double angle = doub * Math.PI * 2;

            float x = (float)Math.Sin(angle);
            float y = (float)Math.Cos(angle);
            
            return new Vector3(x , 0, y );


           
        }
        public string currentRune()
        {
            return ScreenManager.runes[slot];
        }

        public void UpdateNihon(GameTime gameTime)
        {
            Ray cursorRay;
            //ScreenManager.gd.
            //float rotationAmount = 0.0f;
            oldPosition = Position;
            oldDirection = Direction;
            oldkeyBoardState = currentKeyBoardState;
            currentKeyBoardState = Keyboard.GetState();
            oldMouse = mouse;
            mouse = Mouse.GetState();
            TargetCursor.X = mouse.X;
            TargetCursor.Y = mouse.Y;

            for (int i = 0; i < projectiles.Count; i++)
            {
                projectiles[i].update2(gameTime);
                if (!projectiles[i].alive)
                    projectiles.RemoveAt(i);

            }

            float? dist;

            if (gameTime.TotalGameTime - playerMoveTime > MoveTimeOut)
            {

                playerMouseMove = null;
              //  ScreenManager.mouseInputManager.Input.Clear();
                //ScreenManager.mouseInputManager.LastInputTime = TimeSpan.Zero;
                lockTarget = false;
                lockTarget2 = false;
                lockTarget3 = false;
            }

            MoveMouse newMove = ScreenManager.mouseMoveList.DetectMove(ScreenManager.mouseInputManager);

            if (newMove != null)
            {
                playerMouseMove = newMove;
                playerMoveTime = gameTime.TotalGameTime;

                //if(mouse.RightButton == ButtonState.Pressed && oldMouse.RightButton == ButtonState.bow3d)
                #region RC
                if (playerMouseMove.Name == "RC")
                {

                    if (!lockTarget)
                    {
                        Vector3 nearSource = new Vector3(ScreenManager.Theseus.TargetCursor, 0f);
                        Vector3 farSource = new Vector3(ScreenManager.Theseus.TargetCursor, 1f);
                        Vector3 nearPoint = ScreenManager.gd.Viewport.Unproject(nearSource,
           ScreenManager.camera.Projection, ScreenManager.camera.View, Matrix.Identity);

                        Vector3 farPoint = ScreenManager.gd.Viewport.Unproject(farSource,
                            ScreenManager.camera.Projection, ScreenManager.camera.View, Matrix.Identity);
                        Vector3 direction = farPoint - nearPoint;
                        direction.Normalize();
                        cursorRay = new Ray(nearPoint, direction);
                        hitTags.Clear();
                        hitDist.Clear();

                        foreach (JuneXnaModel june in ScreenManager.dummies)
                        {
                            foreach (boundingSphere bs in spheres)
                            {
                                dist = cursorRay.Intersects(bs.BS);
                                if (dist != null)
                                {
                                    hitTags.Add(june.fighterIndex);
                                    hitDist.Add(dist.Value);
                                    lockTarget = true;
                                    break;
                                }

                            }
                        }

                        if (!lockTarget)//break the playerTime thing and this playerMove but go to the spot that was last clicked
                        {

                            playerMoveTime = TimeSpan.Zero;
                            TargetTrans = ScreenManager.Theseus.TargetCursor3.Value;
                            pstate = 1;
                            pRotationAmount = TurnToFace(position, TargetTrans, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                            ScreenManager.mouseInputManager.ZeroOutLastInputTime();
                        }

                        else if (lockTarget)
                        {
                            if (hitTags.Count > 0)
                            {
                                for (int i = 0; i < hitTags.Count; i++)
                                {
                                    if (hitDist[i] < hitDist[0])
                                    {
                                        hitTags[0] = hitTags[i];
                                        hitDist[0] = hitDist[i];
                                    }
                                    pstate = 3;
                                    pRotationAmount = TurnToFace(position, ScreenManager.dummies[hitTags[0]].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                                    currentAnimationTime = TimeSpan.Zero;
                                    justBones.CopyTo(previousAnimation, 0);

                                }
                            }
                        }
                        //else if (hitTags.Count == 1)
                        //{

                        //    //do nothing

                        //    //TargetTrans = ScreenManager.Theseus.TargetCursor3.Value;
                        //    pstate = 3;
                        //    pRotationAmount = TurnToFace(position, ScreenManager.dummies[hitTags[0]].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));


                        //}
                        //else
                        //{

                        //    TargetTrans = ScreenManager.Theseus.TargetCursor3.Value;
                        //    pstate = 1;
                        //    pRotationAmount = TurnToFace(position, TargetTrans, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                        //}


                    }
                }
                #endregion

                //CAN ONLY GET HERE IF YOU DOUBLECLICK ON A PERSON
                if (playerMouseMove.Name == "LC,LC")
                {

                  //  Console.WriteLine("LCLC");
                    if (!lockTarget2)
                    {
                        Vector3 nearSource = new Vector3(ScreenManager.Theseus.TargetCursor, 0f);
                        Vector3 farSource = new Vector3(ScreenManager.Theseus.TargetCursor, 1f);
                        Vector3 nearPoint = ScreenManager.gd.Viewport.Unproject(nearSource,
           ScreenManager.camera.Projection, ScreenManager.camera.View, Matrix.Identity);

                        Vector3 farPoint = ScreenManager.gd.Viewport.Unproject(farSource,
                            ScreenManager.camera.Projection, ScreenManager.camera.View, Matrix.Identity);
                        Vector3 direction = farPoint - nearPoint;
                        direction.Normalize();
                        cursorRay = new Ray(nearPoint, direction);


                        hitTags.Clear();
                        hitDist.Clear();

                        foreach (JuneXnaModel june in ScreenManager.dummies)
                        {
                            foreach (boundingSphere bs in june.spheres)
                            {
                                dist = cursorRay.Intersects(bs.BS);
                                if (dist != null)
                                {
                                    hitTags.Add(june.fighterIndex);
                                    hitDist.Add(dist.Value);
                                    lockTarget2 = true;
                                    break;
                                }

                            }
                        }
                        if (!lockTarget2)//break the playerTime thing and this playerMove but go to the spot that was last clicked
                        {

                            playerMoveTime = TimeSpan.Zero;
                            TargetTrans = ScreenManager.Theseus.TargetCursor3.Value;
                            pstate = 1;
                            pRotationAmount = TurnToFace(position, TargetTrans, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                            ScreenManager.mouseInputManager.ZeroOutLastInputTime();
                        }
                        else if (lockTarget2)
                        {
                            if (hitTags.Count > 0)
                            {
                                for (int i = 0; i < hitTags.Count; i++)
                                {
                                    if (hitDist[i] < hitDist[0])
                                    {
                                        hitTags[0] = hitTags[i];
                                        hitDist[0] = hitDist[i];
                                    }
                                    pstate = 2;
                                    isHoldAtk2 =true;
                                    TargetTrans = ScreenManager.dummies[hitTags[0]].Position;
                                    pRotationAmount = TurnToFace(position, ScreenManager.dummies[hitTags[0]].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                                   // currentAnimationTime = TimeSpan.Zero;
                                   // justBones.CopyTo(previousAnimation, 0);

                                }
                            }
                        }

                    }

                }
                #region LC
                if (playerMouseMove.Name == "LC")
                {
                   // pstate = 0;

                    //if (ScreenManager.Theseus.TargetCursor3 != null)
                    //{
                    //    foreach (boundingSphere bs in ScreenManager.rogue.spheres)
                    //        if (cursorRay.Intersects(bs.BS) != null)
                    //        {
                    //            pstate = 2;
                    //            TargetTrans = ScreenManager.rogue.Position;
                    //            break;
                    //        }

                    //    if (pstate == 0)
                    //    {
                    //        TargetTrans = ScreenManager.Theseus.TargetCursor3.Value;
                    //        pstate = 1;
                    //        pRotationAmount = TurnToFace(position, TargetTrans, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                    //    }
                    //}
                    if (!lockTarget)
                    {
                        Vector3 nearSource = new Vector3(ScreenManager.Theseus.TargetCursor, 0f);
                        Vector3 farSource = new Vector3(ScreenManager.Theseus.TargetCursor, 1f);
                        Vector3 nearPoint = ScreenManager.gd.Viewport.Unproject(nearSource,
           ScreenManager.camera.Projection, ScreenManager.camera.View, Matrix.Identity);

                        Vector3 farPoint = ScreenManager.gd.Viewport.Unproject(farSource,
                            ScreenManager.camera.Projection, ScreenManager.camera.View, Matrix.Identity);
                        Vector3 direction = farPoint - nearPoint;
                        direction.Normalize();
                        cursorRay = new Ray(nearPoint, direction);


                        hitTags.Clear();
                        hitDist.Clear();

                        foreach (JuneXnaModel june in ScreenManager.dummies)
                        {
                            foreach (boundingSphere bs in june.spheres)
                            {
                                dist = cursorRay.Intersects(bs.BS);
                                if (dist != null)
                                {
                                    hitTags.Add(june.fighterIndex);
                                    hitDist.Add(dist.Value);
                                    lockTarget = true;
                                    break;
                                }

                            }
                        }
                        if (!lockTarget)//break the playerTime thing and this playerMove but go to the spot that was last clicked
                        {

                            playerMoveTime = TimeSpan.Zero;
                            TargetTrans = ScreenManager.Theseus.TargetCursor3.Value;
                            pstate = 1;
                            pRotationAmount = TurnToFace(position, TargetTrans, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                            ScreenManager.mouseInputManager.ZeroOutLastInputTime();
                        }
                        else if (lockTarget)
                        {
                            if (hitTags.Count > 0)
                            {
                                for (int i = 0; i < hitTags.Count; i++)
                                {
                                    if (hitDist[i] < hitDist[0])
                                    {
                                        hitTags[0] = hitTags[i];
                                        hitDist[0] = hitDist[i];
                                    }
                                    pstate = 2;
                                    TargetTrans = ScreenManager.dummies[hitTags[0]].Position;
                                    pRotationAmount = TurnToFace(position, ScreenManager.dummies[hitTags[0]].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
                               //     currentAnimationTime = TimeSpan.Zero;
                                  //  justBones.CopyTo(previousAnimation, 0);
                                    isHoldAtk1 = true;

                                }
                            }
                        }
                        //else if (hitTags.Count == 1)
                        //{

                        //    //do nothing

                        //    //TargetTrans = ScreenManager.Theseus.TargetCursor3.Value;
                        //    pstate = 2;
                        //    TargetTrans = ScreenManager.dummies[hitTags[0]].Position;
                        //    pRotationAmount = TurnToFace(position, ScreenManager.dummies[hitTags[0]].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));


                        //}
                        //else
                        //{

                        //    TargetTrans = ScreenManager.Theseus.TargetCursor3.Value;
                        //    pstate = 1;
                        //    pRotationAmount = TurnToFace(position, TargetTrans, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                        //}

                    }
                }
                #endregion
            }

            if (pstate == 0)
                thrustAmount = 0.0f;

            if (pstate == 1)
            {
                float dToM = Vector3.Distance(position, TargetTrans);
                if (dToM > 60)
                {
                    thrustAmount = 1.0f;
                    if (!isRun)
                    {
                        isRun = true;
                        justBones.CopyTo(previousAnimation, 0);

                    }
                }
                else
                {
                    pstate = 0;
                    isRun = false;
                    thrustAmount = 0.0f; 
                }

            }
            if (pstate == 2)
            {

                //float dToA = Vector3.Distance(position, ScreenManager.rogue.Position);
                //pRotationAmount = 0.0f;
                //pRotationAmount = TurnToFace(position, ScreenManager.rogue.Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                float dToA = Vector3.Distance(position, ScreenManager.dummies[hitTags[0]].Position);
                pRotationAmount = 0.0f;
                pRotationAmount = TurnToFace(position, ScreenManager.dummies[hitTags[0]].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                if (dToA > 60)
                {

                    thrustAmount = 1.0f;
                    if (!isRun)
                    {

                        isRun = true;
                        justBones.CopyTo(previousAnimation, 0);
                    }
                }
                else
                {
                    if (isHoldAtk1)
                    {
                        if (!isAtk1)
                        {
                            isRun = false;
                            fightClass = 0;
                            thrustAmount = 0.0f;
                            active = true;
                            isAtk1 = true;
                            currentAnimationTime = TimeSpan.Zero;
                            justBones.CopyTo(previousAnimation, 0);
                        }
                    }
                    else if (isHoldAtk2)
                    {
                        if (!isAtk2)
                        {

                            isRun = false;
                            fightClass = 0;
                            thrustAmount = 0.0f;
                            active = true;
                            isAtk2 = true;
                            currentAnimationTime = TimeSpan.Zero;
                            justBones.CopyTo(previousAnimation, 0);



                        }


                    }

                }
            }
            if (pstate == 3)
            {

                //float dToA = Vector3.Distance(position, ScreenManager.rogue.Position);
                //pRotationAmount = 0.0f;
                //pRotationAmount = TurnToFace(position, ScreenManager.rogue.Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));


                float dToA = Vector3.Distance(position, ScreenManager.dummies[hitTags[0]].Position);
                pRotationAmount = 0.0f;
                pRotationAmount = TurnToFace(position, ScreenManager.dummies[hitTags[0]].Position, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));

                if (dToA > 560)
                {

                    thrustAmount = 1.0f;
                    if (!isRun)
                    {

                        isRun = true;
                        justBones.CopyTo(previousAnimation, 0);
                    }
                }
                else
                {
                    if (!isBow && pstate == 3)
                    {
                        fightClass = 1;
                        thrustAmount = 0.0f;
                        active = true;
                        isBow = true;
                        currentAnimationTime = TimeSpan.Zero;
                        justBones.CopyTo(previousAnimation, 0);
                    }
                    thrustAmount = 0.0f;
                }
            }

            if (isRun)
                updateRun(gameTime);
            //currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)8);
            if (isJump)
                UpdateJump(gameTime);
            if (isShield)
                UpdateShield(gameTime);
            if (isKnockBack)
                UpdateKnockBack(gameTime);
            if (isShieldToss)
                UpdateShieldToss(gameTime);
            if (isBow)
                UpdatePBow(gameTime);
            if (isAtk1)
                UpdatePBasic1(gameTime);
            else if (isAtk2)
                UpdatePBasic2(gameTime);
            else if (isAtk3)
                UpdateBasic3(gameTime);
            if (isShieldSpin)
            {
                UpdateShieldSpin(gameTime);

            }
            if (isShieldBash)
            {
                UpdateShieldBash(gameTime);
            }
            if (isShieldUpper)
            {
                UpdateShieldUpper(gameTime);
            }
            if (isHurt)
            {
                hurtUpdate(gameTime);
            }
            float x = (float)Math.Sin(pRotationAmount);
            float y = (float)Math.Cos(pRotationAmount);
            Direction = new Vector3(x, 0.0f, y);
            Up = Vector3.Up;
            Up.Normalize();
            Direction.Normalize();
            Right = Vector3.Cross(Direction, Up);

            if (strafeLeft)
                Position += world.Left * 2.0f;
            if (strafeRight)
                Position += world.Right * 2.0f;
            if (isHurt)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldToss)
                upperBones.CopyTo(justBones, 0);
            else if (isBow)
                upperBones.CopyTo(justBones, 0);
            else if (isShield)
                upperBones.CopyTo(justBones, 0);
            else if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldSpin)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldBash)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1 || isAtk2 || isAtk3)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);

            if (thrustAmount > 0)
                Position += thrustAmount * Direction * 2.0f;

            world = Matrix.Identity;
            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Up;
            world.Right = Right;
            world.Forward = Direction  * new Vector3(-1, 0,-1);

            world.Translation = Position;

            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();




        }
        public void UpdateNinjaneer(GameTime gameTime)
        {
            Vector2 rotationAmount = currentGamePadState.ThumbSticks.Left;
            Vector2 rotAmt = currentGamePadState.ThumbSticks.Right;
            float rot = (float)Math.Atan(currentGamePadState.ThumbSticks.Left.X / currentGamePadState.ThumbSticks.Left.Y);
            float rot2 =(float)Math.Atan(currentGamePadState.ThumbSticks.Right.X / currentGamePadState.ThumbSticks.Right.Y);

            if (currentGamePadState.IsButtonDown(Buttons.RightThumbstickUp) && oldGamePadState.IsButtonUp(Buttons.RightThumbstickUp))
            {
                ScreenManager.camera.dFov += .1f;
            }
            if (currentGamePadState.IsButtonDown(Buttons.RightThumbstickDown) && oldGamePadState.IsButtonUp(Buttons.RightThumbstickDown))
            {
                ScreenManager.camera.dFov -= .1f;
            }

            oldGamePadState = currentGamePadState;
            oldkeyBoardState = currentKeyBoardState;
            World.Decompose(out scale, out rota, out trans);
            oldPosition = Position;
            oldDirection = Direction;
            currentGamePadState = GamePad.GetState(PlayerIndex.One, GamePadDeadZone.Circular);
            for (int i = 0; i < arrows.Count; i++)
            {
                arrows[i].update(gameTime);
                if (!arrows[i].alive)
                    arrows.RemoveAt(i);

            }
            if (gameTime.TotalGameTime - playerMoveTime > MoveTimeOut)
            {
                playerMove = null;
            }

            Move newMove = ScreenManager.moveList.DetectMove(ScreenManager.inputManager);


            if (newMove != null)
            {
                playerMove = newMove;

                playerMoveTime = gameTime.TotalGameTime;
                if (playerMove.Name == "Y")
                {
                    if (!isBow)
                    {
                        isBow = true;

                        currentAnimationTime = TimeSpan.Zero;
                        justBones.CopyTo(previousAnimation, 0);


                    }

                }
                if (playerMove.Name == "A")
                {
                    if (!isAtk1 & !isHoldAtk1)
                    {

                        active = true;
                        isAtk1 = true;
                        currentAnimationTime = TimeSpan.Zero;
                        justBones.CopyTo(previousAnimation, 0);
                        currentAtkTime = TimeSpan.FromSeconds(1.0);
                        atkSuccess = false;
                        hits.Clear();
                        atkSpheres.Clear();
                    }



                }
                if (playerMove.Name == "AA")
                {
                    //if (!isAtk1 && !isAtk2)

                    if (!isAtk2 & !isHoldAtk2)
                    {
                        isHoldAtk1 = false;
                        active = true;
                        isAtk2 = true;
                        //currentAnimationTime = TimeSpan.Zero;
                        //justBones.CopyTo(previousAnimation, 0);

                        if (!isAtk1)
                            currentAnimationTime = TimeSpan.Zero;
                        atkSuccess = false;
                        hits.Clear();
                        atkSpheres.Clear();

                    }


                }
            }

            thrustAmount = currentGamePadState.ThumbSticks.Left.Y;
            if (Math.Abs(rotationAmount.X) > .05f || Math.Abs(rotationAmount.Y) > .05f)
            {
                if (rotationAmount.Y < 0)
                    Direction = new Vector3(-(float)Math.Sin(rot), 0.0f, (float)Math.Cos(rot));
                else
                    Direction = new Vector3((float)Math.Sin(rot), 0.0f, -(float)Math.Cos(rot));
                  thrustAmount = 1;
                // else
                //  Direction = new Vector3((float)Math.Sin(rot), 0.0f, (float)Math.Cos(rot));
            }
            if (Math.Abs(rotAmt.X) > .05f || Math.Abs(rotAmt.Y) > .05f)
            {

                //if (rotationAmount.Y < 0)
                //    facing = new Vector3(-(float)Math.Sin(rot2), 0.0f, (float)Math.Cos(rot2));
                //else
                //    facing = new Vector3((float)Math.Sin(rot2), 0.0f, -(float)Math.Cos(rot2));
                if (rotAmt.X < 0)
                  facing=  Vector3.Transform(facing, Matrix.CreateRotationY(.1f));
                if (rotAmt.X > 0)
                facing =   Vector3.Transform(facing, Matrix.CreateRotationY(-.1f));
                



            }
            //Console.WriteLine(facing);
            if (active)
            {
                thrustAmount = 0;

            }
            if (channeling)
                thrustAmount = 0;
            if (Math.Abs(thrustAmount) > 0.0f)
            {
                isRun = true;
                justBones.CopyTo(previousAnimation, 0);
            }
            else
            {
                isRun = false;
                runTime = TimeSpan.Zero;
            }

            if (isRun)
                updateRun(gameTime);
            //currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)8);
            if (isJump)
                UpdateJump(gameTime);
            if (isShield)
                UpdateShield(gameTime);
            if (isKnockBack)
                UpdateKnockBack(gameTime);
            if (isShieldToss)
                UpdateShieldToss(gameTime);
            if (isBow)
                UpdateBow(gameTime);
            if (isHoldAtk1)
                UpdateHoldBasic1(gameTime);
            if (isHoldAtk2)
                UpdateHoldBasic2(gameTime);
            if (isHoldAtk3)
                UpdateHoldBasic3(gameTime);
            if (isAtk1)
                UpdateBasic1(gameTime);
            else if (isAtk2)
                UpdateBasic2(gameTime);
            else if (isAtk3)
                UpdateBasic3(gameTime);
            if (isShieldSpin)
            {
                UpdateShieldSpin(gameTime);

            }
            if (isShieldBash)
            {
                UpdateShieldBash(gameTime);
            }
            if (isShieldUpper)
            {
                UpdateShieldUpper(gameTime);
            }
            if (isHurt)
            {
                hurtUpdate(gameTime);
            }
            if (isAtk1 || isAtk2 || isAtk3)
            {
                // if (currentAtkTime.TotalMilliseconds < 500)
                //    thrustAmount = .5f;
                // else
                Direction = oldDirection;
            }
            Up = Vector3.Up;
            Up.Normalize();
            Direction.Normalize();
            facing.Normalize();
            Right = Vector3.Cross(facing, Up);
            
            if (isHurt)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldToss)
                upperBones.CopyTo(justBones, 0);
            else if (isBow)
                upperBones.CopyTo(justBones, 0);
            else if (isShield)
                upperBones.CopyTo(justBones, 0);
            else if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldSpin)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldBash)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1 || isAtk2 || isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isHoldAtk1)
                atk1d.CopyTo(justBones, 0);
            else if (isHoldAtk2)
                atk2d.CopyTo(justBones, 0);
            else if (isHoldAtk3)
                atk1d.CopyTo(justBones, 0);
            else
                standing.CopyTo(justBones, 0);
            world = Matrix.Identity;
            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Up;
            world.Right = Right;
            world.Forward = facing;
            Vector3 moveDirection;
            bool moveLeft = false;
            bool moveRight = false;
            bool moveForward = false;
            bool moveBackward = false;

            if (rotationAmount.X > .1)
            {
                moveRight = true;

            }
            if (rotationAmount.X < .1)
                moveLeft = true;
            if (rotationAmount.Y > .1)
                moveForward = true;
            if (rotationAmount.Y < .1)
                moveBackward = true;

            if (moveLeft)
            {
                if (moveForward)
                {
                    Direction = (world.Forward * Math.Abs(rotationAmount.Y) + world.Left * Math.Abs(rotationAmount.X)) / 2;
                }
                if (moveBackward)
                {
                    Direction = (world.Backward * Math.Abs(rotationAmount.Y) + world.Left * Math.Abs(rotationAmount.X)) / 2;

                }


            }
            else if (moveRight)
            {
                if (moveForward)
                {
                    Direction = (world.Forward * Math.Abs(rotationAmount.Y) + world.Right * Math.Abs(rotationAmount.X)) / 2;
                }
                if (moveBackward)
                {
                    Direction = (world.Backward * Math.Abs(rotationAmount.Y) + world.Right * Math.Abs(rotationAmount.X)) / 2;

                }


            }
            else
            {

                if (moveForward)
                {
                    Direction = world.Forward;
                }
                if (moveBackward)
                {
                    Direction = world.Backward;
                }

            }
            Position -=  Direction * thrustAmount * speed;
            world.Translation = Position;
            collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();
        }
        public void UpdatePerspectiveFollow(GameTime gameTime)
        {
            if (RingOfFire)
            {
                ROFTime -= gameTime.ElapsedGameTime;
                if (ROFTime < TimeSpan.Zero)
                    RingOfFire = false;

                fireRings.updateROF(gameTime, collisionS[1].BS.Center);

            }
            if (PowerGust)
            {
                PGTimer -= gameTime.ElapsedGameTime;
                if (PGTimer < TimeSpan.Zero)
                    PowerGust = false;
            }
            if (IcyField)
            {
                IFTimer -= gameTime.ElapsedGameTime;
                if (IFTimer < TimeSpan.Zero)
                    IcyField = false;
            }
            if (RockArmor)
            {
                RATimer -= gameTime.ElapsedGameTime;
                if (RATimer < TimeSpan.Zero)
                    RockArmor = false;
                rABonus = 5.0f;

            }
            else
                rABonus = 0.0f;
            if (BoilingBlood)
            {
                BBTimer -= gameTime.ElapsedGameTime;
                if (BBTimer < TimeSpan.Zero)
                    BoilingBlood = false;
                speed = 8;
            }
            else
                speed = 5;

            #region old

            if (!strafe)
                facing = Direction;
            if (!channeling)
                ChannelingDirection = Direction;



            float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds;

            mana1 += elapsed * mana1Recover;
            health += elapsed * healthRecover;
            stamina += elapsed * staminaRecover;
            // Console.WriteLine(mana1);
            if (mana1 > mana1Max)
                mana1 = mana1Max;
            if (health > healthMax)
                health = healthMax;
            if (stamina > stamMax)
                stamina = stamMax;

            if (!channeling)
                AreaEffectCenter = Position;//so that it isnt the same thing in turntoface
            if (TargetCursor3 != null)
                TargetSphere = new BoundingSphere(TargetCursor3.Value + new Vector3(0, 70.0f, 0.0f), 30.0f);
            oldGamePadState = currentGamePadState;
            oldkeyBoardState = currentKeyBoardState;
            World.Decompose(out scale, out rota, out trans);
            oldPosition = Position;
            oldDirection = Direction;
            currentGamePadState = GamePad.GetState(PlayerIndex.One, GamePadDeadZone.Circular);
            currentKeyBoardState = Keyboard.GetState();
            //foreach (Projectile2 pro in projectiles)
            //{
            //    pro.update2(gameTime);
            //    projectiles.Remove(pro);                  
            //}

            //   if(fightClass == 0)

            //  if(fightClass == 1)

            for (int i = 0; i < arrows.Count; i++)
            {
                arrows[i].update2(gameTime, skinTrans[ScreenManager.rHand]);
                if (!arrows[i].alive)
                    arrows.RemoveAt(i);

            }

            for (int i = 0; i < projectiles.Count; i++)
            {
                projectiles[i].update2(gameTime);
                if (!projectiles[i].alive)
                    projectiles.RemoveAt(i);

            }
            for (int i = 0; i < eruptions.Count; i++)
            {
                eruptions[i].updateEruption(gameTime);
                if (!eruptions[i].alive)
                    eruptions.RemoveAt(i);

            }




            //float rororo = TurnToFace(position, ScreenManager.Perseus.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
            //Console.WriteLine(rororo);


            Vector2 rotationAmount = currentGamePadState.ThumbSticks.Left;

            float rot = (float)Math.Atan(currentGamePadState.ThumbSticks.Left.X / currentGamePadState.ThumbSticks.Left.Y);
            float rotR = (float)Math.Atan(currentGamePadState.ThumbSticks.Right.X / currentGamePadState.ThumbSticks.Right.Y);
            // Console.WriteLine(rot);
            Vector2 inputAmount = currentGamePadState.ThumbSticks.Right;

            //rotAmt = TurnToFace(ScreenManager.asterion.Position, ScreenManager.medusa.Position, Vector3.Zero);
            // Direction = new Vector3((float)Math.Sin(rotAmt), 0.0f, (float)Math.Cos(rotAmt));

            if (gameTime.TotalGameTime - playerMoveTime > MoveTimeOut)
            {
                playerMove = null;
            }
            //inputManager.Update(gameTime);
            Move newMove = ScreenManager.moveList.DetectMove(ScreenManager.inputManager);


            if (newMove != null)
            {
                playerMove = newMove;

                playerMoveTime = gameTime.TotalGameTime;

                //if (playerMove.Name == "LT+RT")
                //{

                //  //  Projected = 
                //    TargetCursor = new Vector2(Projected.X, Projected.Y);


                //}
                if (playerMove.Name == "B")
                {
                    if (spellList) //Defense
                    {
                        if (currentRune() == "Fire 1")
                        {
                            RingOfFire = true;
                            ROFTime = new TimeSpan(0, 0, 5);
                            fireRings = new horizontalRing(3, world, 70);
                        }
                        if (currentRune() == "Earth 1")
                        {
                            rockOrbit = true;
                            ROTime = new TimeSpan(0, 0, 5);
                        }


                        if (currentRune() == "Water 1")
                        {
                            IcyField = true;
                            IFTimer = new TimeSpan(0, 0, 5);
                            IFSphere = new BoundingSphere(bodySphere.Center, 80.0f);
                        }

                        if (currentRune() == "Wind 1")
                        {
                            EnvelopingWinds = true;
                            EWTime = new TimeSpan(0, 0, 5);
                            EWSphere = new BoundingSphere(bodySphere.Center, 80.0f);


                        }

                    }

                }
                if (playerMove.Name == "Y")
                {
                    if (spellList) //Support
                    {
                        if (currentRune() == "Fire 1")
                        {
                            BoilingBlood = true;
                            BBTimer = new TimeSpan(0, 0, 5);
                        }
                        if (currentRune() == "Earth 1")
                        {
                            RockArmor = true;
                            RATimer = new TimeSpan(0, 0, 5);
                        }
                        if (currentRune() == "Water 1")
                        {
                            Heal = true;
                            HTime = new TimeSpan(0, 0, 5);

                        }
                        if (currentRune() == "Wind 1")
                        {
                            //powergust with a weapon adds charge
                            PowerGust = true;
                            PGTimer = new TimeSpan(0, 0, 5);

                        }
                    }
                    else
                    {
                        if (!isBow)
                        {
                            isBow = true;

                            currentAnimationTime = TimeSpan.Zero;
                            justBones.CopyTo(previousAnimation, 0);


                        }


                        //if(fightClass == 0)
                        //if (!isShieldToss)
                        //{
                        //    isShieldToss = true;

                        //    currentAnimationTime = TimeSpan.Zero;
                        //    justBones.CopyTo(previousAnimation, 0);


                        //}
                        // if (fightClass == 1)
                    }

                }

                if (playerMove.Name == "RS")
                {



                    //if (!spell)
                    //{
                    //    spell = true;

                    //    AreaEffectCenter = Position;

                    //}
                    //else
                    //{
                    //    spell = false;

                    //}
                    //    if (mana1 > 60)
                    // {
                    ////     mana1 -= 60;
                    //     projectiles.Add(new Projectile2("Fire", forwardSpell, facing));
                    // }
                }
                if (playerMove.Name == "LT")
                {
                    ///Construct



                    //Physical Tower, Elemental Tower, Tower of Warding, Rinna-Al, Shura-Mo, 

                    //if (!channeling)
                    //    channeling = true;
                    //else
                    //    channeling = false;
                    //double ran1 = ScreenManager.rand.NextDouble();
                    //double ran2 = ScreenManager.rand.NextDouble();
                    //double ran3 = ScreenManager.rand.NextDouble();
                    //double ran4 = ScreenManager.rand.NextDouble();
                    //int rise1 = 50 + ScreenManager.rand.Next(80);
                    //int rise2 = 50 + ScreenManager.rand.Next(80);
                    //int rise3 = 50 + ScreenManager.rand.Next(80);
                    //int rise4 = 50 + ScreenManager.rand.Next(80);
                    //eruptions.Add(new Projectile2("Eruption", World, DirFromDouble(ran1), DirFromDouble(ran2), DirFromDouble(ran3),
                    //    DirFromDouble(ran4), rise1, rise2, rise3, rise4));
                    //testingIndex++;
                    //if (testingIndex > 2)
                    //    testingIndex = 0;

                }
                if (playerMove.Name == "RT")
                {
                    ///RT SWITCHES THE TARGET
                    //ScreenManager.Theseus.Position = new Vector3(1349.0f, 0.0f, 2770.0f);//13.49 -27.692
                    findNextTarget();

                    fightClass++;
                    if (fightClass == 2)
                        fightClass = 0;
                }
                if (playerMove.Name == "LS")
                {
                    //    if (strafe)
                    //        strafe = false;
                    //    else
                    //    {
                    //        strafe = true;

                    //    }
                    //    //strafeLeft = true;
                    //    projectiles.Add(new Projectile2("FireBlast", World, facing));
                }



                if (playerMove.Name == "A")
                {
                    if (spellList) //offense
                    {
                        if (currentRune() == "Fire 1")
                        {
                            fireBall1 = true;
                            projectiles.Add(new Projectile2("Fire", forwardSpell, facing));
                        }
                        if (currentRune() == "Earth 1")
                        {
                            avalanche1 = true;
                            projectiles.Add(new Projectile2("Earth", forwardSpell, facing));
                        }
                        if (currentRune() == "Water 1")
                        {
                            waterBlast = true;
                            projectiles.Add(new Projectile2("Water", forwardSpell, facing));
                        }
                        if (currentRune() == "Wind 1")
                        {
                            slicingWinds = true;
                            projectiles.Add(new Projectile2("Wind", forwardSpell, facing));
                        }


                    }

                    else
                    {
                        if (!isAtk1 & !isHoldAtk1)
                        {

                            active = true;
                            isAtk1 = true;
                            currentAnimationTime = TimeSpan.Zero;
                            justBones.CopyTo(previousAnimation, 0);
                            currentAtkTime = TimeSpan.FromSeconds(1.0);
                            atkSuccess = false;
                            hits.Clear();
                            atkSpheres.Clear();
                        }

                    }



                }
                if (playerMove.Name == "AA")
                {
                    //if (!isAtk1 && !isAtk2)

                    if (!isAtk2 & !isHoldAtk2)
                    {
                        isHoldAtk1 = false;
                        active = true;
                        isAtk2 = true;
                        //currentAnimationTime = TimeSpan.Zero;
                        //justBones.CopyTo(previousAnimation, 0);

                        if (!isAtk1)
                            currentAnimationTime = TimeSpan.Zero;
                        atkSuccess = false;
                        hits.Clear();
                        atkSpheres.Clear();

                    }


                }
                if (playerMove.Name == "AAA")
                {
                    if (!isAtk3)
                    {
                        active = true;
                        isAtk3 = true;
                        if (!isAtk2)
                            currentAnimationTime = TimeSpan.Zero;
                        atkSuccess = false;
                        hits.Clear();
                        atkSpheres.Clear();
                    }

                }

                if (playerMove.Name == "X") //defense
                {
                    if (spellList)
                    {

                        if (currentRune() == "Fire 1")
                        {
                            //fireBall1 = true;
                            constructs.Add(new Construct(100, 0, 0, 0, forwardSpell.Translation));

                        }
                        if (currentRune() == "Earth 1")
                        {
                            constructs.Add(new Construct(0, 100, 0, 0, forwardSpell.Translation));
                        }
                        if (currentRune() == "Water 1")
                        {

                            constructs.Add(new Construct(0, 0, 0, 100, forwardSpell.Translation));
                        }
                        if (currentRune() == "Wind 1")
                        {
                            constructs.Add(new Construct(0, 0, 100, 0, forwardSpell.Translation));
                        }
                    }
                    //if (!isShieldSpin)
                    //{
                    //    isShieldSpin = true;
                    //    currentAnimationTime = TimeSpan.Zero;
                    //}
                    //justBones.CopyTo(previousAnimation, 0);




                }
                // Console.WriteLine(playerMove.Name);

            }
            #endregion

            if (currentGamePadState.IsButtonDown(Buttons.LeftTrigger) && currentGamePadState.IsButtonDown(Buttons.RightTrigger) && currentGamePadState.IsButtonDown(Buttons.LeftShoulder) && currentGamePadState.IsButtonDown(Buttons.RightShoulder))
                ScreenManager.stage1 = true;
            if (currentGamePadState.IsButtonDown(Buttons.LeftTrigger) && currentGamePadState.IsButtonDown(Buttons.RightTrigger))
                TargetCursor = new Vector2(Projected.X, Projected.Y);

            if (currentGamePadState.IsButtonDown(Buttons.RightTrigger))
            {
                arrowTime += gameTime.ElapsedGameTime.TotalMilliseconds;
                if (arrowTime > arrowTimer)
                {
                    arrows.Add(new Arrow(arrowWorld, direction, arrow));
                    arrowTime -= arrowTimer;
                }


            }
            //if (currentGamePadState.IsButtonDown(Buttons.X))
            //{
            //    absorbAffinity = true;
            //}
            //else
            //    absorbAffinity = false;

            if (modTower)
            {
                if (currentGamePadState.IsButtonDown(Buttons.X) && oldGamePadState.IsButtonDown(Buttons.X))
                {
                    if (leftSide)
                        leftSide = false;
                    else if (!leftSide)
                    {
                        if (ScreenManager.targetedTowers.Count > 0)
                            if (ScreenManager.Theseus.runes[rSelection].count > 0)
                            {
                                ScreenManager.Towers[ScreenManager.targetedTowers[0]].runes[lSelection].name =
                                    ScreenManager.Theseus.runes[rSelection].name;
                                ScreenManager.Theseus.runes[rSelection].count--;
                            }
                        modTower = false;
                        leftSide = true;
                    }

                }
                if (currentGamePadState.IsButtonDown(Buttons.A) && oldGamePadState.IsButtonDown(Buttons.A))
                {
                    modTower = false;

                }
                if (currentGamePadState.IsButtonDown(Buttons.LeftThumbstickLeft) && oldGamePadState.IsButtonUp(Buttons.LeftThumbstickLeft))
                {
                    //if (leftSide)
                    //    leftSide = false;
                    //else
                    //    leftSide = true;
                }

                if (currentGamePadState.IsButtonDown(Buttons.LeftThumbstickRight) && oldGamePadState.IsButtonUp(Buttons.LeftThumbstickRight))
                {
                    //if (leftSide)
                    //    leftSide = false;
                    //else
                    //    leftSide = true;
                }

                if (currentGamePadState.IsButtonDown(Buttons.LeftThumbstickDown) && oldGamePadState.IsButtonUp(Buttons.LeftThumbstickDown))
                {
                    if (leftSide)
                    {
                        lSelection++;

                    }
                    if (!leftSide)
                    {
                        rSelection++;

                    }
                }

                if (currentGamePadState.IsButtonDown(Buttons.LeftThumbstickUp) && oldGamePadState.IsButtonUp(Buttons.LeftThumbstickUp))
                {
                    if (leftSide)
                    {
                        lSelection--;

                    }
                    if (!leftSide)
                    {
                        rSelection--;

                    }
                }
                if (ScreenManager.targetedTowers.Count > 0)
                {
                    if (lSelection < 0)
                        lSelection = ScreenManager.Towers[ScreenManager.targetedTowers[0]].runes.Count - 1;
                    if (lSelection > ScreenManager.Towers[ScreenManager.targetedTowers[0]].runes.Count - 1)
                        lSelection = 0;
                }
                if (rSelection < 0)
                    rSelection = ScreenManager.Theseus.runes.Count - 1;
                if (rSelection > ScreenManager.Theseus.runes.Count - 1)
                    rSelection = 0;

            }
            if (currentGamePadState.IsButtonDown(Buttons.X) && oldGamePadState.IsButtonDown(Buttons.X))
            {
                if (towerSelected)
                    modTower = true;

            }
            if (currentGamePadState.IsButtonDown(Buttons.LeftTrigger))
                construction = true;
            else
            {
                construction = false;
                buildTower = false;
                physicalTower = false;
                buildWall = false;
                buildPhase1 = false;
                buildPhase2 = false;
            }


            if (currentGamePadState.IsButtonDown(Buttons.RightShoulder))
                spellList = true;
            else
            {
                spellList = false;


            }
            #region build

            if (physicalTower && currentGamePadState.IsButtonDown(Buttons.A) && oldGamePadState.IsButtonUp(Buttons.A))
            {
                ScreenManager.Towers.Add(new Tower(tower.BS.Center));
                int x = (int)tower.BS.Center.X / 60;
                int y = (int)tower.BS.Center.Z / 60;

                ScreenManager.mainOpen[x][y] = false;
                //tower.translation = towerCenter = tower.BS.Center = position;
                physicalTower = false;

            }
            if (healCon && currentGamePadState.IsButtonDown(Buttons.Y))
            {
                healing = true;
            }
            else
                healing = false;
            if (healCon && currentGamePadState.IsButtonDown(Buttons.A))
            {
                healCon = false;
            }

            if (buildTower && currentGamePadState.IsButtonDown(Buttons.X) && oldGamePadState.IsButtonUp(Buttons.X))
            {
                healCon = true;
                buildTower = false;
                TargetCursor = new Vector2(Projected.X, Projected.Y);

            }
            if (buildTower && currentGamePadState.IsButtonDown(Buttons.Y) && oldGamePadState.IsButtonUp(Buttons.Y))
            {
                physicalTower = true;
                TargetCursor = new Vector2(Projected.X, Projected.Y);
                tower.translation = buildCenter1 = tower.BS.Center = position;

            }
            if (buildPhase2 && currentGamePadState.IsButtonDown(Buttons.B) && oldGamePadState.IsButtonUp(Buttons.B))
            {
                if (Vector3.Distance(buildCenter1, buildCenter2) < 40.0f)
                    buildCenter2 = new Vector3(buildCenter1.X + 40.0f, buildCenter1.Y, buildCenter1.Z);
                wall = new Wall(buildCenter1, buildCenter2);

            }

            if (buildPhase1 && currentGamePadState.IsButtonDown(Buttons.B) && oldGamePadState.IsButtonUp(Buttons.B))
            {
                buildPhase2 = true;
                // buildSphere1 = new BoundingSphere(buildCenter1, 20.0f);
                // buildSphere2 = new BoundingSphere(buildCenter1 + new Vector3(40.0f, 0.0f, 0.0f), 20.0f);
                // wall = new Wall(buildCenter1, buildCenter2);
            }
            if (buildWall && currentGamePadState.IsButtonDown(Buttons.B) && oldGamePadState.IsButtonUp(Buttons.B))
            {
                buildPhase1 = true;
                buildSphere1 = new BoundingSphere(buildCenter1, 20.0f);

                buildSphere2 = new BoundingSphere(buildCenter1 + new Vector3(40.0f, 0.0f, 0.0f), 20.0f);
                wall = new Wall(buildCenter1, buildCenter2);
            }
            if (construction && currentGamePadState.IsButtonDown(Buttons.B) && oldGamePadState.IsButtonUp(Buttons.B))
            {
                if (!buildWall)
                {
                    buildWall = true;
                    buildCenter1 = position;
                    buildCenter2 = position;
                    buildSphere1 = new BoundingSphere(buildCenter1, 20.0f);

                    buildSphere2 = new BoundingSphere(buildCenter1 + new Vector3(40.0f, 0.0f, 0.0f), 20.0f);
                    wall = new Wall(buildCenter1, buildCenter2);
                }
            }
            if (construction && currentGamePadState.IsButtonDown(Buttons.Y) && oldGamePadState.IsButtonUp(Buttons.Y))
                buildTower = true;
            #endregion


            //if (currentGamePadState.IsButtonDown(Buttons.B))
            //    isShield = true;
            //else
            //    isShield = false;
            if (currentGamePadState.IsButtonDown(Buttons.B))
            {
                if (!jumping & !falling)
                {
                    jumping = true;
                    currentJumpTime = 0;
                }
                else if (jumping)
                {
                    currentJumpTime += gameTime.ElapsedGameTime.TotalSeconds;
                    if (currentJumpTime > maxJumpTime)
                    {
                        falling = true;
                        jumping = false;
                    }
                }


            }
            else
            {
                falling = true;
                jumping = false;
            }
            if (spell)
                if (currentGamePadState.IsButtonDown(Buttons.Y))
                    charge1 += (float)(gameTime.ElapsedGameTime.TotalSeconds * charge1R);
            if (TargetCursor3 != null)
                TargetDirection = new Vector3(-1, 0, -1) * DirFromFloat(TurnToFace(position, TargetCursor3.Value, Direction));
            //TargetDirection *= new Vector3
            if (channeling)
            {

                ChannelingDirection = DirFromFloat(TurnToFace(position, AreaEffectCenter, ChannelingDirection));
                ChannelingDirection *= new Vector3(-1, 0, -1);
                //Direction = ChannelingDirection;


            }
            //if (currentGamePadState.IsButtonDown(Buttons.LeftShoulder))
            //    strafeRight = true;
            //else
            //    strafeRight = false;


            //if (currentGamePadState.IsButtonDown(Buttons.RightShoulder))
            //    strafeLeft = true;
            //else
            //    strafeLeft = false;


            if (isKnockedBack)
            {
                if (!isKnockBack)
                {
                    isKnockBack = true;
                    currentAnimationTime = TimeSpan.Zero;
                    justBones.CopyTo(previousAnimation, 0);

                    isBow = false;
                    isAtk1 = false;
                    isAtk2 = false;
                    isShieldToss = false;
                }

            }



            //if (Math.Abs(rotationAmount.X) > .3f || Math.Abs(rotationAmount.Y) > .3f)
            {
                //Direction = new Vector3(rotationAmount.X, 0.0f, rotationAmount.Y);



                //if ((rotationAmount.X) > .3f)
                //{

                //    Direction = Vector3.Transform(Vector3.One, Matrix.CreateFromAxisAngle(Vector3.Up, rotationAmount.X));
                //}
                //if(Math.Abs(rotationAmount.X) > .3f)
                // Direction = Vector3.Transform(new Vector3(1, 0, 0), Matrix.CreateFromAxisAngle(Vector3.Up, rot));

                // if (Math.Abs(rotationAmount.X) <- .3f)
                // {

                // Direction = Vector3.Transform(Direction, Matrix.CreateFromYawPitchRoll(rotationAmount.X,rotationAmount.Y,0.0f ));
                //}

                //if ((rotationAmount.X) > .3f)
                //{
                //    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, -.01f));

                //}

                //if ((rotationAmount.X) < -.3f)
                //{
                //    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, .01f));

                //}


                //Console.WriteLine(rotationAmount);
                //Direction = new Vector3(rotationAmount.X, 0.0f, -rotationAmount.Y);
                //Direction = new Vector3((float)Math.Cos(rot), 0.0f,(float) Math.Sin(rot));

                //NSIII 
                //if (Math.Abs(rotationAmount.X) >= 0.3 || Math.Abs(rotationAmount.Y) >= 0.3)
                //    Direction = new Vector3(rotationAmount.X, 0.0f, -rotationAmount.Y);
                //else
                //    Direction = oldDirection;
                //if (Math.Abs(currentGamePadState.ThumbSticks.Left.X) > 0.3 || Math.Abs(currentGamePadState.ThumbSticks.Left.Y) > 0.3)
                //    thrustAmount = -1.0f;
                //else
                //    thrustAmount = 0.0f;
                thrustAmount = currentGamePadState.ThumbSticks.Left.Y;
                if (Math.Abs(rotationAmount.X) > .005f || Math.Abs(rotationAmount.Y) > .005f)
                {
                    if (rotationAmount.Y < 0)
                        Direction = new Vector3(-(float)Math.Sin(rot), 0.0f, (float)Math.Cos(rot));
                    else
                        Direction = new Vector3((float)Math.Sin(rot), 0.0f, -(float)Math.Cos(rot));
                    thrustAmount = 1;
                    // else
                    //  Direction = new Vector3((float)Math.Sin(rot), 0.0f, (float)Math.Cos(rot));
                }
                //else
                RThrust = currentGamePadState.ThumbSticks.Right.Y;
                // ScreenManager.desiredY += currentGamePadState.ThumbSticks.Left.Y;
                //ScreenManager.lookAtY += currentGamePadState.ThumbSticks.Right.Y;
                if (!modTower)
                    TargetCursor += new Vector2(1, -1) * currentGamePadState.ThumbSticks.Right * (float)gameTime.ElapsedGameTime.TotalSeconds * 500.0f;

                if (physicalTower)
                    if (Math.Abs(inputAmount.X) > .05f || Math.Abs(inputAmount.Y) > .05f)
                    {

                        //if(inputAmount.Y < 0)
                        RThrust = 1;
                        if (inputAmount.Y < 0)
                            towerDirection = new Vector3(-(float)Math.Sin(rotR), 0.0f, (float)Math.Cos(rotR));
                        else
                            towerDirection = new Vector3((float)Math.Sin(rotR), 0.0f, -(float)Math.Cos(rotR));


                    }
                if (buildWall)
                {
                    if (Math.Abs(inputAmount.X) > .05f || Math.Abs(inputAmount.Y) > .05f)
                    {

                        //if(inputAmount.Y < 0)
                        RThrust = 1;
                        if (inputAmount.Y < 0)
                            buildDirection = new Vector3(-(float)Math.Sin(rotR), 0.0f, (float)Math.Cos(rotR));
                        else
                            buildDirection = new Vector3((float)Math.Sin(rotR), 0.0f, -(float)Math.Cos(rotR));


                    }


                }
                //RThrust = currentGamePadState.ThumbSticks.Right.Y;
                //if (Math.Abs(inputAmount.X) > .05f || Math.Abs(inputAmount.Y) > .05f)
                //{

                //    //if(inputAmount.Y < 0)
                //    RThrust = 1;
                //    if (inputAmount.Y < 0)
                //        AreaEffectDirection = new Vector3(-(float)Math.Sin(rotR), 0.0f, (float)Math.Cos(rotR));
                //    else
                //        AreaEffectDirection = new Vector3((float)Math.Sin(rotR), 0.0f, -(float)Math.Cos(rotR));


                //}
                if (thrustAmount > 1)
                    thrustAmount = 1.0f;
                if (thrustAmount < -1)
                    thrustAmount = -1.0f;
                if (active)
                {
                    thrustAmount = 0;

                }
                if (channeling)
                    thrustAmount = 0;

                if (Math.Abs(thrustAmount) > 0.0f)
                {
                    isRun = true;
                    justBones.CopyTo(previousAnimation, 0);
                }
                else
                {
                    isRun = false;
                    runTime = TimeSpan.Zero;
                }

                //  else
                //  thrustAmount = rotationAmount.Y;
            }


            //else
            //    thrustAmount = 0.0f;

            // Up.Normalize();

            //     Direction = oldDirection;

            if (currentGamePadState.IsButtonDown(Buttons.RightThumbstickRight) && oldGamePadState.IsButtonUp(Buttons.RightThumbstickRight))
                slot++;

            if (currentGamePadState.IsButtonDown(Buttons.RightThumbstickLeft) && oldGamePadState.IsButtonUp(Buttons.RightThumbstickLeft))
                slot--;

            if (slot == -1)
                slot = 7;
            if (slot == 8)
                slot = 0;



            // Right = Vector3.Cross(Direction, Up);
            if (isRun)
                updateRun(gameTime);
            //currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)8);
            if (isJump)
                UpdateJump(gameTime);
            if (isShield)
                UpdateShield(gameTime);
            if (isKnockBack)
                UpdateKnockBack(gameTime);
            if (isShieldToss)
                UpdateShieldToss(gameTime);
            if (isBow)
                UpdateBow(gameTime);
            if (isHoldAtk1)
                UpdateHoldBasic1(gameTime);
            if (isHoldAtk2)
                UpdateHoldBasic2(gameTime);
            if (isHoldAtk3)
                UpdateHoldBasic3(gameTime);
            if (isAtk1)
                UpdateBasic1(gameTime);
            else if (isAtk2)
                UpdateBasic2(gameTime);
            else if (isAtk3)
                UpdateBasic3(gameTime);
            if (isShieldSpin)
            {
                UpdateShieldSpin(gameTime);

            }
            if (isShieldBash)
            {
                UpdateShieldBash(gameTime);
            }
            if (isShieldUpper)
            {
                UpdateShieldUpper(gameTime);
            }
            if (isHurt)
            {
                hurtUpdate(gameTime);
            }

            //if ((runTime.Seconds > 1.0 && runTime.Seconds < 4.0) || (runTime.Seconds > 4.0 && runTime.Seconds < 8.0))
            //    thrustAmount = 1;
            //else
            //    thrustAmount = 0;
            if (isAtk1 || isAtk2 || isAtk3)
            {
                // if (currentAtkTime.TotalMilliseconds < 500)
                //    thrustAmount = .5f;
                // else
                Direction = oldDirection;
            }
            //if (isBow)
            //{
            //    Direction = TargetDirection;
            //}

            Up = Vector3.Up;
            Up.Normalize();
            Direction.Normalize();
            Right = Vector3.Cross(Direction, Up);

            if (strafe)
                Right = Vector3.Cross(facing, Up);

            if (channeling)
            {
                Right = Vector3.Cross(ChannelingDirection, Up);

            }

            Position -= Direction * thrustAmount * speed;
            if (jumping)
                Position += new Vector3(0.0f, (float)gameTime.ElapsedGameTime.TotalMilliseconds, 0.0f);
            if (falling)
                Position -= new Vector3(0.0f, (float)gameTime.ElapsedGameTime.TotalMilliseconds, 0.0f);
            if (Position.Y < 0)
            {
                falling = false;
                Position = new Vector3(Position.X, 0.0f, Position.Z);
            }
            AreaEffectCenter -= AreaEffectDirection * RThrust * 5.0f;


            if (physicalTower)
            {
                //tower.BS.Center = buildCenter1 -= towerDirection * RThrust * 5.0f;
                if (TargetCursor3.HasValue)
                {


                    tower.BS.Center = new Vector3((int)TargetCursor3.Value.X / 60 * 60 + 30, 70.0f, (int)TargetCursor3.Value.Z / 60 * 60 + 30);
                }
            }
            if (buildPhase1)
            {
                buildCenter2 -= buildDirection * RThrust * 5.0f;

                //buildSphere1 = new BoundingSphere(buildCenter1, 20.0f);
                buildSphere2 = new BoundingSphere(buildCenter2, 20.0f);
                wall = new Wall(buildSphere1.Center, buildSphere2.Center);
            }
            else if (buildWall)
            {
                buildCenter1 -= buildDirection * RThrust * 5.0f;
                buildCenter2 = buildCenter1 + new Vector3(40.0f, 0.0f, 0.0f);
                buildSphere1 = new BoundingSphere(buildCenter1, 20.0f);
                buildSphere2 = new BoundingSphere(buildCenter2, 20.0f);
                wall = new Wall(buildSphere1.Center, buildSphere2.Center);
            }

            areaSphere.BS = new BoundingSphere(AreaEffectCenter, 50.0f);

            if (isJump)
            {
                upperBones.CopyTo(justBones, 0);

            }
            if (strafeLeft)
                Position += world.Left * 2.0f;
            if (strafeRight)
                Position += world.Right * 2.0f;
            if (isHurt)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldToss)
                upperBones.CopyTo(justBones, 0);
            else if (isBow)
                upperBones.CopyTo(justBones, 0);
            else if (isShield)
                upperBones.CopyTo(justBones, 0);
            else if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldSpin)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldBash)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1 || isAtk2 || isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isHoldAtk1)
                atk1d.CopyTo(justBones, 0);
            else if (isHoldAtk2)
                atk2d.CopyTo(justBones, 0);
            else if (isHoldAtk3)
                atk1d.CopyTo(justBones, 0);
            else
                standing.CopyTo(justBones, 0);

            //world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);



            if (isKnockBack)
            {
                //    Console.WriteLine(kbTimer);
                Position = oldPosition + knockBackVec * 5.0f;
                Position = oldPosition + kbVec * 5.0f;
                kbTimer -= gameTime.ElapsedGameTime;
                if (kbTimer < TimeSpan.Zero)
                    isKnockBack = false;
            }


            projectileWorld = Matrix.Identity;
            projectileWorld.Up = Vector3.Up;
            //projectileWorld.Forward = TargetDirection;
            projectileWorld.Forward = Direction;
            projectileWorld.Right = Vector3.Cross(projectileWorld.Up, projectileWorld.Forward);
            projectileWorld.Translation = position;

            world = Matrix.Identity;
            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Up;
            world.Right = Right;
            world.Forward = Direction;
            if (strafe)
                world.Forward = facing;
            if (channeling)
                world.Forward = ChannelingDirection;
            // world.Right.Normalize();
            world.Translation = Position;
            world.Translation += new Vector3(0.0f, jumpHt, 0.0f);
            collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
            //world.Left.Normalize();
            // world.Down.Normalize();
            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            ray = new Ray(new Vector3(Position.X, 90.0f, Position.Z), new Vector3(-Direction.X, 0.0f, -Direction.Z));//Direction);
            lRay = new Ray(new Vector3(Position.X, 90.0f, Position.Z), Vector3.Transform(new Vector3(-Direction.X, 0.0f, -Direction.Z), Matrix.CreateFromAxisAngle(Vector3.Up, -0.1f)));
            rRay = new Ray(new Vector3(Position.X, 90.0f, Position.Z), Vector3.Transform(new Vector3(-Direction.X, 0.0f, -Direction.Z), Matrix.CreateFromAxisAngle(Vector3.Up, 0.1f)));

            //  if (resetFormations)
            {
                //    resetFormations = false;

                formation = world;
            }
            // position = new Vector3(-100.0f, 0.0f, 0.0f);


            if (currentKeyBoardState.IsKeyDown(Keys.A))// && oldkeyBoardState.IsKeyUp(Keys.A))
                ScreenManager.camera.dY -= 10;
            if (currentKeyBoardState.IsKeyDown(Keys.Q))// && oldkeyBoardState.IsKeyUp(Keys.Q))
                ScreenManager.camera.dY += 10;
            if (currentKeyBoardState.IsKeyDown(Keys.W))// && oldkeyBoardState.IsKeyUp(Keys.W))
                ScreenManager.camera.dZ += 10;
            if (currentKeyBoardState.IsKeyDown(Keys.S))// && oldkeyBoardState.IsKeyUp(Keys.S))
                ScreenManager.camera.dZ -= 10;
            if (currentKeyBoardState.IsKeyDown(Keys.E))// && oldkeyBoardState.IsKeyUp(Keys.E))
                ScreenManager.camera.lY += 10;
            if (currentKeyBoardState.IsKeyDown(Keys.D))// && oldkeyBoardState.IsKeyUp(Keys.D))
                ScreenManager.camera.lY -= 10;
            if (currentKeyBoardState.IsKeyDown(Keys.R))// && oldkeyBoardState.IsKeyUp(Keys.R))
                ScreenManager.camera.lZ += 10;
            if (currentKeyBoardState.IsKeyDown(Keys.F))// && oldkeyBoardState.IsKeyUp(Keys.F))
                ScreenManager.camera.lZ -= 10;
            if (currentKeyBoardState.IsKeyDown(Keys.T))
                ScreenManager.camera.fovDiv += 1;
            if (currentKeyBoardState.IsKeyDown(Keys.G))
                ScreenManager.camera.fovDiv -= 1f;
            if (currentKeyBoardState.IsKeyDown(Keys.Escape))
                ScreenManager.aGame.Exit();

            //if(currentKeyBoardState.IsKeyDown(Keys.U))


        }
        public void UpdatePlatform(GameTime gameTime)
        {
            if (RingOfFire)
            {
                ROFTime -= gameTime.ElapsedGameTime;
                if (ROFTime < TimeSpan.Zero)
                    RingOfFire = false;

                fireRings.updateROF(gameTime, collisionS[1].BS.Center);

            }
            if (PowerGust)
            {
                PGTimer -= gameTime.ElapsedGameTime;
                if (PGTimer < TimeSpan.Zero)
                    PowerGust = false;
            }
            if (IcyField)
            {
                IFTimer -= gameTime.ElapsedGameTime;
                if (IFTimer < TimeSpan.Zero)
                    IcyField = false;
            }
            if (RockArmor)
            {
                RATimer -= gameTime.ElapsedGameTime;
                if (RATimer < TimeSpan.Zero)
                    RockArmor = false;
                rABonus = 5.0f;

            }
            else
                rABonus = 0.0f;
            if (BoilingBlood)
            {
                BBTimer -= gameTime.ElapsedGameTime;
                if (BBTimer < TimeSpan.Zero)
                    BoilingBlood = false;
                speed = 8;
            }
            else
                speed = 5;

            #region old

            if (!strafe)
                facing = Direction;
            if (!channeling)
                ChannelingDirection = Direction;



            float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds;

            mana1 += elapsed * mana1Recover;
            health += elapsed * healthRecover;
            stamina += elapsed * staminaRecover;
            // Console.WriteLine(mana1);
            if (mana1 > mana1Max)
                mana1 = mana1Max;
            if (health > healthMax)
                health = healthMax;
            if (stamina > stamMax)
                stamina = stamMax;

            if (!channeling)
                AreaEffectCenter = Position;//so that it isnt the same thing in turntoface
            if (TargetCursor3 != null)
                TargetSphere = new BoundingSphere(TargetCursor3.Value + new Vector3(0, 70.0f, 0.0f), 30.0f);
            oldGamePadState = currentGamePadState;
            oldkeyBoardState = currentKeyBoardState;
            World.Decompose(out scale, out rota, out trans);
            oldPosition = Position;
            oldDirection = Direction;
            currentGamePadState = GamePad.GetState(PlayerIndex.One, GamePadDeadZone.Circular);
            currentKeyBoardState = Keyboard.GetState();
            //foreach (Projectile2 pro in projectiles)
            //{
            //    pro.update2(gameTime);
            //    projectiles.Remove(pro);                  
            //}

            //   if(fightClass == 0)

            //  if(fightClass == 1)

            for (int i = 0; i < arrows.Count; i++)
            {
                arrows[i].update2(gameTime, skinTrans[ScreenManager.rHand]);
                if (!arrows[i].alive)
                    arrows.RemoveAt(i);

            }

            for (int i = 0; i < projectiles.Count; i++)
            {
                projectiles[i].update2(gameTime);
                if (!projectiles[i].alive)
                    projectiles.RemoveAt(i);

            }
            for (int i = 0; i < eruptions.Count; i++)
            {
                eruptions[i].updateEruption(gameTime);
                if (!eruptions[i].alive)
                    eruptions.RemoveAt(i);

            }




            //float rororo = TurnToFace(position, ScreenManager.Perseus.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
            //Console.WriteLine(rororo);


            Vector2 rotationAmount = currentGamePadState.ThumbSticks.Left;

            float rot = (float)Math.Atan(currentGamePadState.ThumbSticks.Left.X / currentGamePadState.ThumbSticks.Left.Y);
            float rotR = (float)Math.Atan(currentGamePadState.ThumbSticks.Right.X / currentGamePadState.ThumbSticks.Right.Y);
            // Console.WriteLine(rot);
            Vector2 inputAmount = currentGamePadState.ThumbSticks.Right;

            //rotAmt = TurnToFace(ScreenManager.asterion.Position, ScreenManager.medusa.Position, Vector3.Zero);
            // Direction = new Vector3((float)Math.Sin(rotAmt), 0.0f, (float)Math.Cos(rotAmt));

            if (gameTime.TotalGameTime - playerMoveTime > MoveTimeOut)
            {
                playerMove = null;
            }
            //inputManager.Update(gameTime);
            Move newMove = ScreenManager.moveList.DetectMove(ScreenManager.inputManager);


            if (newMove != null)
            {
                playerMove = newMove;

                playerMoveTime = gameTime.TotalGameTime;

                //if (playerMove.Name == "LT+RT")
                //{

                //  //  Projected = 
                //    TargetCursor = new Vector2(Projected.X, Projected.Y);


                //}
                if (playerMove.Name == "B")
                {
                    if (spellList) //Defense
                    {
                        if (currentRune() == "Fire 1")
                        {
                            RingOfFire = true;
                            ROFTime = new TimeSpan(0, 0, 5);
                            fireRings = new horizontalRing(3, world, 70);
                        }
                        if (currentRune() == "Earth 1")
                        {
                            rockOrbit = true;
                            ROTime = new TimeSpan(0, 0, 5);
                        }


                        if (currentRune() == "Water 1")
                        {
                            IcyField = true;
                            IFTimer = new TimeSpan(0, 0, 5);
                            IFSphere = new BoundingSphere(bodySphere.Center, 80.0f);
                        }

                        if (currentRune() == "Wind 1")
                        {
                            EnvelopingWinds = true;
                            EWTime = new TimeSpan(0, 0, 5);
                            EWSphere = new BoundingSphere(bodySphere.Center, 80.0f);


                        }

                    }

                }
                if (playerMove.Name == "Y")
                {
                    if (spellList) //Support
                    {
                        if (currentRune() == "Fire 1")
                        {
                            BoilingBlood = true;
                            BBTimer = new TimeSpan(0, 0, 5);
                        }
                        if (currentRune() == "Earth 1")
                        {
                            RockArmor = true;
                            RATimer = new TimeSpan(0, 0, 5);
                        }
                        if (currentRune() == "Water 1")
                        {
                            Heal = true;
                            HTime = new TimeSpan(0, 0, 5);

                        }
                        if (currentRune() == "Wind 1")
                        {
                            //powergust with a weapon adds charge
                            PowerGust = true;
                            PGTimer = new TimeSpan(0, 0, 5);

                        }
                    }
                    else
                    {
                        if (!isBow)
                        {
                            isBow = true;

                            currentAnimationTime = TimeSpan.Zero;
                            justBones.CopyTo(previousAnimation, 0);


                        }


                        //if(fightClass == 0)
                        //if (!isShieldToss)
                        //{
                        //    isShieldToss = true;

                        //    currentAnimationTime = TimeSpan.Zero;
                        //    justBones.CopyTo(previousAnimation, 0);


                        //}
                        // if (fightClass == 1)
                    }

                }

                if (playerMove.Name == "RS")
                {



                    //if (!spell)
                    //{
                    //    spell = true;

                    //    AreaEffectCenter = Position;

                    //}
                    //else
                    //{
                    //    spell = false;

                    //}
                    //    if (mana1 > 60)
                    // {
                    ////     mana1 -= 60;
                    //     projectiles.Add(new Projectile2("Fire", forwardSpell, facing));
                    // }
                }
                if (playerMove.Name == "LT")
                {
                    ///Construct



                    //Physical Tower, Elemental Tower, Tower of Warding, Rinna-Al, Shura-Mo, 

                    //if (!channeling)
                    //    channeling = true;
                    //else
                    //    channeling = false;
                    //double ran1 = ScreenManager.rand.NextDouble();
                    //double ran2 = ScreenManager.rand.NextDouble();
                    //double ran3 = ScreenManager.rand.NextDouble();
                    //double ran4 = ScreenManager.rand.NextDouble();
                    //int rise1 = 50 + ScreenManager.rand.Next(80);
                    //int rise2 = 50 + ScreenManager.rand.Next(80);
                    //int rise3 = 50 + ScreenManager.rand.Next(80);
                    //int rise4 = 50 + ScreenManager.rand.Next(80);
                    //eruptions.Add(new Projectile2("Eruption", World, DirFromDouble(ran1), DirFromDouble(ran2), DirFromDouble(ran3),
                    //    DirFromDouble(ran4), rise1, rise2, rise3, rise4));
                    //testingIndex++;
                    //if (testingIndex > 2)
                    //    testingIndex = 0;

                }
                if (playerMove.Name == "RT")
                {
                    ///RT SWITCHES THE TARGET
                    //ScreenManager.Theseus.Position = new Vector3(1349.0f, 0.0f, 2770.0f);//13.49 -27.692
                    findNextTarget();

                    fightClass++;
                    if (fightClass == 2)
                        fightClass = 0;
                }
                if (playerMove.Name == "LS")
                {
                    //    if (strafe)
                    //        strafe = false;
                    //    else
                    //    {
                    //        strafe = true;

                    //    }
                    //    //strafeLeft = true;
                    //    projectiles.Add(new Projectile2("FireBlast", World, facing));
                }



                if (playerMove.Name == "A")
                {
                    if (spellList) //offense
                    {
                        if (currentRune() == "Fire 1")
                        {
                            fireBall1 = true;
                            projectiles.Add(new Projectile2("Fire", forwardSpell, facing));
                        }
                        if (currentRune() == "Earth 1")
                        {
                            avalanche1 = true;
                            projectiles.Add(new Projectile2("Earth", forwardSpell, facing));
                        }
                        if (currentRune() == "Water 1")
                        {
                            waterBlast = true;
                            projectiles.Add(new Projectile2("Water", forwardSpell, facing));
                        }
                        if (currentRune() == "Wind 1")
                        {
                            slicingWinds = true;
                            projectiles.Add(new Projectile2("Wind", forwardSpell, facing));
                        }


                    }

                    else
                    {
                        if (!isAtk1 & !isHoldAtk1)
                        {

                            active = true;
                            isAtk1 = true;
                            currentAnimationTime = TimeSpan.Zero;
                            justBones.CopyTo(previousAnimation, 0);
                            currentAtkTime = TimeSpan.FromSeconds(1.0);
                            atkSuccess = false;
                            hits.Clear();
                            atkSpheres.Clear();
                        }

                    }



                }
                if (playerMove.Name == "AA")
                {
                    //if (!isAtk1 && !isAtk2)

                    if (!isAtk2 & !isHoldAtk2)
                    {
                        isHoldAtk1 = false;
                        active = true;
                        isAtk2 = true;
                        //currentAnimationTime = TimeSpan.Zero;
                        //justBones.CopyTo(previousAnimation, 0);

                        if (!isAtk1)
                            currentAnimationTime = TimeSpan.Zero;
                        atkSuccess = false;
                        hits.Clear();
                        atkSpheres.Clear();

                    }


                }
                if (playerMove.Name == "AAA")
                {
                    if (!isAtk3)
                    {
                        active = true;
                        isAtk3 = true;
                        if (!isAtk2)
                            currentAnimationTime = TimeSpan.Zero;
                        atkSuccess = false;
                        hits.Clear();
                        atkSpheres.Clear();
                    }

                }

                if (playerMove.Name == "X") //defense
                {
                    if (spellList)
                    {

                        if (currentRune() == "Fire 1")
                        {
                            //fireBall1 = true;
                            constructs.Add(new Construct(100, 0, 0, 0, forwardSpell.Translation));

                        }
                        if (currentRune() == "Earth 1")
                        {
                            constructs.Add(new Construct(0, 100, 0, 0, forwardSpell.Translation));
                        }
                        if (currentRune() == "Water 1")
                        {

                            constructs.Add(new Construct(0, 0, 0, 100, forwardSpell.Translation));
                        }
                        if (currentRune() == "Wind 1")
                        {
                            constructs.Add(new Construct(0, 0, 100, 0, forwardSpell.Translation));
                        }
                    }
                    //if (!isShieldSpin)
                    //{
                    //    isShieldSpin = true;
                    //    currentAnimationTime = TimeSpan.Zero;
                    //}
                    //justBones.CopyTo(previousAnimation, 0);




                }
                // Console.WriteLine(playerMove.Name);

            }
            #endregion

            if (currentGamePadState.IsButtonDown(Buttons.LeftTrigger) && currentGamePadState.IsButtonDown(Buttons.RightTrigger) && currentGamePadState.IsButtonDown(Buttons.LeftShoulder) && currentGamePadState.IsButtonDown(Buttons.RightShoulder))
                ScreenManager.stage1 = true;
            if (currentGamePadState.IsButtonDown(Buttons.LeftTrigger) && currentGamePadState.IsButtonDown(Buttons.RightTrigger))
                TargetCursor = new Vector2(Projected.X, Projected.Y);

            if (currentGamePadState.IsButtonDown(Buttons.RightTrigger))
            {
                arrowTime += gameTime.ElapsedGameTime.TotalMilliseconds;
                if (arrowTime > arrowTimer)
                {
                    arrows.Add(new Arrow(arrowWorld, direction, arrow));
                    arrowTime -= arrowTimer;
                }


            }
            //if (currentGamePadState.IsButtonDown(Buttons.X))
            //{
            //    absorbAffinity = true;
            //}
            //else
            //    absorbAffinity = false;

            if (modTower)
            {
                if (currentGamePadState.IsButtonDown(Buttons.X) && oldGamePadState.IsButtonDown(Buttons.X))
                {
                    if (leftSide)
                        leftSide = false;
                    else if (!leftSide)
                    {
                        if (ScreenManager.targetedTowers.Count > 0)
                            if (ScreenManager.Theseus.runes[rSelection].count > 0)
                            {
                                ScreenManager.Towers[ScreenManager.targetedTowers[0]].runes[lSelection].name =
                                    ScreenManager.Theseus.runes[rSelection].name;
                                ScreenManager.Theseus.runes[rSelection].count--;
                            }
                        modTower = false;
                        leftSide = true;
                    }

                }
                if (currentGamePadState.IsButtonDown(Buttons.A) && oldGamePadState.IsButtonDown(Buttons.A))
                {
                    modTower = false;

                }
                if (currentGamePadState.IsButtonDown(Buttons.LeftThumbstickLeft) && oldGamePadState.IsButtonUp(Buttons.LeftThumbstickLeft))
                {
                    //if (leftSide)
                    //    leftSide = false;
                    //else
                    //    leftSide = true;
                }

                if (currentGamePadState.IsButtonDown(Buttons.LeftThumbstickRight) && oldGamePadState.IsButtonUp(Buttons.LeftThumbstickRight))
                {
                    //if (leftSide)
                    //    leftSide = false;
                    //else
                    //    leftSide = true;
                }

                if (currentGamePadState.IsButtonDown(Buttons.LeftThumbstickDown) && oldGamePadState.IsButtonUp(Buttons.LeftThumbstickDown))
                {
                    if (leftSide)
                    {
                        lSelection++;

                    }
                    if (!leftSide)
                    {
                        rSelection++;

                    }
                }

                if (currentGamePadState.IsButtonDown(Buttons.LeftThumbstickUp) && oldGamePadState.IsButtonUp(Buttons.LeftThumbstickUp))
                {
                    if (leftSide)
                    {
                        lSelection--;

                    }
                    if (!leftSide)
                    {
                        rSelection--;

                    }
                }
                if (ScreenManager.targetedTowers.Count > 0)
                {
                    if (lSelection < 0)
                        lSelection = ScreenManager.Towers[ScreenManager.targetedTowers[0]].runes.Count - 1;
                    if (lSelection > ScreenManager.Towers[ScreenManager.targetedTowers[0]].runes.Count - 1)
                        lSelection = 0;
                }
                if (rSelection < 0)
                    rSelection = ScreenManager.Theseus.runes.Count - 1;
                if (rSelection > ScreenManager.Theseus.runes.Count - 1)
                    rSelection = 0;

            }
            if (currentGamePadState.IsButtonDown(Buttons.X) && oldGamePadState.IsButtonDown(Buttons.X))
            {
                if (towerSelected)
                    modTower = true;

            }
            if (currentGamePadState.IsButtonDown(Buttons.LeftTrigger))
                construction = true;
            else
            {
                construction = false;
                buildTower = false;
                physicalTower = false;
                buildWall = false;
                buildPhase1 = false;
                buildPhase2 = false;
            }


            if (currentGamePadState.IsButtonDown(Buttons.RightShoulder))
                spellList = true;
            else
            {
                spellList = false;


            }
            #region build

            if (physicalTower && currentGamePadState.IsButtonDown(Buttons.A) && oldGamePadState.IsButtonUp(Buttons.A))
            {
                ScreenManager.Towers.Add(new Tower(tower.BS.Center));
                int x = (int)tower.BS.Center.X / 60;
                int y = (int)tower.BS.Center.Z / 60;

                ScreenManager.mainOpen[x][y] = false;
                //tower.translation = towerCenter = tower.BS.Center = position;
                physicalTower = false;

            }
            if (healCon && currentGamePadState.IsButtonDown(Buttons.Y))
            {
                healing = true;
            }
            else
                healing = false;
            if (healCon && currentGamePadState.IsButtonDown(Buttons.A))
            {
                healCon = false;
            }

            if (buildTower && currentGamePadState.IsButtonDown(Buttons.X) && oldGamePadState.IsButtonUp(Buttons.X))
            {
                healCon = true;
                buildTower = false;
                TargetCursor = new Vector2(Projected.X, Projected.Y);

            }
            if (buildTower && currentGamePadState.IsButtonDown(Buttons.Y) && oldGamePadState.IsButtonUp(Buttons.Y))
            {
                physicalTower = true;
                TargetCursor = new Vector2(Projected.X, Projected.Y);
                tower.translation = buildCenter1 = tower.BS.Center = position;

            }
            if (buildPhase2 && currentGamePadState.IsButtonDown(Buttons.B) && oldGamePadState.IsButtonUp(Buttons.B))
            {
                if (Vector3.Distance(buildCenter1, buildCenter2) < 40.0f)
                    buildCenter2 = new Vector3(buildCenter1.X + 40.0f, buildCenter1.Y, buildCenter1.Z);
                wall = new Wall(buildCenter1, buildCenter2);

            }

            if (buildPhase1 && currentGamePadState.IsButtonDown(Buttons.B) && oldGamePadState.IsButtonUp(Buttons.B))
            {
                buildPhase2 = true;
                // buildSphere1 = new BoundingSphere(buildCenter1, 20.0f);
                // buildSphere2 = new BoundingSphere(buildCenter1 + new Vector3(40.0f, 0.0f, 0.0f), 20.0f);
                // wall = new Wall(buildCenter1, buildCenter2);
            }
            if (buildWall && currentGamePadState.IsButtonDown(Buttons.B) && oldGamePadState.IsButtonUp(Buttons.B))
            {
                buildPhase1 = true;
                buildSphere1 = new BoundingSphere(buildCenter1, 20.0f);

                buildSphere2 = new BoundingSphere(buildCenter1 + new Vector3(40.0f, 0.0f, 0.0f), 20.0f);
                wall = new Wall(buildCenter1, buildCenter2);
            }
            if (construction && currentGamePadState.IsButtonDown(Buttons.B) && oldGamePadState.IsButtonUp(Buttons.B))
            {
                if (!buildWall)
                {
                    buildWall = true;
                    buildCenter1 = position;
                    buildCenter2 = position;
                    buildSphere1 = new BoundingSphere(buildCenter1, 20.0f);

                    buildSphere2 = new BoundingSphere(buildCenter1 + new Vector3(40.0f, 0.0f, 0.0f), 20.0f);
                    wall = new Wall(buildCenter1, buildCenter2);
                }
            }
            if (construction && currentGamePadState.IsButtonDown(Buttons.Y) && oldGamePadState.IsButtonUp(Buttons.Y))
                buildTower = true;
            #endregion


            //if (currentGamePadState.IsButtonDown(Buttons.B))
            //    isShield = true;
            //else
            //    isShield = false;
            if (currentGamePadState.IsButtonDown(Buttons.B))
            {
                if (!jumping & !falling)
                {
                    jumping = true;
                    currentJumpTime = 0;
                }
                else if (jumping)
                {
                    currentJumpTime += gameTime.ElapsedGameTime.TotalSeconds;
                    if (currentJumpTime > maxJumpTime)
                    {
                        falling = true;
                        jumping = false;
                    }
                }


            }
            else
            {
                falling = true;
                jumping = false;
            }
            if (spell)
                if (currentGamePadState.IsButtonDown(Buttons.Y))
                    charge1 += (float)(gameTime.ElapsedGameTime.TotalSeconds * charge1R);
            if (TargetCursor3 != null)
                TargetDirection = new Vector3(-1, 0, -1) * DirFromFloat(TurnToFace(position, TargetCursor3.Value, Direction));
            //TargetDirection *= new Vector3
            if (channeling)
            {

                ChannelingDirection = DirFromFloat(TurnToFace(position, AreaEffectCenter, ChannelingDirection));
                ChannelingDirection *= new Vector3(-1, 0, -1);
                //Direction = ChannelingDirection;


            }
            //if (currentGamePadState.IsButtonDown(Buttons.LeftShoulder))
            //    strafeRight = true;
            //else
            //    strafeRight = false;


            //if (currentGamePadState.IsButtonDown(Buttons.RightShoulder))
            //    strafeLeft = true;
            //else
            //    strafeLeft = false;


            if (isKnockedBack)
            {
                if (!isKnockBack)
                {
                    isKnockBack = true;
                    currentAnimationTime = TimeSpan.Zero;
                    justBones.CopyTo(previousAnimation, 0);

                    isBow = false;
                    isAtk1 = false;
                    isAtk2 = false;
                    isShieldToss = false;
                }

            }



            //if (Math.Abs(rotationAmount.X) > .3f || Math.Abs(rotationAmount.Y) > .3f)
            {
                //Direction = new Vector3(rotationAmount.X, 0.0f, rotationAmount.Y);



                //if ((rotationAmount.X) > .3f)
                //{

                //    Direction = Vector3.Transform(Vector3.One, Matrix.CreateFromAxisAngle(Vector3.Up, rotationAmount.X));
                //}
                //if(Math.Abs(rotationAmount.X) > .3f)
                // Direction = Vector3.Transform(new Vector3(1, 0, 0), Matrix.CreateFromAxisAngle(Vector3.Up, rot));

                // if (Math.Abs(rotationAmount.X) <- .3f)
                // {

                // Direction = Vector3.Transform(Direction, Matrix.CreateFromYawPitchRoll(rotationAmount.X,rotationAmount.Y,0.0f ));
                //}

                //if ((rotationAmount.X) > .3f)
                //{
                //    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, -.01f));

                //}

                //if ((rotationAmount.X) < -.3f)
                //{
                //    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, .01f));

                //}


                //Console.WriteLine(rotationAmount);
                //Direction = new Vector3(rotationAmount.X, 0.0f, -rotationAmount.Y);
                //Direction = new Vector3((float)Math.Cos(rot), 0.0f,(float) Math.Sin(rot));

                //NSIII 
                //if (Math.Abs(rotationAmount.X) >= 0.3 || Math.Abs(rotationAmount.Y) >= 0.3)
                //    Direction = new Vector3(rotationAmount.X, 0.0f, -rotationAmount.Y);
                //else
                //    Direction = oldDirection;
                //if (Math.Abs(currentGamePadState.ThumbSticks.Left.X) > 0.3 || Math.Abs(currentGamePadState.ThumbSticks.Left.Y) > 0.3)
                //    thrustAmount = -1.0f;
                //else
                //    thrustAmount = 0.0f;
                thrustAmount = currentGamePadState.ThumbSticks.Left.Y;
                if (Math.Abs(rotationAmount.X) > .005f || Math.Abs(rotationAmount.Y) > .005f)
                {
                    if (rotationAmount.Y < 0)
                        Direction = new Vector3(-(float)Math.Sin(rot), 0.0f, (float)Math.Cos(rot));
                    else
                        Direction = new Vector3((float)Math.Sin(rot), 0.0f, -(float)Math.Cos(rot));
                    thrustAmount = 1;
                    // else
                    //  Direction = new Vector3((float)Math.Sin(rot), 0.0f, (float)Math.Cos(rot));
                }
                //else
                RThrust = currentGamePadState.ThumbSticks.Right.Y;
                // ScreenManager.desiredY += currentGamePadState.ThumbSticks.Left.Y;
                //ScreenManager.lookAtY += currentGamePadState.ThumbSticks.Right.Y;
                if (!modTower)
                    TargetCursor += new Vector2(1, -1) * currentGamePadState.ThumbSticks.Right * (float)gameTime.ElapsedGameTime.TotalSeconds * 500.0f;

                if (physicalTower)
                    if (Math.Abs(inputAmount.X) > .05f || Math.Abs(inputAmount.Y) > .05f)
                    {

                        //if(inputAmount.Y < 0)
                        RThrust = 1;
                        if (inputAmount.Y < 0)
                            towerDirection = new Vector3(-(float)Math.Sin(rotR), 0.0f, (float)Math.Cos(rotR));
                        else
                            towerDirection = new Vector3((float)Math.Sin(rotR), 0.0f, -(float)Math.Cos(rotR));


                    }
                if (buildWall)
                {
                    if (Math.Abs(inputAmount.X) > .05f || Math.Abs(inputAmount.Y) > .05f)
                    {

                        //if(inputAmount.Y < 0)
                        RThrust = 1;
                        if (inputAmount.Y < 0)
                            buildDirection = new Vector3(-(float)Math.Sin(rotR), 0.0f, (float)Math.Cos(rotR));
                        else
                            buildDirection = new Vector3((float)Math.Sin(rotR), 0.0f, -(float)Math.Cos(rotR));


                    }


                }
                //RThrust = currentGamePadState.ThumbSticks.Right.Y;
                //if (Math.Abs(inputAmount.X) > .05f || Math.Abs(inputAmount.Y) > .05f)
                //{

                //    //if(inputAmount.Y < 0)
                //    RThrust = 1;
                //    if (inputAmount.Y < 0)
                //        AreaEffectDirection = new Vector3(-(float)Math.Sin(rotR), 0.0f, (float)Math.Cos(rotR));
                //    else
                //        AreaEffectDirection = new Vector3((float)Math.Sin(rotR), 0.0f, -(float)Math.Cos(rotR));


                //}
                if (thrustAmount > 1)
                    thrustAmount = 1.0f;
                if (thrustAmount < -1)
                    thrustAmount = -1.0f;
                if (active)
                {
                    thrustAmount = 0;

                }
                if (channeling)
                    thrustAmount = 0;

                if (Math.Abs(thrustAmount) > 0.0f)
                {
                    isRun = true;
                    justBones.CopyTo(previousAnimation, 0);
                }
                else
                {
                    isRun = false;
                    runTime = TimeSpan.Zero;
                }

                //  else
                //  thrustAmount = rotationAmount.Y;
            }


            //else
            //    thrustAmount = 0.0f;

            // Up.Normalize();

            //     Direction = oldDirection;

            if (currentGamePadState.IsButtonDown(Buttons.RightThumbstickRight) && oldGamePadState.IsButtonUp(Buttons.RightThumbstickRight))
                slot++;

            if (currentGamePadState.IsButtonDown(Buttons.RightThumbstickLeft) && oldGamePadState.IsButtonUp(Buttons.RightThumbstickLeft))
                slot--;

            if (slot == -1)
                slot = 7;
            if (slot == 8)
                slot = 0;



            // Right = Vector3.Cross(Direction, Up);
            if (isRun)
                updateRun(gameTime);
            //currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)8);
            if (isJump)
                UpdateJump(gameTime);
            if (isShield)
                UpdateShield(gameTime);
            if (isKnockBack)
                UpdateKnockBack(gameTime);
            if (isShieldToss)
                UpdateShieldToss(gameTime);
            if (isBow)
                UpdateBow(gameTime);
            if (isHoldAtk1)
                UpdateHoldBasic1(gameTime);
            if (isHoldAtk2)
                UpdateHoldBasic2(gameTime);
            if (isHoldAtk3)
                UpdateHoldBasic3(gameTime);
            if (isAtk1)
                UpdateBasic1(gameTime);
            else if (isAtk2)
                UpdateBasic2(gameTime);
            else if (isAtk3)
                UpdateBasic3(gameTime);
            if (isShieldSpin)
            {
                UpdateShieldSpin(gameTime);

            }
            if (isShieldBash)
            {
                UpdateShieldBash(gameTime);
            }
            if (isShieldUpper)
            {
                UpdateShieldUpper(gameTime);
            }
            if (isHurt)
            {
                hurtUpdate(gameTime);
            }

            //if ((runTime.Seconds > 1.0 && runTime.Seconds < 4.0) || (runTime.Seconds > 4.0 && runTime.Seconds < 8.0))
            //    thrustAmount = 1;
            //else
            //    thrustAmount = 0;
            if (isAtk1 || isAtk2 || isAtk3)
            {
                // if (currentAtkTime.TotalMilliseconds < 500)
                //    thrustAmount = .5f;
                // else
                Direction = oldDirection;
            }
            //if (isBow)
            //{
            //    Direction = TargetDirection;
            //}

            Up = Vector3.Up;
            Up.Normalize();
            Direction.Normalize();
            Right = Vector3.Cross(Direction, Up);

            if (strafe)
                Right = Vector3.Cross(facing, Up);

            if (channeling)
            {
                Right = Vector3.Cross(ChannelingDirection, Up);

            }

            Position -= Direction * thrustAmount * speed;
            if (jumping)
                Position += new Vector3(0.0f, (float)gameTime.ElapsedGameTime.TotalMilliseconds, 0.0f);
            if (falling)
                Position -= new Vector3(0.0f, (float)gameTime.ElapsedGameTime.TotalMilliseconds, 0.0f);
            if (Position.Y < 0)
            {
                falling = false;
                Position = new Vector3(Position.X, 0.0f, Position.Z);
            }
            AreaEffectCenter -= AreaEffectDirection * RThrust * 5.0f;


            if (physicalTower)
            {
                //tower.BS.Center = buildCenter1 -= towerDirection * RThrust * 5.0f;
                if (TargetCursor3.HasValue)
                {


                    tower.BS.Center = new Vector3((int)TargetCursor3.Value.X / 60 * 60 + 30, 70.0f, (int)TargetCursor3.Value.Z / 60 * 60 + 30);
                }
            }
            if (buildPhase1)
            {
                buildCenter2 -= buildDirection * RThrust * 5.0f;

                //buildSphere1 = new BoundingSphere(buildCenter1, 20.0f);
                buildSphere2 = new BoundingSphere(buildCenter2, 20.0f);
                wall = new Wall(buildSphere1.Center, buildSphere2.Center);
            }
            else if (buildWall)
            {
                buildCenter1 -= buildDirection * RThrust * 5.0f;
                buildCenter2 = buildCenter1 + new Vector3(40.0f, 0.0f, 0.0f);
                buildSphere1 = new BoundingSphere(buildCenter1, 20.0f);
                buildSphere2 = new BoundingSphere(buildCenter2, 20.0f);
                wall = new Wall(buildSphere1.Center, buildSphere2.Center);
            }

            areaSphere.BS = new BoundingSphere(AreaEffectCenter, 50.0f);

            if (isJump)
            {
                upperBones.CopyTo(justBones, 0);

            }
            if (strafeLeft)
                Position += world.Left * 2.0f;
            if (strafeRight)
                Position += world.Right * 2.0f;
            if (isHurt)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldToss)
                upperBones.CopyTo(justBones, 0);
            else if (isBow)
                upperBones.CopyTo(justBones, 0);
            else if (isShield)
                upperBones.CopyTo(justBones, 0);
            else if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldSpin)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldBash)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1 || isAtk2 || isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isHoldAtk1)
                atk1d.CopyTo(justBones, 0);
            else if (isHoldAtk2)
                atk2d.CopyTo(justBones, 0);
            else if (isHoldAtk3)
                atk1d.CopyTo(justBones, 0);
            else
                standing.CopyTo(justBones, 0);

            //world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);



            if (isKnockBack)
            {
                //    Console.WriteLine(kbTimer);
                Position = oldPosition + knockBackVec * 5.0f;
                Position = oldPosition + kbVec * 5.0f;
                kbTimer -= gameTime.ElapsedGameTime;
                if (kbTimer < TimeSpan.Zero)
                    isKnockBack = false;
            }

          //  if (ScreenManager.collisionColors[((int)(1279 - position.Z) / 10) * 128 + ((int)(1279 - position.X) / 10)].R < 15)
             //   position = oldPosition;

            if (ScreenManager.collisionColors[(int)(position.Z / 10) * 128 + (int)(position.X / 10)].R < 15)
                position = oldPosition;


            projectileWorld = Matrix.Identity;
            projectileWorld.Up = Vector3.Up;
            //projectileWorld.Forward = TargetDirection;
            projectileWorld.Forward = Direction;
            projectileWorld.Right = Vector3.Cross(projectileWorld.Up, projectileWorld.Forward);
            projectileWorld.Translation = position;

            world = Matrix.Identity;
            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Up;
            world.Right = Right;
            world.Forward = Direction;
            if (strafe)
                world.Forward = facing;
            if (channeling)
                world.Forward = ChannelingDirection;
            // world.Right.Normalize();
            world.Translation = Position;
            world.Translation += new Vector3(0.0f, jumpHt, 0.0f);
            collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
            //world.Left.Normalize();
            // world.Down.Normalize();
            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            ray = new Ray(new Vector3(Position.X, 90.0f, Position.Z), new Vector3(-Direction.X, 0.0f, -Direction.Z));//Direction);
            lRay = new Ray(new Vector3(Position.X, 90.0f, Position.Z), Vector3.Transform(new Vector3(-Direction.X, 0.0f, -Direction.Z), Matrix.CreateFromAxisAngle(Vector3.Up, -0.1f)));
            rRay = new Ray(new Vector3(Position.X, 90.0f, Position.Z), Vector3.Transform(new Vector3(-Direction.X, 0.0f, -Direction.Z), Matrix.CreateFromAxisAngle(Vector3.Up, 0.1f)));

            //  if (resetFormations)
            {
                //    resetFormations = false;

                formation = world;
            }
            // position = new Vector3(-100.0f, 0.0f, 0.0f);


            if (currentKeyBoardState.IsKeyDown(Keys.A))// && oldkeyBoardState.IsKeyUp(Keys.A))
                ScreenManager.camera.dY -= 10;
            if (currentKeyBoardState.IsKeyDown(Keys.Q))// && oldkeyBoardState.IsKeyUp(Keys.Q))
                ScreenManager.camera.dY += 10;
            if (currentKeyBoardState.IsKeyDown(Keys.W))// && oldkeyBoardState.IsKeyUp(Keys.W))
                ScreenManager.camera.dZ += 10;
            if (currentKeyBoardState.IsKeyDown(Keys.S))// && oldkeyBoardState.IsKeyUp(Keys.S))
                ScreenManager.camera.dZ -= 10;
            if (currentKeyBoardState.IsKeyDown(Keys.E))// && oldkeyBoardState.IsKeyUp(Keys.E))
                ScreenManager.camera.lY += 10;
            if (currentKeyBoardState.IsKeyDown(Keys.D))// && oldkeyBoardState.IsKeyUp(Keys.D))
                ScreenManager.camera.lY -= 10;
            if (currentKeyBoardState.IsKeyDown(Keys.R))// && oldkeyBoardState.IsKeyUp(Keys.R))
                ScreenManager.camera.lZ += 10;
            if (currentKeyBoardState.IsKeyDown(Keys.F))// && oldkeyBoardState.IsKeyUp(Keys.F))
                ScreenManager.camera.lZ -= 10;
            if (currentKeyBoardState.IsKeyDown(Keys.T))
                ScreenManager.camera.fovDiv += 1;
            if (currentKeyBoardState.IsKeyDown(Keys.G))
                ScreenManager.camera.fovDiv -= 1f;
            if (currentKeyBoardState.IsKeyDown(Keys.Escape))
                ScreenManager.aGame.Exit();

            //if(currentKeyBoardState.IsKeyDown(Keys.U))


        }
        public void UpdateTheseus(GameTime gameTime)
        {
            if (RingOfFire)
            {
                ROFTime -= gameTime.ElapsedGameTime;
                if (ROFTime < TimeSpan.Zero)
                    RingOfFire= false;

                fireRings.updateROF(gameTime, collisionS[1].BS.Center);

            }
            if (PowerGust)
            {
                PGTimer -= gameTime.ElapsedGameTime;
                if (PGTimer < TimeSpan.Zero)
                    PowerGust = false;
            }
            if (IcyField)
            {
                IFTimer -= gameTime.ElapsedGameTime;
                if (IFTimer < TimeSpan.Zero)
                    IcyField = false;
            }
            if (RockArmor)
            {
                RATimer -= gameTime.ElapsedGameTime;
                if (RATimer < TimeSpan.Zero)
                    RockArmor = false;
                rABonus = 5.0f;

            }
            else
                rABonus = 0.0f;
            if (BoilingBlood)
            {
                BBTimer -= gameTime.ElapsedGameTime;
                if (BBTimer < TimeSpan.Zero)
                    BoilingBlood = false;
                  speed = 8;
            }
            else
                speed = 5;
            
            #region old

            if (!strafe )
                facing = Direction;
            if (!channeling)
                ChannelingDirection = Direction;
            
            

            float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds;

            mana1 += elapsed * mana1Recover;
            health += elapsed * healthRecover;
            stamina += elapsed * staminaRecover;
           // Console.WriteLine(mana1);
            if (mana1 > mana1Max)
                mana1 = mana1Max;
            if (health > healthMax)
                health = healthMax;
            if(stamina > stamMax)
            stamina = stamMax;

            if (!channeling)
                AreaEffectCenter = Position;//so that it isnt the same thing in turntoface
            if(TargetCursor3 != null)
            TargetSphere = new BoundingSphere(TargetCursor3.Value + new Vector3(0, 70.0f, 0.0f), 30.0f);
            oldGamePadState = currentGamePadState;
            oldkeyBoardState = currentKeyBoardState;
            World.Decompose(out scale, out rota, out trans);
            oldPosition = Position;
            oldDirection = Direction;
            currentGamePadState = GamePad.GetState(PlayerIndex.One, GamePadDeadZone.Circular);
            currentKeyBoardState = Keyboard.GetState();
            //foreach (Projectile2 pro in projectiles)
            //{
            //    pro.update2(gameTime);
            //    projectiles.Remove(pro);                  
            //}

         //   if(fightClass == 0)

          //  if(fightClass == 1)

            for (int i = 0; i < arrows.Count; i++)
            {
                arrows[i].update(gameTime);
                if (!arrows[i].alive)
                    arrows.RemoveAt(i);

            }

            for (int i = 0; i < projectiles.Count; i++)
            {
                projectiles[i].update2(gameTime);
                if (!projectiles[i].alive)
                    projectiles.RemoveAt(i);

            }
            for (int i = 0; i < eruptions.Count; i++)
            {
                eruptions[i].updateEruption(gameTime);
                if (!eruptions[i].alive)
                    eruptions.RemoveAt(i);

            }

            


            //float rororo = TurnToFace(position, ScreenManager.Perseus.World.Translation, new Vector3(0.0f, (float)Math.Atan((double)(Direction.Z / Direction.X)), 0.0f));
            //Console.WriteLine(rororo);

           
            Vector2 rotationAmount = currentGamePadState.ThumbSticks.Left;

            float rot = (float)Math.Atan(currentGamePadState.ThumbSticks.Left.X / currentGamePadState.ThumbSticks.Left.Y);
            float rotR = (float)Math.Atan(currentGamePadState.ThumbSticks.Right.X / currentGamePadState.ThumbSticks.Right.Y);
           // Console.WriteLine(rot);
            Vector2 inputAmount = currentGamePadState.ThumbSticks.Right;
           
            //rotAmt = TurnToFace(ScreenManager.asterion.Position, ScreenManager.medusa.Position, Vector3.Zero);
            // Direction = new Vector3((float)Math.Sin(rotAmt), 0.0f, (float)Math.Cos(rotAmt));

            if (gameTime.TotalGameTime - playerMoveTime > MoveTimeOut)
            {
                playerMove = null;
            }
            //inputManager.Update(gameTime);
            Move newMove = ScreenManager.moveList.DetectMove(ScreenManager.inputManager);


            if (newMove != null)
            {
                playerMove = newMove;

                playerMoveTime = gameTime.TotalGameTime;

                //if (playerMove.Name == "LT+RT")
                //{

                //  //  Projected = 
                //    TargetCursor = new Vector2(Projected.X, Projected.Y);


                //}
                if (playerMove.Name == "B")
                {
                    if (spellList) //Defense
                    {
                        if (currentRune() == "Fire 1")
                        {
                            RingOfFire = true;
                            ROFTime = new TimeSpan(0, 0, 5);
                            fireRings = new horizontalRing(3, world, 70);
                        }
                        if (currentRune() == "Earth 1")
                        {
                            rockOrbit = true;
                            ROTime = new TimeSpan(0, 0, 5);
                        }
   
                   
                        if (currentRune() == "Water 1")
                        {
                            IcyField = true;
                            IFTimer = new TimeSpan(0, 0, 5);
                            IFSphere = new BoundingSphere(bodySphere.Center, 80.0f);
                        }
                           
                         if (currentRune() == "Wind 1")
                        {
                            EnvelopingWinds = true;
                            EWTime = new TimeSpan(0, 0, 5);
                            EWSphere = new BoundingSphere(bodySphere.Center, 80.0f);


                        }

                    }

                }
                if (playerMove.Name == "Y")
                {
                    if (spellList) //Support
                    {
                        if (currentRune() == "Fire 1")
                        {
                            BoilingBlood = true;
                            BBTimer = new TimeSpan(0, 0, 5);
                        }
                        if (currentRune() == "Earth 1")
                        {
                            RockArmor = true;
                            RATimer = new TimeSpan(0, 0, 5);
                        }
                        if (currentRune() == "Water 1")
                        {
                            Heal = true;
                            HTime = new TimeSpan(0, 0, 5);

                        }
                        if (currentRune() == "Wind 1")
                        {
                            //powergust with a weapon adds charge
                            PowerGust = true;
                            PGTimer = new TimeSpan(0, 0, 5);

                        }
                    }
                    else
                    {
                        if (!isBow)
                        {
                            isBow = true;

                            currentAnimationTime = TimeSpan.Zero;
                            justBones.CopyTo(previousAnimation, 0);


                        }


                        //if(fightClass == 0)
                        //if (!isShieldToss)
                        //{
                        //    isShieldToss = true;

                        //    currentAnimationTime = TimeSpan.Zero;
                        //    justBones.CopyTo(previousAnimation, 0);


                        //}
                        // if (fightClass == 1)
                    }
     
                }

                if (playerMove.Name == "RS")
                {



                    //if (!spell)
                    //{
                    //    spell = true;
                        
                    //    AreaEffectCenter = Position;

                    //}
                    //else
                    //{
                    //    spell = false;
                     
                    //}
                //    if (mana1 > 60)
                   // {
                   ////     mana1 -= 60;
                   //     projectiles.Add(new Projectile2("Fire", forwardSpell, facing));
                   // }
                }
                if (playerMove.Name == "LT")
                {
                    ///Construct
                    
                    
                    
                    //Physical Tower, Elemental Tower, Tower of Warding, Rinna-Al, Shura-Mo, 

                    //if (!channeling)
                    //    channeling = true;
                    //else
                    //    channeling = false;
                    //double ran1 = ScreenManager.rand.NextDouble();
                    //double ran2 = ScreenManager.rand.NextDouble();
                    //double ran3 = ScreenManager.rand.NextDouble();
                    //double ran4 = ScreenManager.rand.NextDouble();
                    //int rise1 = 50 + ScreenManager.rand.Next(80);
                    //int rise2 = 50 + ScreenManager.rand.Next(80);
                    //int rise3 = 50 + ScreenManager.rand.Next(80);
                    //int rise4 = 50 + ScreenManager.rand.Next(80);
                    //eruptions.Add(new Projectile2("Eruption", World, DirFromDouble(ran1), DirFromDouble(ran2), DirFromDouble(ran3),
                    //    DirFromDouble(ran4), rise1, rise2, rise3, rise4));
                    //testingIndex++;
                    //if (testingIndex > 2)
                    //    testingIndex = 0;

                }
                if (playerMove.Name == "RT")
                {
                    ///RT SWITCHES THE TARGET
                    //ScreenManager.Theseus.Position = new Vector3(1349.0f, 0.0f, 2770.0f);//13.49 -27.692
                    findNextTarget();

                    fightClass++;
                    if (fightClass == 2)
                        fightClass = 0; 
                }
                if (playerMove.Name == "LS")
                {
                //    if (strafe)
                //        strafe = false;
                //    else
                //    {
                //        strafe = true;
                       
                //    }
                //    //strafeLeft = true;
                //    projectiles.Add(new Projectile2("FireBlast", World, facing));
                }



                if (playerMove.Name == "A")
                {
                    if (spellList) //offense
                    {
                        if (currentRune() == "Fire 1")
                        {
                            fireBall1 = true;
                            projectiles.Add(new Projectile2("Fire", forwardSpell, facing));
                        }
                        if (currentRune() == "Earth 1")
                        {
                            avalanche1 = true;
                            projectiles.Add(new Projectile2("Earth", forwardSpell, facing));
                        }
                        if (currentRune() == "Water 1")
                        {
                            waterBlast = true;
                            projectiles.Add(new Projectile2("Water", forwardSpell, facing));
                        }
                        if (currentRune() == "Wind 1")
                        {
                            slicingWinds = true;
                            projectiles.Add(new Projectile2("Wind", forwardSpell, facing));
                        }


                    }

                    else
                    {
                        if (!isAtk1 &!isHoldAtk1)
                        {

                            active = true;
                            isAtk1 = true;
                            currentAnimationTime = TimeSpan.Zero;
                            justBones.CopyTo(previousAnimation, 0);
                            currentAtkTime = TimeSpan.FromSeconds(1.0);
                            atkSuccess = false;
                            hits.Clear();
                            atkSpheres.Clear();
                        }

                    }



                }
                if (playerMove.Name == "AA")
                {
                    //if (!isAtk1 && !isAtk2)

                    if (!isAtk2 &! isHoldAtk2)
                    {
                        isHoldAtk1 = false;
                        active = true;
                        isAtk2 = true;
                        //currentAnimationTime = TimeSpan.Zero;
                        //justBones.CopyTo(previousAnimation, 0);

                        if (!isAtk1)
                            currentAnimationTime = TimeSpan.Zero;
                        atkSuccess = false;
                        hits.Clear();
                        atkSpheres.Clear();

                    }


                }
                if (playerMove.Name == "AAA")
                {
                    if (!isAtk3)
                    {
                        active = true;
                        isAtk3 = true;
                        if (!isAtk2)
                            currentAnimationTime = TimeSpan.Zero;
                        atkSuccess = false;
                        hits.Clear();
                        atkSpheres.Clear();
                    }

                }

                if (playerMove.Name == "X") //defense
                {
                    if (spellList) 
                    {

                        if (currentRune() == "Fire 1")
                        {
                            //fireBall1 = true;
                            constructs.Add(new Construct(100, 0, 0, 0, forwardSpell.Translation));
                            
                        }
                        if (currentRune() == "Earth 1")
                        {
                            constructs.Add(new Construct(0, 100, 0, 0, forwardSpell.Translation));
                        }
                        if (currentRune() == "Water 1")
                        {
                            
                            constructs.Add(new Construct(0, 0, 0, 100, forwardSpell.Translation));
                        }
                        if (currentRune() == "Wind 1")
                        {
                            constructs.Add(new Construct(0, 0, 100, 0, forwardSpell.Translation));
                        }
                    }
                    //if (!isShieldSpin)
                    //{
                    //    isShieldSpin = true;
                    //    currentAnimationTime = TimeSpan.Zero;
                    //}
                    //justBones.CopyTo(previousAnimation, 0);




                }
               // Console.WriteLine(playerMove.Name);

            }
            #endregion

            if (currentGamePadState.IsButtonDown(Buttons.LeftTrigger) && currentGamePadState.IsButtonDown(Buttons.RightTrigger) && currentGamePadState.IsButtonDown(Buttons.LeftShoulder) && currentGamePadState.IsButtonDown(Buttons.RightShoulder))
                ScreenManager.stage1 = true;
            if(currentGamePadState.IsButtonDown(Buttons.LeftTrigger) && currentGamePadState.IsButtonDown(Buttons.RightTrigger))
                TargetCursor = new Vector2(Projected.X, Projected.Y);

            //if (currentGamePadState.IsButtonDown(Buttons.X))
            //{
            //    absorbAffinity = true;
            //}
            //else
            //    absorbAffinity = false;

            if (modTower)
            {
                if(currentGamePadState.IsButtonDown(Buttons.X) && oldGamePadState.IsButtonDown(Buttons.X))
                {
                    if (leftSide)
                        leftSide = false;
                    else if (!leftSide)
                    {
                        if(ScreenManager.targetedTowers.Count > 0)
                            if (ScreenManager.Theseus.runes[rSelection].count > 0)
                            {
                                ScreenManager.Towers[ScreenManager.targetedTowers[0]].runes[lSelection].name =
                                    ScreenManager.Theseus.runes[rSelection].name;
                                ScreenManager.Theseus.runes[rSelection].count--;
                            }
                        modTower = false;
                        leftSide = true;
                    }

                }
                if(currentGamePadState.IsButtonDown(Buttons.A) && oldGamePadState.IsButtonDown(Buttons.A))
                {
                modTower = false;

                }
                if (currentGamePadState.IsButtonDown(Buttons.LeftThumbstickLeft) && oldGamePadState.IsButtonUp(Buttons.LeftThumbstickLeft))
                {
                    //if (leftSide)
                    //    leftSide = false;
                    //else
                    //    leftSide = true;
                }

                if (currentGamePadState.IsButtonDown(Buttons.LeftThumbstickRight) && oldGamePadState.IsButtonUp(Buttons.LeftThumbstickRight))
                {
                    //if (leftSide)
                    //    leftSide = false;
                    //else
                    //    leftSide = true;
                }

                if (currentGamePadState.IsButtonDown(Buttons.LeftThumbstickDown) && oldGamePadState.IsButtonUp(Buttons.LeftThumbstickDown))
                {
                    if (leftSide)
                    {
                        lSelection++;

                    }
                    if (!leftSide)
                    {
                        rSelection++;

                    }
                }

                if (currentGamePadState.IsButtonDown(Buttons.LeftThumbstickUp) && oldGamePadState.IsButtonUp(Buttons.LeftThumbstickUp))
                {
                    if (leftSide)
                    {
                        lSelection--;

                    }
                    if (!leftSide)
                    {
                        rSelection--;

                    }
                }
                if (ScreenManager.targetedTowers.Count > 0)
                {
                    if (lSelection < 0)
                        lSelection = ScreenManager.Towers[ScreenManager.targetedTowers[0]].runes.Count - 1;
                    if (lSelection > ScreenManager.Towers[ScreenManager.targetedTowers[0]].runes.Count - 1)
                        lSelection = 0;
                }
                if (rSelection < 0)
                    rSelection = ScreenManager.Theseus.runes.Count - 1;
                if (rSelection > ScreenManager.Theseus.runes.Count - 1)
                    rSelection = 0; 

            }
            if(currentGamePadState.IsButtonDown(Buttons.X) && oldGamePadState.IsButtonDown(Buttons.X))
            {
                if(towerSelected)
                    modTower = true;

            }
            if (currentGamePadState.IsButtonDown(Buttons.LeftTrigger))
                construction = true;
            else
            {
                construction = false;
                buildTower = false;
                physicalTower = false;
                buildWall = false;
                buildPhase1 = false;
                buildPhase2 = false;
            }


            if (currentGamePadState.IsButtonDown(Buttons.RightShoulder))
                spellList = true;
            else
            {
                spellList = false;


            }
            #region build

            if (physicalTower && currentGamePadState.IsButtonDown(Buttons.A) && oldGamePadState.IsButtonUp(Buttons.A))
            {
                ScreenManager.Towers.Add(new Tower(tower.BS.Center));
                int x = (int)tower.BS.Center.X / 60;
                int y  = (int)tower.BS.Center.Z/60;

                ScreenManager.mainOpen[x][y] = false;
                //tower.translation = towerCenter = tower.BS.Center = position;
                physicalTower = false;

            }
            if (healCon && currentGamePadState.IsButtonDown(Buttons.Y))
            {
                healing = true;
            }
            else
                healing = false;
            if (healCon && currentGamePadState.IsButtonDown(Buttons.A))
            {
                healCon = false;
            }

            if (buildTower && currentGamePadState.IsButtonDown(Buttons.X) && oldGamePadState.IsButtonUp(Buttons.X))
            {
                healCon = true;
                buildTower = false;
                TargetCursor = new Vector2(Projected.X, Projected.Y);
                
            }
            if (buildTower && currentGamePadState.IsButtonDown(Buttons.Y) && oldGamePadState.IsButtonUp(Buttons.Y))
            {
                physicalTower = true;
                TargetCursor = new Vector2(Projected.X, Projected.Y);
                tower.translation = buildCenter1 = tower.BS.Center = position;

            }
            if (buildPhase2 && currentGamePadState.IsButtonDown(Buttons.B) && oldGamePadState.IsButtonUp(Buttons.B))
            {
                if(Vector3.Distance(buildCenter1 , buildCenter2) < 40.0f)
                    buildCenter2 = new Vector3(buildCenter1.X + 40.0f, buildCenter1.Y, buildCenter1.Z);
                wall = new Wall(buildCenter1, buildCenter2);

            }

            if (buildPhase1 && currentGamePadState.IsButtonDown(Buttons.B) && oldGamePadState.IsButtonUp(Buttons.B))
            {
                buildPhase2 = true;
               // buildSphere1 = new BoundingSphere(buildCenter1, 20.0f);
               // buildSphere2 = new BoundingSphere(buildCenter1 + new Vector3(40.0f, 0.0f, 0.0f), 20.0f);
               // wall = new Wall(buildCenter1, buildCenter2);
            }
            if (buildWall && currentGamePadState.IsButtonDown(Buttons.B) && oldGamePadState.IsButtonUp(Buttons.B))
            {
                buildPhase1 = true;
                buildSphere1 = new BoundingSphere(buildCenter1, 20.0f);

                buildSphere2 = new BoundingSphere(buildCenter1 + new Vector3(40.0f, 0.0f, 0.0f), 20.0f);
                wall = new Wall(buildCenter1, buildCenter2);
            }
            if (construction && currentGamePadState.IsButtonDown(Buttons.B) && oldGamePadState.IsButtonUp(Buttons.B))
            {
                if (!buildWall)
                {
                    buildWall = true;
                    buildCenter1 = position;
                    buildCenter2 = position;
                    buildSphere1 = new BoundingSphere(buildCenter1, 20.0f);

                    buildSphere2 = new BoundingSphere(buildCenter1 + new Vector3(40.0f, 0.0f, 0.0f), 20.0f);
                    wall = new Wall(buildCenter1, buildCenter2);
                }
            }
            if (construction && currentGamePadState.IsButtonDown(Buttons.Y) && oldGamePadState.IsButtonUp(Buttons.Y))
                buildTower = true;
            #endregion


            if (currentGamePadState.IsButtonDown(Buttons.B))
                isShield = true;
            else
                isShield = false;

            if (spell)
                if (currentGamePadState.IsButtonDown(Buttons.Y))
                    charge1 += (float)(gameTime.ElapsedGameTime.TotalSeconds * charge1R);
            if(TargetCursor3 != null)
            TargetDirection = new Vector3(-1, 0, -1) * DirFromFloat(TurnToFace(position, TargetCursor3.Value, Direction));
            //TargetDirection *= new Vector3
            if (channeling)
            {

               ChannelingDirection = DirFromFloat(TurnToFace(position, AreaEffectCenter, ChannelingDirection));
               ChannelingDirection *= new Vector3(-1, 0, -1);
               //Direction = ChannelingDirection;


            }
            //if (currentGamePadState.IsButtonDown(Buttons.LeftShoulder))
            //    strafeRight = true;
            //else
            //    strafeRight = false;


            //if (currentGamePadState.IsButtonDown(Buttons.RightShoulder))
            //    strafeLeft = true;
            //else
            //    strafeLeft = false;


            if (isKnockedBack)
            {
                if (!isKnockBack)
                {
                    isKnockBack = true;
                    currentAnimationTime = TimeSpan.Zero;
                    justBones.CopyTo(previousAnimation, 0);

                    isBow = false;
                    isAtk1 = false;
                    isAtk2 = false;
                    isShieldToss = false;
                }

            }



            //if (Math.Abs(rotationAmount.X) > .3f || Math.Abs(rotationAmount.Y) > .3f)
            {
                //Direction = new Vector3(rotationAmount.X, 0.0f, rotationAmount.Y);



                //if ((rotationAmount.X) > .3f)
                //{

                //    Direction = Vector3.Transform(Vector3.One, Matrix.CreateFromAxisAngle(Vector3.Up, rotationAmount.X));
                //}
                //if(Math.Abs(rotationAmount.X) > .3f)
               // Direction = Vector3.Transform(new Vector3(1, 0, 0), Matrix.CreateFromAxisAngle(Vector3.Up, rot));
                
               // if (Math.Abs(rotationAmount.X) <- .3f)
               // {

                   // Direction = Vector3.Transform(Direction, Matrix.CreateFromYawPitchRoll(rotationAmount.X,rotationAmount.Y,0.0f ));
                //}

                //if ((rotationAmount.X) > .3f)
                //{
                //    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, -.01f));

                //}

                //if ((rotationAmount.X) < -.3f)
                //{
                //    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, .01f));

                //}

                
                //Console.WriteLine(rotationAmount);
                //Direction = new Vector3(rotationAmount.X, 0.0f, -rotationAmount.Y);
                //Direction = new Vector3((float)Math.Cos(rot), 0.0f,(float) Math.Sin(rot));
                
                //NSIII 
                //if (Math.Abs(rotationAmount.X) >= 0.3 || Math.Abs(rotationAmount.Y) >= 0.3)
                //    Direction = new Vector3(rotationAmount.X, 0.0f, -rotationAmount.Y);
                //else
                //    Direction = oldDirection;
                //if (Math.Abs(currentGamePadState.ThumbSticks.Left.X) > 0.3 || Math.Abs(currentGamePadState.ThumbSticks.Left.Y) > 0.3)
                //    thrustAmount = -1.0f;
                //else
                //    thrustAmount = 0.0f;
                thrustAmount = currentGamePadState.ThumbSticks.Left.Y;
                if (Math.Abs(rotationAmount.X) > .05f || Math.Abs(rotationAmount.Y) > .05f)
                {
                    if (rotationAmount.Y < 0)
                       Direction = new Vector3(-(float)Math.Sin(rot), 0.0f, (float)Math.Cos(rot));
                    else
                        Direction = new Vector3((float)Math.Sin(rot), 0.0f, -(float)Math.Cos(rot));
                    thrustAmount = 1;
                    // else
                    //  Direction = new Vector3((float)Math.Sin(rot), 0.0f, (float)Math.Cos(rot));
                }
                //else
                RThrust = currentGamePadState.ThumbSticks.Right.Y;
               // ScreenManager.desiredY += currentGamePadState.ThumbSticks.Left.Y;
                //ScreenManager.lookAtY += currentGamePadState.ThumbSticks.Right.Y;
                if(!modTower)
                TargetCursor += new Vector2(1, -1) * currentGamePadState.ThumbSticks.Right * (float)gameTime.ElapsedGameTime.TotalSeconds * 500.0f;

                if(physicalTower)
                    if (Math.Abs(inputAmount.X) > .05f || Math.Abs(inputAmount.Y) > .05f)
                    {

                        //if(inputAmount.Y < 0)
                        RThrust = 1;
                        if (inputAmount.Y < 0)
                            towerDirection = new Vector3(-(float)Math.Sin(rotR), 0.0f, (float)Math.Cos(rotR));
                        else
                            towerDirection = new Vector3((float)Math.Sin(rotR), 0.0f, -(float)Math.Cos(rotR));


                    }
                if (buildWall)
                {
                    if (Math.Abs(inputAmount.X) > .05f || Math.Abs(inputAmount.Y) > .05f)
                    {

                        //if(inputAmount.Y < 0)
                        RThrust = 1;
                        if (inputAmount.Y < 0)
                            buildDirection = new Vector3(-(float)Math.Sin(rotR), 0.0f, (float)Math.Cos(rotR));
                        else
                            buildDirection = new Vector3((float)Math.Sin(rotR), 0.0f, -(float)Math.Cos(rotR));


                    }


                }
                //RThrust = currentGamePadState.ThumbSticks.Right.Y;
                //if (Math.Abs(inputAmount.X) > .05f || Math.Abs(inputAmount.Y) > .05f)
                //{
                    
                //    //if(inputAmount.Y < 0)
                //    RThrust = 1;
                //    if (inputAmount.Y < 0)
                //        AreaEffectDirection = new Vector3(-(float)Math.Sin(rotR), 0.0f, (float)Math.Cos(rotR));
                //    else
                //        AreaEffectDirection = new Vector3((float)Math.Sin(rotR), 0.0f, -(float)Math.Cos(rotR));


                //}
                if (thrustAmount > 1)
                    thrustAmount = 1.0f;
                if (thrustAmount < -1)
                    thrustAmount = -1.0f;
                if (active)
                {
                    thrustAmount = 0;

                }
                if (channeling)
                    thrustAmount = 0; 

                if (Math.Abs(thrustAmount) > 0.0f)
                {
                    isRun = true;
                    justBones.CopyTo(previousAnimation, 0);
                }
                else
                {
                    isRun = false;
                    runTime = TimeSpan.Zero;
                }

                //  else
                //  thrustAmount = rotationAmount.Y;
            }


            //else
            //    thrustAmount = 0.0f;

           // Up.Normalize();

           //     Direction = oldDirection;

            if (currentGamePadState.IsButtonDown(Buttons.RightThumbstickRight) && oldGamePadState.IsButtonUp(Buttons.RightThumbstickRight))
                slot++;

            if (currentGamePadState.IsButtonDown(Buttons.RightThumbstickLeft) && oldGamePadState.IsButtonUp(Buttons.RightThumbstickLeft))
                slot--;

            if (slot == -1)
                slot = 7;
            if (slot == 8)
                slot = 0; 
            


           // Right = Vector3.Cross(Direction, Up);
            if (isRun)
            updateRun(gameTime);
            //currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)8);
            if (isJump)
                UpdateJump(gameTime);
            if (isShield)
                UpdateShield(gameTime);
            if (isKnockBack)
                UpdateKnockBack(gameTime);
            if (isShieldToss)
                UpdateShieldToss(gameTime);
            if (isBow)
                UpdateBow(gameTime);
            if (isHoldAtk1)
                UpdateHoldBasic1(gameTime);
            if (isHoldAtk2)
                UpdateHoldBasic2(gameTime);
            if (isHoldAtk3)
                UpdateHoldBasic3(gameTime);
            if (isAtk1)
                UpdateBasic1(gameTime);
            else if (isAtk2)
                UpdateBasic2(gameTime);
            else if (isAtk3)
                UpdateBasic3(gameTime);
            if (isShieldSpin)
            {
                UpdateShieldSpin(gameTime);     

            }
            if (isShieldBash)
            {
                UpdateShieldBash(gameTime);
            }
            if (isShieldUpper)
            {
                UpdateShieldUpper(gameTime);
            }
            if (isHurt)
            {
                hurtUpdate(gameTime);
            }

            //if ((runTime.Seconds > 1.0 && runTime.Seconds < 4.0) || (runTime.Seconds > 4.0 && runTime.Seconds < 8.0))
            //    thrustAmount = 1;
            //else
            //    thrustAmount = 0;
            if (isAtk1 || isAtk2 || isAtk3)
            {
               // if (currentAtkTime.TotalMilliseconds < 500)
                //    thrustAmount = .5f;
               // else
                    Direction = oldDirection;
            }
            //if (isBow)
            //{
            //    Direction = TargetDirection;
            //}

            Up = Vector3.Up;
            Up.Normalize();
            Direction.Normalize();
            Right = Vector3.Cross(Direction, Up);

            if (strafe)
                Right = Vector3.Cross(facing, Up);

            if (channeling)
            {
                Right = Vector3.Cross(ChannelingDirection, Up);

            }

            Position -= Direction * thrustAmount * speed;
            AreaEffectCenter -= AreaEffectDirection * RThrust * 5.0f;


            if (physicalTower)
            {
                //tower.BS.Center = buildCenter1 -= towerDirection * RThrust * 5.0f;
                if (TargetCursor3.HasValue)
                {
                    

                    tower.BS.Center = new Vector3((int)TargetCursor3.Value.X / 60 * 60 + 30, 70.0f, (int)TargetCursor3.Value.Z / 60 *60 + 30);
                }
            }
            if (buildPhase1)
            {
                buildCenter2 -= buildDirection * RThrust * 5.0f;

                //buildSphere1 = new BoundingSphere(buildCenter1, 20.0f);
                buildSphere2 = new BoundingSphere(buildCenter2, 20.0f);
                wall = new Wall(buildSphere1.Center, buildSphere2.Center);
            }
            else if (buildWall)
            {
                buildCenter1 -= buildDirection * RThrust * 5.0f;
                buildCenter2 = buildCenter1 + new Vector3(40.0f, 0.0f, 0.0f);
                buildSphere1 = new BoundingSphere(buildCenter1, 20.0f);
                buildSphere2 = new BoundingSphere(buildCenter2, 20.0f);
                wall = new Wall(buildSphere1.Center, buildSphere2.Center);
            }

            areaSphere.BS = new BoundingSphere(AreaEffectCenter, 50.0f);

            if (isJump)
            {
                upperBones.CopyTo(justBones, 0);
                
            }
            if (strafeLeft)
                Position += world.Left * 2.0f;
            if (strafeRight)
                Position += world.Right * 2.0f;
            if (isHurt)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldToss)
                upperBones.CopyTo(justBones, 0);
            else if (isBow)
                upperBones.CopyTo(justBones, 0);
            else if (isShield)
                upperBones.CopyTo(justBones, 0);
            else if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldSpin)
                upperBones.CopyTo(justBones, 0);
            else if (isShieldBash)
                upperBones.CopyTo(justBones, 0);
            else if (isKnockBack)
                upperBones.CopyTo(justBones, 0);
            else if (isAtk1 || isAtk2 || isAtk3)
                upperBones.CopyTo(justBones, 0);
            else if (isHoldAtk1)
                atk1d.CopyTo(justBones, 0);
            else if (isHoldAtk2)
                atk2d.CopyTo(justBones, 0);
            else if (isHoldAtk3)
                atk1d.CopyTo(justBones, 0);
            else
                standing.CopyTo(justBones, 0);

            //world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);



            if (isKnockBack)
            {
            //    Console.WriteLine(kbTimer);
                Position = oldPosition + knockBackVec * 5.0f;
                Position = oldPosition + kbVec * 5.0f;
                kbTimer -= gameTime.ElapsedGameTime;
                if (kbTimer < TimeSpan.Zero)
                    isKnockBack = false;
            }
            

            projectileWorld = Matrix.Identity;
            projectileWorld.Up = Vector3.Up;
            //projectileWorld.Forward = TargetDirection;
            projectileWorld.Forward = Direction;
            projectileWorld.Right = Vector3.Cross(projectileWorld.Up, projectileWorld.Forward);
            projectileWorld.Translation = position;

            world = Matrix.Identity;
            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Up;
            world.Right = Right;
            world.Forward = Direction;
            if (strafe)
                world.Forward = facing;
            if (channeling)
                world.Forward = ChannelingDirection;
           // world.Right.Normalize();
            world.Translation = Position;
            world.Translation += new Vector3(0.0f, jumpHt, 0.0f);
            collisionS[1].BS = new BoundingSphere(Position + new Vector3(0.0f, 70.0f, 0.0f), collisionS[1].BS.Radius);
            //world.Left.Normalize();
           // world.Down.Normalize();
            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();

            ray = new Ray(new Vector3(Position.X, 90.0f, Position.Z), new Vector3(-Direction.X, 0.0f, -Direction.Z));//Direction);
            lRay = new Ray(new Vector3(Position.X, 90.0f, Position.Z), Vector3.Transform(new Vector3(-Direction.X, 0.0f, -Direction.Z), Matrix.CreateFromAxisAngle(Vector3.Up, -0.1f)));
            rRay = new Ray(new Vector3(Position.X, 90.0f, Position.Z), Vector3.Transform(new Vector3(-Direction.X, 0.0f, -Direction.Z), Matrix.CreateFromAxisAngle(Vector3.Up, 0.1f)));

            //  if (resetFormations)
            {
                //    resetFormations = false;

                formation = world;
            }
            // position = new Vector3(-100.0f, 0.0f, 0.0f);


            if (currentKeyBoardState.IsKeyDown(Keys.A))// && oldkeyBoardState.IsKeyUp(Keys.A))
                ScreenManager.camera.dY -=10;
            if (currentKeyBoardState.IsKeyDown(Keys.Q))// && oldkeyBoardState.IsKeyUp(Keys.Q))
                ScreenManager.camera.dY += 10;
            if (currentKeyBoardState.IsKeyDown(Keys.W))// && oldkeyBoardState.IsKeyUp(Keys.W))
                ScreenManager.camera.dZ += 10;
            if (currentKeyBoardState.IsKeyDown(Keys.S))// && oldkeyBoardState.IsKeyUp(Keys.S))
                ScreenManager.camera.dZ -= 10;
            if (currentKeyBoardState.IsKeyDown(Keys.E))// && oldkeyBoardState.IsKeyUp(Keys.E))
                ScreenManager.camera.lY += 10;
            if (currentKeyBoardState.IsKeyDown(Keys.D))// && oldkeyBoardState.IsKeyUp(Keys.D))
                ScreenManager.camera.lY -= 10;
            if (currentKeyBoardState.IsKeyDown(Keys.R))// && oldkeyBoardState.IsKeyUp(Keys.R))
                ScreenManager.camera.lZ += 10;
            if (currentKeyBoardState.IsKeyDown(Keys.F))// && oldkeyBoardState.IsKeyUp(Keys.F))
                ScreenManager.camera.lZ -= 10;
            if (currentKeyBoardState.IsKeyDown(Keys.T))
                ScreenManager.camera.fovDiv += 1;
            if (currentKeyBoardState.IsKeyDown(Keys.G))
                ScreenManager.camera.fovDiv -= 1f;
            if (currentKeyBoardState.IsKeyDown(Keys.Escape))
                ScreenManager.aGame.Exit();
            
            //if(currentKeyBoardState.IsKeyDown(Keys.U))
               

        }
        public void UpdatePerseus(GameTime gameTime)
        {


            float elapsed = (float)gameTime.ElapsedGameTime.TotalSeconds;
            oldGamePadState = currentGamePadState;
            oldkeyBoardState = currentKeyBoardState;
            World.Decompose(out scale, out rota, out trans);
            oldPosition = Position;
            oldDirection = Direction;
            currentGamePadState = GamePad.GetState(PlayerIndex.One);

            foreach (Projectile2 pro in projectiles)
                pro.update2(gameTime);


            Vector2 rotationAmount = currentGamePadState.ThumbSticks.Left;

            Vector2 inputAmount = currentGamePadState.ThumbSticks.Right;

            //rotAmt = TurnToFace(ScreenManager.asterion.Position, ScreenManager.medusa.Position, Vector3.Zero);
            // Direction = new Vector3((float)Math.Sin(rotAmt), 0.0f, (float)Math.Cos(rotAmt));

            if (gameTime.TotalGameTime - playerMoveTime > MoveTimeOut)
            {
                playerMove = null;
            }
            //inputManager.Update(gameTime);
            Move newMove = ScreenManager.moveList.DetectMove(ScreenManager.inputManager);

            if (newMove != null)
            {
                playerMove = newMove;

                playerMoveTime = gameTime.TotalGameTime;

                if (playerMove.Name == "RS")
                {
                    projectiles.Add(new Projectile2("Fire", forwardSpell, Direction));

                }
                if (playerMove.Name == "LT")
                {
                    testingIndex++;
                    if (testingIndex > 2)
                        testingIndex = 0;

                }
                if (playerMove.Name == "RT")
                {

                }
                if (playerMove.Name == "LS")
                {


                }



                if (playerMove.Name == "A")
                {

                    if (!isSpear)
                    {
                        isSpear = true;
                        currentAnimationTime = TimeSpan.Zero;
                        justBones.CopyTo(previousAnimation, 0);

                        //ScreenManager.spears[0].state = 1;
                        //need to set attack
                    }

                }
                if (playerMove.Name == "AA")
                {
                    //if (!isAtk1 && !isAtk2)

                    if (!isSpearSpin)
                    {

                        isSpearSpin = true;
                        //currentAnimationTime = TimeSpan.Zero;
                        //justBones.CopyTo(previousAnimation, 0);

                        if (!isSpear)
                            currentAnimationTime = TimeSpan.Zero;


                    }


                }

                if (playerMove.Name == "X")
                {
                    if (!isFlyingSpear &! isSpear)
                    {
                        isFlyingSpear = true;
                        currentAnimationTime = TimeSpan.Zero;
                    }
                    justBones.CopyTo(previousAnimation, 0);




                }
                Console.WriteLine(playerMove.Name);

            }
            //if (Math.Abs(rotationAmount.X) > .3f || Math.Abs(rotationAmount.Y) > .3f)
            {
                //Direction = new Vector3(rotationAmount.X, 0.0f, rotationAmount.Y);



                if ((rotationAmount.X) > .3f)
                {

                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, -.03f));
                }
                if ((rotationAmount.X) < -.3f)
                {
                    Direction = Vector3.Transform(Direction, Matrix.CreateFromAxisAngle(Vector3.Up, .03f));

                }
                thrustAmount = -currentGamePadState.ThumbSticks.Left.Y;

                if (thrustAmount > 1)
                    thrustAmount = 1.0f;
                if (thrustAmount < -1)
                    thrustAmount = -1.0f;



                if (Math.Abs(thrustAmount) > 0.0f)
                {
                    isRun = true;
                    justBones.CopyTo(previousAnimation, 0);
                }
                else
                {
                    isRun = false;
                    runTime = TimeSpan.Zero;
                }
                //  else
                //  thrustAmount = rotationAmount.Y;
            }
            //else
            //    thrustAmount = 0.0f;

            Up.Normalize();
            Direction.Normalize();


            Right = Vector3.Cross(Direction, Up);
            if (isRun)
            {
                runTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)3.0);
                if (runTime.TotalSeconds < 9.0f)
                {

                    //        if (runTime.TotalSeconds < 1.0f)
                    //        {

                    //            for (int i = 0; i < brace.Length; i++)
                    //            {
                    //                previousAnimation[i].Decompose(out scale, out rota, out trans);
                    //                run1a[i].Decompose(out scale2, out rota2, out trans2);
                    //                upperBones[i] = Matrix.CreateScale(scale2) *
                    //Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
                    //Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                    //            }

                    //        }
                    //        else 
                    if (runTime.TotalSeconds < 1.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun1[i].Decompose(out scale, out rota, out trans);
                            lRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun2[i].Decompose(out scale, out rota, out trans);
                            lRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun3[i].Decompose(out scale, out rota, out trans);
                            lRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 5.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            lRun4[i].Decompose(out scale, out rota, out trans);
                            rRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 4.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 4.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 6.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun1[i].Decompose(out scale, out rota, out trans);
                            rRun2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 5.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 5.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 7.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun2[i].Decompose(out scale, out rota, out trans);
                            rRun3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 6.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 6.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 8.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun3[i].Decompose(out scale, out rota, out trans);
                            rRun4[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 7.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 7.0) / 1.0f));

                        }


                    }
                    else if (runTime.TotalSeconds < 9.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            rRun4[i].Decompose(out scale, out rota, out trans);
                            lRun1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 8.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 8.0) / 1.0f));

                        }


                    }

                }
                else
                {

                    runTime = TimeSpan.Zero;
                    lRun1.CopyTo(previousAnimation, 0);



                }

            }
            currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)8);

            if (isFlyingSpear)
            {


                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 1.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            flySpear1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 2.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            flySpear1[i].Decompose(out scale, out rota, out trans);
                            flySpear2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 3.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            flySpear2[i].Decompose(out scale, out rota, out trans);
                            flySpear3[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                        }


                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            flySpear3[i].Decompose(out scale, out rota, out trans);
                            brace[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                        }


                    }




                }
                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isFlyingSpear = false;
                }

            }
            if (isSpear)
            {
                if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    if (currentAnimationTime.TotalSeconds < 2.0f)
                    {

                        for (int i = 0; i < brace.Length; i++)
                        {
                            previousAnimation[i].Decompose(out scale, out rota, out trans);
                            spear1[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 2.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 2.0f));

                        }

                    }
                    else if (currentAnimationTime.TotalSeconds < 4.0f)
                    {
                        for (int i = 0; i < brace.Length; i++)
                        {
                            spear1[i].Decompose(out scale, out rota, out trans);
                            spear2[i].Decompose(out scale2, out rota2, out trans2);
                            upperBones[i] = Matrix.CreateScale(scale2) *
            Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 4.0f)) *
            Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 4.0f));

                        }


                    }

                }
                else if (!isSpearSpin)
                {

                    isSpear = false;
                    currentAnimationTime = TimeSpan.Zero;



                }
                    
                else if (currentAnimationTime.TotalSeconds < 5.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        spear2[i].Decompose(out scale, out rota, out trans);
                        spearSpin1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 6.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        spearSpin1[i].Decompose(out scale, out rota, out trans);
                        spearSpin2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 7.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        spearSpin2[i].Decompose(out scale, out rota, out trans);
                        spearSpin3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 6.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 6.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 8.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        spearSpin3[i].Decompose(out scale, out rota, out trans);
                        spearSpin4[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 7.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 7.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 9.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        spearSpin4[i].Decompose(out scale, out rota, out trans);
                        spearSpin5[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 8.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 8.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 10.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        spearSpin5[i].Decompose(out scale, out rota, out trans);
                        spearSpin6[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 9.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 9.0) / 1.0f));

                    }


                }


                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isSpear = false;
                    isSpearSpin = false;

                }


            }




            //world = Matrix.Identity;
            //world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            //world.Up = Up;
            //world.Right = Right;
            //world.Translation = Position + new Vector3(0.0f, 0.0f, 0.0f);


            //if (isAtk1)
            // upperBones.CopyTo(justBones, 0);
            //else

            // world = Matrix.Identity;

            Position += Direction * thrustAmount * 5.0f;
            if (isRun)
                upperBones.CopyTo(justBones, 0);
            else if (isFlyingSpear)
                upperBones.CopyTo(justBones, 0);
            else if (isSpear)
                upperBones.CopyTo(justBones, 0);
            else
                brace.CopyTo(justBones, 0);

            world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);

            // world.Forward = new Vector3(Direction.X, Direction.Y, Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            world.Translation = Position;

            // world.Translation = new Vector3(0.0f, 0.0f, 0.0f);
            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();



            //  if (resetFormations)
            {
                //    resetFormations = false;

                formation = world;
            }
            // position = new Vector3(-100.0f, 0.0f, 0.0f);



        }
        public void UpdateJump(GameTime gameTime)
        {

            currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)2.0);
            if (currentAnimationTime.TotalSeconds < 1.0)
            {
                for (int i = 0; i < brace.Length; i++)
                {
                    previousAnimation[i].Decompose(out scale, out rota, out trans);
                    jump1[i].Decompose(out scale2, out rota2, out trans2);
                    upperBones[i] = Matrix.CreateScale(scale2) *
    Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
    Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                }
                jumpHt = Vector3.Lerp(Vector3.Zero, new Vector3(0.0f, 120.0f, 0.0f), (float)currentAnimationTime.TotalSeconds / 1.0f).Y;
            }
            else if (currentAnimationTime.TotalSeconds < 2.0f)
            {
                for (int i = 0; i < brace.Length; i++)
                {
                    jump1[i].Decompose(out scale, out rota, out trans);
                    standing[i].Decompose(out scale2, out rota2, out trans2);
                    upperBones[i] = Matrix.CreateScale(scale2) *
    Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
    Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));
                    jumpHt = Vector3.Lerp(new Vector3(0.0f, 120.0f, 0.0f), Vector3.Zero, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f).Y;
                }


            }
            else
            {
                isJump = false;

            }




        }
        public void updateRun(GameTime gameTime)
        {

            runTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)8.0);
            if (runTime.TotalSeconds < 8.0f)
            {

                //        if (runTime.TotalSeconds < 1.0f)
                //        {

                //            for (int i = 0; i < brace.Length; i++)
                //            {
                //                previousAnimation[i].Decompose(out scale, out rota, out trans);
                //                run1a[i].Decompose(out scale2, out rota2, out trans2);
                //                upperBones[i] = Matrix.CreateScale(scale2) *
                //Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
                //Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                //            }

                //        }
                //        else 
                if (runTime.TotalSeconds < 1.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        previousAnimation[i].Decompose(out scale, out rota, out trans);
                        lRun1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds) / 1.0f));

                    }


                }
                else if (runTime.TotalSeconds < 2.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        lRun1[i].Decompose(out scale, out rota, out trans);
                        lRun2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 1.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 1.0) / 1.0f));

                    }


                }
                else if (runTime.TotalSeconds < 3.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        lRun2[i].Decompose(out scale, out rota, out trans);
                        lRun3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 2.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 2.0) / 1.0f));

                    }


                }
                else if (runTime.TotalSeconds < 4.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        lRun3[i].Decompose(out scale, out rota, out trans);
                        lRun4[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 3.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 3.0) / 1.0f));

                    }


                }
                else if (runTime.TotalSeconds < 4.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        lRun4[i].Decompose(out scale, out rota, out trans);
                        rRun1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 3.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 3.0) / 1.0f));

                    }


                }
                else if (runTime.TotalSeconds < 5.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        rRun1[i].Decompose(out scale, out rota, out trans);
                        rRun2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 4.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 4.0) / 1.0f));

                    }


                }
                else if (runTime.TotalSeconds < 6.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        rRun2[i].Decompose(out scale, out rota, out trans);
                        rRun3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 5.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 5.0) / 1.0f));

                    }


                }
                else if (runTime.TotalSeconds < 7.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        rRun3[i].Decompose(out scale, out rota, out trans);
                        rRun4[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 6.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 6.0) / 1.0f));

                    }


                }
                else if (runTime.TotalSeconds < 8.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        rRun4[i].Decompose(out scale, out rota, out trans);
                        lRun1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(runTime.TotalSeconds - 7.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(runTime.TotalSeconds - 7.0) / 1.0f));

                    }


                }

            }
            else
            {

                runTime = TimeSpan.FromSeconds(1.0);
                lRun1.CopyTo(previousAnimation, 0);
            }
        }

        public void updateKnockDown(GameTime gameTime)
        {


            currentAnimationTime += TimeSpan.FromTicks(gameTime.ElapsedGameTime.Ticks * 3);
            if (currentAnimationTime.TotalSeconds < 1.0f)
            {

                if (currentAnimationTime.TotalSeconds < 1.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        previousAnimation[i].Decompose(out scale, out rota, out trans);
                        knockDown[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                    }

                }
            }
            else
            {
                knockDown.CopyTo(upperBones, 0);
            }


        }

        public void UpdateHammerFlight(GameTime gameTime)
        {

            currentAnimationTime += TimeSpan.FromTicks(gameTime.ElapsedGameTime.Ticks * 2);
            if (currentAnimationTime.TotalSeconds < 2.0f)
            {

                if (currentAnimationTime.TotalSeconds < 1.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        previousAnimation[i].Decompose(out scale, out rota, out trans);
                        hammerFlight1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 2.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        hammerFlight1[i].Decompose(out scale, out rota, out trans);
                        hammerFlight2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                    }

                }
            }
            else
            {
                slashPoints.Clear();
                isHammerFlight = false;
                isAPSet = false;
                currentAnimationTime = TimeSpan.Zero;
                atkSuccess = false;
                    active = false;
                    state = 0;
            }

        }
        public void UpdatePBasic1(GameTime gameTime)
        {
            //Console.WriteLine(currentAtkTime);
            // Console.WriteLine(currentAnimationTime);
            currentAtkTime -= gameTime.ElapsedGameTime;
            currentAnimationTime += TimeSpan.FromTicks(gameTime.ElapsedGameTime.Ticks * 4);
            if (currentAnimationTime.TotalSeconds < 4.0f)
            {

                if (currentAnimationTime.TotalSeconds < 1.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        previousAnimation[i].Decompose(out scale, out rota, out trans);
                        atk1a[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 2.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk1a[i].Decompose(out scale, out rota, out trans);
                        atk1b[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 3.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk1b[i].Decompose(out scale, out rota, out trans);
                        atk1c[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk1c[i].Decompose(out scale, out rota, out trans);
                        atk1d[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                    }

                }

            }
            else
            {
                isHoldAtk1 = false;

                thrustAmount = 0.0f;
                atkSuccess = false;
                slashPoints.Clear();
                isAtk1 = false;
                currentAnimationTime = TimeSpan.Zero;
                atk1d.CopyTo(previousAnimation, 0);
                hit.Clear();
                if (isHoldAtk2)
                {
                   //changed for pbasic on mouse control
                    //if (isAtk2)
                    {
                        //atk1d.CopyTo(previousAnimation, 0);
                        openStrike = true;
                        currentAtkTime = new TimeSpan(0, 0, 1);
                    }



                }

                else
                {
                    active = false;
                    isBrace = true;
                    pstate = 0;
                }

            }


        }
        public void UpdateHoldBasic1(GameTime gameTime)
        {
            
            currentAnimationTime += gameTime.ElapsedGameTime;
            if (currentAnimationTime.TotalMilliseconds < 500.0f)
            {

                ///dont have to do anything just return atk1d
            }
            else
            {

                isHoldAtk1 = false;

            }

        }
        public void UpdateHoldBasic2(GameTime gameTime)
        {

            currentAnimationTime += gameTime.ElapsedGameTime;
            if (currentAnimationTime.TotalMilliseconds < 500.0f)
            {

                ///dont have to do anything just return atk1d
            }
            else
            {

                isHoldAtk2 = false;

            }

        }
        public void UpdateHoldBasic3(GameTime gameTime)
        {

            currentAnimationTime += gameTime.ElapsedGameTime;
            if (currentAnimationTime.TotalMilliseconds < 500.0f)
            {

                ///dont have to do anything just return atk1d
            }
            else
            {

                isHoldAtk3 = false;

            }

        }
        public void UpdateDeadMonster(GameTime gameTime)
        {

            UpdateDead(gameTime);
            if (!isDead)
            {
                isDead = true;
                ScreenManager.items.Add(new Item(position, 0, 2));
                ScreenManager.items.Add(new Item(position, 1, 3));

            }
            upperBones.CopyTo(justBones, 0);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;

            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();



        }
        public void UpdateDeadJune(GameTime gameTime)
        {
            UpdateDead(gameTime);
            if (!isDead)
            {
                isDead = true;
                //ScreenManager.items.Add(new Item(position, 0, 2));
                //ScreenManager.items.Add(new Item(position, 1, 3));

            }
            upperBones.CopyTo(justBones, 0);
            world = Matrix.Identity;
            world.Forward = new Vector3(-Direction.X, Direction.Y, -Direction.Z);
            world.Up = Vector3.Up;
            world.Right = Vector3.Cross(world.Forward, world.Up);
            //position.Y = ScreenManager.heightData[pX, pZ];
            world.Translation = Position;

            UpdateWorldTransforms(Matrix.Identity);
            UpdateSkinTransforms();



        }
        public void UpdateDead(GameTime gameTime)
        {
            currentAnimationTime += TimeSpan.FromTicks(gameTime.ElapsedGameTime.Ticks);
            if (currentAnimationTime.TotalSeconds < 1.0f)
            {

                for (int i = 0; i < brace.Length; i++)
                {
                    previousAnimation[i].Decompose(out scale, out rota, out trans);
                    deaded[i].Decompose(out scale2, out rota2, out trans2);
                    upperBones[i] = Matrix.CreateScale(scale2) *
    Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
    Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                }

            }
            else
                deaded.CopyTo(upperBones, 0);
    }
        public void UpdateBasic1(GameTime gameTime)
        {
           // Console.WriteLine(currentAtkTime);
           // Console.WriteLine(currentAnimationTime);
            currentAtkTime -= gameTime.ElapsedGameTime;
            //there are 4 parts to the animation and it has to be played in one second that why its multiplied here
            currentAnimationTime += TimeSpan.FromTicks(gameTime.ElapsedGameTime.Ticks * 4);
            if (currentAnimationTime.TotalSeconds < 4.0f)
            {

                if (currentAnimationTime.TotalSeconds < 1.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        previousAnimation[i].Decompose(out scale, out rota, out trans);
                        atk1a[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 2.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk1a[i].Decompose(out scale, out rota, out trans);
                        atk1b[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 3.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk1b[i].Decompose(out scale, out rota, out trans);
                        atk1c[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk1c[i].Decompose(out scale, out rota, out trans);
                        atk1d[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                    }

                }

            }
            else
            {
                atkSpheres.Clear();
                atkSuccess = false;
                slashPoints.Clear();
                isAtk1 = false;
                currentAnimationTime = TimeSpan.Zero;
                atk1d.CopyTo(previousAnimation, 0);
                hit.Clear();
                isHoldAtk1 = true;
                if (isAtk2)
                {
                    //atk1d.CopyTo(previousAnimation, 0);
                    openStrike = true;
                    currentAtkTime= new TimeSpan(0, 0, 1);
                }
                else
                {
                    active = false;
                    isBrace = true;
                    
                }

            }


        }
        public void UpdatePBasic2(GameTime gameTime)
        {
            currentAtkTime -= gameTime.ElapsedGameTime;
            currentAnimationTime += TimeSpan.FromTicks(gameTime.ElapsedGameTime.Ticks * 2);
            if (currentAnimationTime.TotalSeconds < 2.0f)
            {

                if (currentAnimationTime.TotalSeconds < 1.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        previousAnimation[i].Decompose(out scale, out rota, out trans);
                        atk2a[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 2.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk2a[i].Decompose(out scale, out rota, out trans);
                        atk2b[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                    }

                }
            }
            else
            {
                isHoldAtk2 = false;
                slashPoints.Clear();
                isAtk2 = false;
                currentAnimationTime = TimeSpan.Zero;
                atkSuccess = false;
                if (isAtk3)
                {
                    atk2b.CopyTo(previousAnimation, 0);
                    openStrike = true;
                    currentAtkTime = new TimeSpan(0, 0, 1);
                }
                else
                    active = false;

            }

        }

        public void UpdateBasic2(GameTime gameTime)
        {
            currentAtkTime -= gameTime.ElapsedGameTime;
            currentAnimationTime += TimeSpan.FromTicks(gameTime.ElapsedGameTime.Ticks * 4);
            if (currentAnimationTime.TotalSeconds < 4.0f)
            {

                if (currentAnimationTime.TotalSeconds < 1.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        previousAnimation[i].Decompose(out scale, out rota, out trans);
                        atk1c[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 2.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk1c[i].Decompose(out scale, out rota, out trans);
                        atk1b[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 3.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk1b[i].Decompose(out scale, out rota, out trans);
                        atk1a[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk1a[i].Decompose(out scale, out rota, out trans);
                        standing[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                    }

                }
            }
            else
            {
                atkSpheres.Clear();
                slashPoints.Clear();
                isAtk2 = false;
                currentAnimationTime = TimeSpan.Zero;
                atkSuccess = false;
                isHoldAtk2 = true;
                if (isAtk3)
                {
                    atk2d.CopyTo(previousAnimation, 0);
                    openStrike = true;
                    currentAtkTime = new TimeSpan(0, 0, 1);
                }
                else
                    active = false;

            }

        }
        public void UpdateBasic3(GameTime gameTime)
        {

            currentAtkTime -= gameTime.ElapsedGameTime;
            currentAnimationTime += TimeSpan.FromTicks(gameTime.ElapsedGameTime.Ticks * 3);
            if (currentAnimationTime.TotalSeconds < 4.0f)
            {

                if (currentAnimationTime.TotalSeconds < 1.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        previousAnimation[i].Decompose(out scale, out rota, out trans);
                        atk1a[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 2.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk1a[i].Decompose(out scale, out rota, out trans);
                        atk1b[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 3.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk1b[i].Decompose(out scale, out rota, out trans);
                        atk1c[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 4.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        atk1c[i].Decompose(out scale, out rota, out trans);
                        atk1d[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                    }

                }
            }
            else
            {
                atkSpheres.Clear();
                isHoldAtk3 = true;
                slashPoints.Clear();
                isAtk3 = false;
                currentAnimationTime = TimeSpan.Zero;
                atkSuccess = false;
                atk1d.CopyTo(previousAnimation, 0);
                active = false;
            }

        }

        public void UpdatePBow(GameTime gameTime)
        {


            currentAnimationTime += TimeSpan.FromTicks(gameTime.ElapsedGameTime.Ticks * 3);

            if (currentAnimationTime.TotalSeconds < 2.0f)
            {

                if (currentAnimationTime.TotalSeconds < 1.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        previousAnimation[i].Decompose(out scale, out rota, out trans);
                        bow2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 2.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        bow2[i].Decompose(out scale, out rota, out trans);
                        bow3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                    }


                }
            }
            else if (!isTripleBow)
            {
                pstate = 0; 
                isBow = false;
                currentAnimationTime = TimeSpan.Zero;


                if (arrow1Fired == false)
                {
                    // arrow1Fired = true;
                    projectiles.Add(new Projectile2("Arrow", arrowWorld, TargetDirection));

                }



            }


            else if (currentAnimationTime.TotalSeconds < 3.0f)
            {
                if (arrow1Fired == false)
                {
                    arrow1Fired = true;
                    projectiles.Add(new Projectile2("Arrow", arrowWorld, facing));

                }
                for (int i = 0; i < brace.Length; i++)
                {
                    bow3[i].Decompose(out scale, out rota, out trans);
                    bow2[i].Decompose(out scale2, out rota2, out trans2);
                    upperBones[i] = Matrix.CreateScale(scale2) *
    Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
    Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                }


            }
            else if (currentAnimationTime.TotalSeconds < 4.0f)
            {
                for (int i = 0; i < brace.Length; i++)
                {
                    bow2[i].Decompose(out scale, out rota, out trans);
                    bow3[i].Decompose(out scale2, out rota2, out trans2);
                    upperBones[i] = Matrix.CreateScale(scale2) *
    Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
    Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                }


            }
            else if (currentAnimationTime.TotalSeconds < 5.0f)
            {
                if (arrow2Fired == false)
                {
                    arrow2Fired = true;
                    projectiles.Add(new Projectile2("Arrow", arrowWorld, facing));

                }
                for (int i = 0; i < brace.Length; i++)
                {
                    bow3[i].Decompose(out scale, out rota, out trans);
                    bow2[i].Decompose(out scale2, out rota2, out trans2);
                    upperBones[i] = Matrix.CreateScale(scale2) *
    Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
    Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                }


            }
            else if (currentAnimationTime.TotalSeconds < 6.0f)
            {
                for (int i = 0; i < brace.Length; i++)
                {
                    bow2[i].Decompose(out scale, out rota, out trans);
                    bow3[i].Decompose(out scale2, out rota2, out trans2);
                    upperBones[i] = Matrix.CreateScale(scale2) *
    Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
    Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                }


            }

            else
            {
                if (arrow3Fired == false)
                {
                    arrow3Fired = true;
                    projectiles.Add(new Projectile2("Arrow", arrowWorld, facing));

                }
                currentAnimationTime = TimeSpan.Zero;
                isBow = false;
                isTripleBow = false;

            }





        }
        public void UpdateBow(GameTime gameTime)
        {


            currentAnimationTime += TimeSpan.FromTicks(gameTime.ElapsedGameTime.Ticks * 2);

            if (currentAnimationTime.TotalSeconds < 2.0f)
            {

                if (currentAnimationTime.TotalSeconds < 1.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        previousAnimation[i].Decompose(out scale, out rota, out trans);
                        bow2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) /1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 2.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        bow2[i].Decompose(out scale, out rota, out trans);
                        bow3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds -1.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) /1.0f));

                    }


                }
            }
            else if (!isTripleBow)
            {
                isBow = false;
                currentAnimationTime = TimeSpan.Zero;


                if (arrow1Fired == false)
                {
                    // arrow1Fired = true;
                 //   projectiles.Add(new Projectile2("Arrow", arrowWorld, TargetDirection));
                    //projectiles.Add(new Projectile2("Arrow", arrowWorld, Direction));
                    arrows.Add(new Arrow(arrowWorld, Direction, arrow));
                }



            }


            else if (currentAnimationTime.TotalSeconds < 3.0f)
            {
                if (arrow1Fired == false)
                {
                    arrow1Fired = true;
                    //projectiles.Add(new Projectile2("Arrow", arrowWorld, facing));
                    arrows.Add(new Arrow(arrowWorld, Direction, arrow));

                }
                for (int i = 0; i < brace.Length; i++)
                {
                    bow3[i].Decompose(out scale, out rota, out trans);
                    bow2[i].Decompose(out scale2, out rota2, out trans2);
                    upperBones[i] = Matrix.CreateScale(scale2) *
    Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
    Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                }


            }
            else if (currentAnimationTime.TotalSeconds < 4.0f)
            {
                for (int i = 0; i < brace.Length; i++)
                {
                    bow2[i].Decompose(out scale, out rota, out trans);
                    bow3[i].Decompose(out scale2, out rota2, out trans2);
                    upperBones[i] = Matrix.CreateScale(scale2) *
    Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
    Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                }


            }
            else if (currentAnimationTime.TotalSeconds < 5.0f)
            {
                if (arrow2Fired == false)
                {
                    arrow2Fired = true;
                   // projectiles.Add(new Projectile2("Arrow", arrowWorld, facing));
                    arrows.Add(new Arrow(arrowWorld, Direction, arrow));
                }
                for (int i = 0; i < brace.Length; i++)
                {
                    bow3[i].Decompose(out scale, out rota, out trans);
                    bow2[i].Decompose(out scale2, out rota2, out trans2);
                    upperBones[i] = Matrix.CreateScale(scale2) *
    Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
    Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                }


            }
            else if (currentAnimationTime.TotalSeconds < 6.0f)
            {
                for (int i = 0; i < brace.Length; i++)
                {
                    bow2[i].Decompose(out scale, out rota, out trans);
                    bow3[i].Decompose(out scale2, out rota2, out trans2);
                    upperBones[i] = Matrix.CreateScale(scale2) *
    Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f)) *
    Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 5.0) / 1.0f));

                }


            }

            else
            {
                if (arrow3Fired == false)
                {
                    arrow3Fired = true;
                  //  projectiles.Add(new Projectile2("Arrow", arrowWorld, facing));
                    arrows.Add(new Arrow(arrowWorld, Direction, arrow));
                }
                currentAnimationTime = TimeSpan.Zero;
                isBow = false;
                isTripleBow = false;

            }





        }

        public void UpdateKnockBack(GameTime gameTime)
        {



            currentAnimationTime += gameTime.ElapsedGameTime;
            if (currentAnimationTime.TotalSeconds < 2.0f)
            {

                if (currentAnimationTime.TotalSeconds < 1.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        previousAnimation[i].Decompose(out scale, out rota, out trans);
                        kb1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 2.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        kb1[i].Decompose(out scale, out rota, out trans);
                        kb2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                    }

                }
                //        else if (currentAnimationTime.TotalSeconds < 3.0f)
                //        {

                //            for (int i = 0; i < brace.Length; i++)
                //            {
                //                kb2[i].Decompose(out scale, out rota, out trans);
                //                kb3[i].Decompose(out scale2, out rota2, out trans2);
                //                upperBones[i] = Matrix.CreateScale(scale2) *
                //Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
                //Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds -2.0) / 1.0f));

                //            }

                //        }
            }
            else
            {
                isKnockBack = false;
                currentAnimationTime = TimeSpan.Zero;
                active = false;
                kb2.CopyTo(previousAnimation, 0);

            }








        }

        public void UpdateShieldSpin(GameTime gameTime)
        {
            currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)5);
            if (currentAnimationTime.TotalSeconds < 5.0f)
            {

                if (currentAnimationTime.TotalSeconds < 1.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        previousAnimation[i].Decompose(out scale, out rota, out trans);
                        shieldSpin1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 2.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldSpin1[i].Decompose(out scale, out rota, out trans);
                        shieldSpin2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 3.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldSpin2[i].Decompose(out scale, out rota, out trans);
                        shieldSpin3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 4.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldSpin3[i].Decompose(out scale, out rota, out trans);
                        shieldSpin4[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 5.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldSpin4[i].Decompose(out scale, out rota, out trans);
                        shieldSpin2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 4.0) / 1.0f));

                    }


                }
                            }
            else
            {
                
                currentAnimationTime = TimeSpan.Zero;
                isShieldSpin = false;
                shieldSpin4.CopyTo(previousAnimation, 0);
            }
         }
        public void UpdateShieldBash(GameTime gameTime)
        {
            currentAnimationTime += new TimeSpan(gameTime.ElapsedGameTime.Ticks * (long)2);
            if (currentAnimationTime.TotalSeconds < 2.0f)
            {

                if (currentAnimationTime.TotalSeconds < 1.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        previousAnimation[i].Decompose(out scale, out rota, out trans);
                        shieldBash1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 2.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldBash1[i].Decompose(out scale, out rota, out trans);
                        shieldBash2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 2.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 2.0f));

                    }


                }


            }
            else if (!isShieldUpper)
            {

                isShieldBash = false;
                currentAnimationTime = TimeSpan.Zero;
                shieldBash2.CopyTo(previousAnimation, 0);
                hit.Clear();
                if (isShieldUpper)
                {
                    shieldBash2.CopyTo(previousAnimation, 0);
                    openStrike = true;
                }
                else
                {
                    isBrace = true;

                }
            }
        }

        public void UpdateShieldToss(GameTime gameTime)
        {
           

                currentAnimationTime += TimeSpan.FromTicks(gameTime.ElapsedGameTime.Ticks * (long)3);
                if (currentAnimationTime.TotalSeconds < 1.0f)
                {

                    for (int i = 0; i < brace.Length; i++)
                    {
                        previousAnimation[i].Decompose(out scale, out rota, out trans);
                        shieldToss1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds) / 1.0f));

                    }

                }
                else if (currentAnimationTime.TotalSeconds < 2.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldToss1[i].Decompose(out scale, out rota, out trans);
                        shieldToss2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 3.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldToss2[i].Decompose(out scale, out rota, out trans);
                        shieldToss3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                    }


                }
                else
                {


                    isShieldToss = false;
                    currentAnimationTime = TimeSpan.Zero;
                    projectiles.Add(new Projectile2("Shield", shieldWorld, Direction));

                }

            

        }
        public void UpdateShieldUpper(GameTime gameTime)
        {

            currentAnimationTime += TimeSpan.FromTicks(gameTime.ElapsedGameTime.Ticks * (long)4);
            if (currentAnimationTime.TotalSeconds < 1.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldBash2[i].Decompose(out scale, out rota, out trans);
                        shieldUpper1[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds ) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds ) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 2.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldUpper1[i].Decompose(out scale, out rota, out trans);
                        shieldUpper2[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 1.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 3.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldUpper2[i].Decompose(out scale, out rota, out trans);
                        shieldUpper3[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 2.0) / 1.0f));

                    }


                }
                else if (currentAnimationTime.TotalSeconds < 4.0f)
                {
                    for (int i = 0; i < brace.Length; i++)
                    {
                        shieldUpper3[i].Decompose(out scale, out rota, out trans);
                        shieldUpper4[i].Decompose(out scale2, out rota2, out trans2);
                        upperBones[i] = Matrix.CreateScale(scale2) *
        Matrix.CreateFromQuaternion(Quaternion.Slerp(rota, rota2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f)) *
        Matrix.CreateTranslation(Vector3.Lerp(trans, trans2, (float)(currentAnimationTime.TotalSeconds - 3.0) / 1.0f));

                    }
                    

                }

                else
                {
                    currentAnimationTime = TimeSpan.Zero;
                    isShieldBash = false;
                    isShieldUpper = false;
                    isBrace = true;

                }



        }

        public void Patrol(GameTime gameTime)
        {







        }
        public void UpdateWorldTransforms(Matrix rootTransform)
        {
            // Root bone.
            worldTrans[0] = justBones[0] * world;

            // Child bones.
            for (int bone = 1; bone < worldTrans.Length; bone++)
            {
                int parentBone = skinningData.SkeletonHierarchy[bone];

                worldTrans[bone] = justBones[bone] *
                                             worldTrans[parentBone];
            }
        }
        /// <summary>
        /// Helper used by the Update method to refresh the SkinTransforms data.
        /// </summary>
        public void UpdateSkinTransforms()
        {
            for (int bone = 0; bone < skinTrans.Length; bone++)
            {
                skinTrans[bone] = skinningData.InverseBindPose[bone] *
                                            worldTrans[bone];
            }
        }
         public Point start, end;
         public Point Mstart, Mend;
            // Holds search nodes that are avaliable to search
            public List<JSearchNode> JopenList;
            public List<JSearchNode> MopenList;
            // Holds the nodes that have already been searched
            public List<JSearchNode> JclosedList;
            public List<JSearchNode> MclosedList;
            // Holds all the paths we've creted so far
            private Dictionary<Point, Point> Jpaths;
            private Dictionary<Point, Point> Mpaths;
            // Tells us if the search is stopped, started, finished or failed
            public JSearchStatus myMSearchStatus
            {
                set
                {
                    MsearchStatus = value;
                }
                get { return MsearchStatus; }



            }

            private JSearchStatus MsearchStatus;
            public JSearchStatus myJSearchStatus
            {
                set
                {
                    JsearchStatus = value;
                }
                get { return JsearchStatus; }
            }
            private JSearchStatus JsearchStatus;

            // Tells us which search type we're using right now
            public JSearchMethod myJSearchMethod
            {
                get { return JsearchMethod; }
            }
            private JSearchMethod JsearchMethod = JSearchMethod.AStar;

            public bool IsSearching
            {

                get { return JsearchStatus == JSearchStatus.Searching; }
                set
                {
                    if (JsearchStatus == JSearchStatus.Searching)
                    {
                        JsearchStatus = JSearchStatus.Stopped;
                    }
                    else if (JsearchStatus == JSearchStatus.Stopped)
                    {
                        JsearchStatus = JSearchStatus.Searching;
                    }
                }
            }
            public bool MIsSearching
            {

                get { return MsearchStatus == JSearchStatus.Searching; }
                set
                {
                    if (MsearchStatus == JSearchStatus.Searching)
                    {
                        MsearchStatus = JSearchStatus.Stopped;
                    }
                    else if (MsearchStatus == JSearchStatus.Stopped)
                    {
                        MsearchStatus = JSearchStatus.Searching;
                    }
                }
            }

            public int TotalSearchSteps
            {
                get { return totalSearchSteps; }
            }
            private int totalSearchSteps = 0;

            public int MTotalSearchSteps
            {
                get { return MtotalSearchSteps; }
            }
            private int MtotalSearchSteps = 0;

            public void JunePathing(Point Start, Point End)
            {

                JsearchStatus = new JSearchStatus();
                MsearchStatus = new JSearchStatus();
                JsearchStatus = JSearchStatus.Stopped;
                MsearchStatus = JSearchStatus.Stopped;
                JopenList = new List<JSearchNode>();
                JclosedList = new List<JSearchNode>();
                Jpaths = new Dictionary<Point, Point>();

                MopenList = new List<JSearchNode>();
                MclosedList = new List<JSearchNode>();
                Mpaths = new Dictionary<Point, Point>();

                start = Start;
                end = End;

                Reset(start, end);

            }
            public void MReset(Point StartPt, Point EndPt)
            {
                mWayPoints.Clear();
                Mstart = StartPt;
                Mend = EndPt;
                MsearchStatus = JSearchStatus.Stopped;
                MtotalSearchSteps = 0;
                MopenList.Clear();
                MclosedList.Clear();
                Mpaths.Clear();
                MopenList.Add(new JSearchNode(Mstart, StepDistance(Mstart, Mend), 0));

            }
            public void Reset(Point StartPt, Point EndPt)
            {
                start = StartPt;
                end = EndPt;
                JsearchStatus = JSearchStatus.Stopped;
                totalSearchSteps = 0;
                JopenList.Clear();
                JclosedList.Clear();
                Jpaths.Clear();
                JopenList.Add(new JSearchNode(start, StepDistance(start, end), 0));

            }
            /// <summary>
            /// Cycle through the search method to the next type
            /// </summary>
            public void NextSearchType()
            {
                JsearchMethod = (JSearchMethod)(((int)JsearchMethod + 1) %
                    (int)JSearchMethod.Max);
            }

            private bool InMap(int column, int row)
            {
                return (row >= 0 && row < 5 &&
                    column >= 0 && column < 5);
            }
            private bool MainInMap(int column, int row)
            {
                return (row >= 0 && row < 50 &&
    column >= 0 && column < 50);
            }


            /// <summary>
            /// Returns true if the given map location exists and is not 
            /// blocked by a barrier
            /// </summary>
            /// <param name="column">column position(x)</param>
            /// <param name="row">row position(y)</param>
            private bool IsOpen(int column, int row)
            {
                return InMap(column, row) &&  open[column][row] != false;
            }
            private bool MainIsOpen(int column, int row)
            {
                return MainInMap(column, row) && ScreenManager.mainOpen[column][row] != false;
            }
            /// <summary>
            /// Enumerate all the map locations that can be entered from the given 
            /// map location
            /// </summary>
            public IEnumerable<Point> MainOpenMapTiles(Point mapLoc)
            {
                if (MainIsOpen(mapLoc.X, mapLoc.Y + 1))
                    yield return new Point(mapLoc.X, mapLoc.Y + 1);
                if (MainIsOpen(mapLoc.X, mapLoc.Y - 1))
                    yield return new Point(mapLoc.X, mapLoc.Y - 1);
                if (MainIsOpen(mapLoc.X + 1, mapLoc.Y))
                    yield return new Point(mapLoc.X + 1, mapLoc.Y);
                if (MainIsOpen(mapLoc.X - 1, mapLoc.Y))
                    yield return new Point(mapLoc.X - 1, mapLoc.Y);

                if (MainIsOpen(mapLoc.X - 1, mapLoc.Y - 1))
                    yield return new Point(mapLoc.X - 1, mapLoc.Y - 1);
                if (MainIsOpen(mapLoc.X - 1, mapLoc.Y + 1))
                    yield return new Point(mapLoc.X - 1, mapLoc.Y + 1);
                if (MainIsOpen(mapLoc.X + 1, mapLoc.Y - 1))
                    yield return new Point(mapLoc.X + 1, mapLoc.Y - 1);
                if (MainIsOpen(mapLoc.X + 1, mapLoc.Y + 1))
                    yield return new Point(mapLoc.X + 1, mapLoc.Y + 1);



            }
            public IEnumerable<Point> OpenMapTiles(Point mapLoc)
            {

                if (IsOpen(mapLoc.X, mapLoc.Y + 1))
                    yield return new Point(mapLoc.X, mapLoc.Y + 1);
                if (IsOpen(mapLoc.X, mapLoc.Y - 1))
                    yield return new Point(mapLoc.X, mapLoc.Y - 1);
                if (IsOpen(mapLoc.X + 1, mapLoc.Y))
                    yield return new Point(mapLoc.X + 1, mapLoc.Y);
                if (IsOpen(mapLoc.X - 1, mapLoc.Y))
                    yield return new Point(mapLoc.X - 1, mapLoc.Y);

                //if (IsOpen(mapLoc.X - 1, mapLoc.Y - 1))
                //    yield return new Point(mapLoc.X - 1, mapLoc.Y - 1);
                //if (IsOpen(mapLoc.X - 1, mapLoc.Y + 1))
                //    yield return new Point(mapLoc.X - 1, mapLoc.Y + 1);
                //if (IsOpen(mapLoc.X + 1, mapLoc.Y - 1))
                //    yield return new Point(mapLoc.X + 1, mapLoc.Y - 1);
                //if (IsOpen(mapLoc.X + 1, mapLoc.Y + 1))
                //    yield return new Point(mapLoc.X + 1, mapLoc.Y + 1);
            }
            public void MainDoSearchStep()
            {
                JSearchNode newOpenListNode;

                bool foundNewNode = MainSelectNodeToVisit(out newOpenListNode);
                if (foundNewNode)
                {
                    Point currentPos = newOpenListNode.Position;
                    foreach (Point point in MainOpenMapTiles(currentPos))
                    {
                        JSearchNode mapTile = new JSearchNode(point,
                            StepDistanceToEnd(point),
                            newOpenListNode.DistanceTraveled + 1);
                        if (!InList(MopenList, point) &&
                            !InList(MclosedList, point))
                        {
                            MopenList.Add(mapTile);
                            Mpaths[point] = newOpenListNode.Position;
                        }
                    }
                    if (currentPos == Mend)
                    {
                        MsearchStatus = JSearchStatus.PathFound;
                    }
                    MopenList.Remove(newOpenListNode);
                    MclosedList.Add(newOpenListNode);
                }
                else
                {
                    MsearchStatus = JSearchStatus.NoPath;
                }
            }
        
            public void DoSearchStep()
            {
                JSearchNode newOpenListNode;

                bool foundNewNode = SelectNodeToVisit(out newOpenListNode);
                if (foundNewNode)
                {
                    Point currentPos = newOpenListNode.Position;
                    foreach (Point point in OpenMapTiles(currentPos))
                    {
                        JSearchNode mapTile = new JSearchNode(point,
                            StepDistanceToEnd(point),
                            newOpenListNode.DistanceTraveled + 1);
                        if (!InList(JopenList, point) &&
                            !InList(JclosedList, point))
                        {
                            JopenList.Add(mapTile);
                            Jpaths[point] = newOpenListNode.Position;
                        }
                    }
                    if (currentPos == end)
                    {
                        JsearchStatus = JSearchStatus.PathFound;
                    }
                    JopenList.Remove(newOpenListNode);
                    JclosedList.Add(newOpenListNode);
                }
                else
                {
                    JsearchStatus = JSearchStatus.NoPath;
                }
            }
            private static bool InList(List<JSearchNode> list, Point point)
            {
                bool inList = false;
                foreach (JSearchNode node in list)
                {
                    if (node.Position == point)
                    {
                        inList = true;
                    }
                }
                return inList;
            }
            private bool MainSelectNodeToVisit(out JSearchNode result)
            {

                result = new JSearchNode();
                bool success = false;
                float smallestDistance = float.PositiveInfinity;
                float currentDistance = 0f;
                if (MopenList.Count > 0)
                {
                    switch (JsearchMethod)
                    {
                        // Breadth first search looks at every possible path in the 
                        // order that we see them in.
                        case JSearchMethod.BreadthFirst:
                            MtotalSearchSteps++;
                            result = MopenList[0];
                            success = true;
                            break;
                        // Best first search always looks at whatever path is closest to
                        // the goal regardless of how long that path is.
                        case JSearchMethod.BestFirst:
                            MtotalSearchSteps++;
                            foreach (JSearchNode node in MopenList)
                            {
                                currentDistance = node.DistanceToGoal;
                                if (currentDistance < smallestDistance)
                                {
                                    success = true;
                                    result = node;
                                    smallestDistance = currentDistance;
                                }
                            }
                            break;
                        // A* search uses a heuristic, an estimate, to try to find the 
                        // best path to take. As long as the heuristic is admissible, 
                        // meaning that it never over-estimates, it will always find 
                        // the best path.
                        case JSearchMethod.AStar:
                            MtotalSearchSteps++;
                            foreach (JSearchNode node in MopenList)
                            {
                                currentDistance = Heuristic(node);
                                // The heuristic value gives us our optimistic estimate 
                                // for the path length, while any path with the same 
                                // heuristic value is equally ‘good’ in this case we’re 
                                // favoring paths that have the same heuristic value 
                                // but are longer.
                                if (currentDistance <= smallestDistance)
                                {
                                    if (currentDistance < smallestDistance)
                                    {
                                        success = true;
                                        result = node;
                                        smallestDistance = currentDistance;
                                    }
                                    else if (currentDistance == smallestDistance &&
                                        node.DistanceTraveled > result.DistanceTraveled)
                                    {
                                        success = true;
                                        result = node;
                                        smallestDistance = currentDistance;
                                    }
                                }
                            }
                            break;
                    }
                }
                return success;




            }
            private bool SelectNodeToVisit(out JSearchNode result)
            {
                result = new JSearchNode();
                bool success = false;
                float smallestDistance = float.PositiveInfinity;
                float currentDistance = 0f;
                if (JopenList.Count > 0)
                {
                    switch (JsearchMethod)
                    {
                        // Breadth first search looks at every possible path in the 
                        // order that we see them in.
                        case JSearchMethod.BreadthFirst:
                            totalSearchSteps++;
                            result = JopenList[0];
                            success = true;
                            break;
                        // Best first search always looks at whatever path is closest to
                        // the goal regardless of how long that path is.
                        case JSearchMethod.BestFirst:
                            totalSearchSteps++;
                            foreach (JSearchNode node in JopenList)
                            {
                                currentDistance = node.DistanceToGoal;
                                if (currentDistance < smallestDistance)
                                {
                                    success = true;
                                    result = node;
                                    smallestDistance = currentDistance;
                                }
                            }
                            break;
                        // A* search uses a heuristic, an estimate, to try to find the 
                        // best path to take. As long as the heuristic is admissible, 
                        // meaning that it never over-estimates, it will always find 
                        // the best path.
                        case JSearchMethod.AStar:
                            totalSearchSteps++;
                            foreach (JSearchNode node in JopenList)
                            {
                                currentDistance = Heuristic(node);
                                // The heuristic value gives us our optimistic estimate 
                                // for the path length, while any path with the same 
                                // heuristic value is equally ‘good’ in this case we’re 
                                // favoring paths that have the same heuristic value 
                                // but are longer.
                                if (currentDistance <= smallestDistance)
                                {
                                    if (currentDistance < smallestDistance)
                                    {
                                        success = true;
                                        result = node;
                                        smallestDistance = currentDistance;
                                    }
                                    else if (currentDistance == smallestDistance &&
                                        node.DistanceTraveled > result.DistanceTraveled)
                                    {
                                        success = true;
                                        result = node;
                                        smallestDistance = currentDistance;
                                    }
                                }
                            }
                            break;
                    }
                }
                return success;
            }


            private static float Heuristic(JSearchNode location)
            {
                return location.DistanceTraveled + location.DistanceToGoal;
            }
            public LinkedList<Point> MainFinalPath()
            {
                LinkedList<Point> path = new LinkedList<Point>();
                if (MsearchStatus == JSearchStatus.PathFound)
                {
                    Point curPrev = Mend;
                    path.AddFirst(curPrev);
                    while (Mpaths.ContainsKey(curPrev))
                    {
                        curPrev = Mpaths[curPrev];
                        path.AddFirst(curPrev);
                    }
                }
                return path;

            }
            public LinkedList<Point> FinalPath()
            {
                LinkedList<Point> path = new LinkedList<Point>();
                if (JsearchStatus == JSearchStatus.PathFound)
                {
                    Point curPrev = end;
                    path.AddFirst(curPrev);
                    while (Jpaths.ContainsKey(curPrev))
                    {
                        curPrev = Jpaths[curPrev];
                        path.AddFirst(curPrev);
                    }
                }
                return path;
            }
            public static int StepDistance(Point pointA, Point pointB)
            {
                int distanceX = Math.Abs(pointA.X - pointB.X);
                int distanceY = Math.Abs(pointA.Y - pointB.Y);

                return distanceX + distanceY;
            }
            public int StepDistanceToEnd(Point point)
            {
                return StepDistance(point, end);
            }

        public void loadSpheresJuneModel(JuneXnaModel juney)
        {
            Vector3 scale, trans;
            Quaternion rota;
            Matrix[] transforms = new Matrix[ScreenManager.spearSphere.Bones.Count];
            ScreenManager.spearSphere.CopyAbsoluteBoneTransformsTo(transforms);
            transforms[0].Decompose(out scale, out rota, out trans);

            foreach (ModelMesh mesh in ScreenManager.spearSphere.Meshes)
            {
                //chestS torsoS hipS lShoulderS rShoulderS lUArmS rUArmS lFArmS rFArmS
                //rHandS lULegS lLLegS rLLegS rULegS headS1
                if (mesh.Name == "forwardSpell")
                    juney.spellSpheres.Add(new boundingSphere(mesh.Name, new BoundingSphere(mesh.BoundingSphere.Center, mesh.BoundingSphere.Radius * scale.X)));
                if (mesh.Name == "rSpearS1" || mesh.Name == "rSpearS2" || mesh.Name == "rSpearS3")
                    juney.rSpear.Add(new boundingSphere(mesh.Name, new BoundingSphere(mesh.BoundingSphere.Center, mesh.BoundingSphere.Radius * scale.X)));
                if (mesh.Name == "lSpearS1" || mesh.Name == "lSpearS2" || mesh.Name == "lSpearS3")
                    juney.lSpear.Add(new boundingSphere(mesh.Name, new BoundingSphere(mesh.BoundingSphere.Center, mesh.BoundingSphere.Radius * scale.X)));
                if (mesh.Name == "shieldS1" || mesh.Name == "shieldS2" || mesh.Name == "shieldS3" || mesh.Name == "shieldS4" || mesh.Name == "shieldS5")
                    juney.roundShield.Add(new boundingSphere(mesh.Name, new BoundingSphere(mesh.BoundingSphere.Center, mesh.BoundingSphere.Radius * scale.X)));
                if (mesh.Name == "axeS1" || mesh.Name == "axeS2" || mesh.Name == "axeS3")
                    juney.axe.Add(new boundingSphere(mesh.Name, new BoundingSphere(mesh.BoundingSphere.Center, mesh.BoundingSphere.Radius * scale.X)));
                if (mesh.Name == "rSwordS1" || mesh.Name == "rSwordS2" || mesh.Name == "rSwordS3")
                    juney.rSword.Add(new boundingSphere(mesh.Name, new BoundingSphere(mesh.BoundingSphere.Center, mesh.BoundingSphere.Radius * scale.X)));

                if (mesh.Name == "lSwordS1" || mesh.Name == "lSwordS2" || mesh.Name == "lSwordS3")
                    juney.lSword.Add(new boundingSphere(mesh.Name, new BoundingSphere(mesh.BoundingSphere.Center, mesh.BoundingSphere.Radius * scale.X)));
                if (mesh.Name == "lTAxeS1")
                    juney.lTAxe.Add(new boundingSphere(mesh.Name, new BoundingSphere(mesh.BoundingSphere.Center, mesh.BoundingSphere.Radius * scale.X)));

                if (mesh.Name == "rTAxeS1")
                    juney.rTAxe.Add(new boundingSphere(mesh.Name, new BoundingSphere(mesh.BoundingSphere.Center, mesh.BoundingSphere.Radius * scale.X)));
                if (mesh.Name == "bowS1" || mesh.Name == "bowS2" || mesh.Name == "bowS3" || mesh.Name == "bowS4" || mesh.Name == "bowS5" || mesh.Name == "bowS6")
                    juney.bow.Add(new boundingSphere(mesh.Name, new BoundingSphere(mesh.BoundingSphere.Center, mesh.BoundingSphere.Radius * scale.X)));
                if (mesh.Name == "arrowS1" || mesh.Name == "arrowS2" || mesh.Name == "arrowS3")
                    juney.arrow.Add(new boundingSphere(mesh.Name, new BoundingSphere(mesh.BoundingSphere.Center, mesh.BoundingSphere.Radius * scale.X)));
                else
                    juney.spheres.Add(new boundingSphere(mesh.Name, new BoundingSphere(mesh.BoundingSphere.Center, mesh.BoundingSphere.Radius * scale.X)));


            }





        }
        public struct JSearchNode
        {
            /// <summary>
            /// Location on the map
            /// </summary>
            public Point Position;

            /// <summary>
            /// Distance to goal estimate
            /// </summary>
            public int DistanceToGoal;

            /// <summary>
            /// Distance traveled from the start
            /// </summary>
            public int DistanceTraveled;

            public JSearchNode(
                Point mapPosition, int distanceToGoal, int distanceTraveled)
            {
                Position = mapPosition;
                DistanceToGoal = distanceToGoal;
                DistanceTraveled = distanceTraveled;
            }
        }
        public enum JSearchStatus
        {
            Stopped,
            Searching,
            NoPath,
            PathFound,
        }
        public enum JSearchMethod
        {
            BreadthFirst,
            BestFirst,
            AStar,
            Max,
        }

    }
}
